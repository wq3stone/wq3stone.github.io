<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【学习笔记】Linux命令</title>
      <link href="/posts/50433.html"/>
      <url>/posts/50433.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考<ahref="https://www.runoob.com/linux/linux-command-manual.html">Linux命令大全 | 菜鸟教程</a>与<ahref="https://www.linuxprobe.com/intro/">《Linux就该这么学》 第 3版</a></p></blockquote><h1 id="服务">服务</h1><p>以下均以<code>api.service</code>服务为例演示，在对服务进行操作时，结尾的<code>.service</code>可以省略。</p><h2 id="启停重载状态">启停、重载、状态</h2><table><thead><tr><th style="text-align: center;">作用</th><th style="text-align: center;">命令</th></tr></thead><tbody><tr><td style="text-align: center;">启动服务</td><tdstyle="text-align: center;"><code>systemctl start api.service</code></td></tr><tr><td style="text-align: center;">停止服务</td><tdstyle="text-align: center;"><code>systemctl stop api.service</code></td></tr><tr><td style="text-align: center;">重启服务</td><tdstyle="text-align: center;"><code>systemctl restart api.service</code></td></tr><tr><td style="text-align: center;">重新加载配置文件</td><tdstyle="text-align: center;"><code>systemctl reload api.service</code></td></tr><tr><td style="text-align: center;">查看服务状态</td><tdstyle="text-align: center;"><code>systemctl status api.service</code></td></tr></tbody></table><h2 id="自启动">自启动</h2><table><colgroup><col style="width: 38%" /><col style="width: 61%" /></colgroup><thead><tr><th style="text-align: center;">作用</th><th style="text-align: center;">命令</th></tr></thead><tbody><tr><td style="text-align: center;">开机自启动</td><tdstyle="text-align: center;"><code>systemctl enable api.service</code></td></tr><tr><td style="text-align: center;">开机不自启动</td><tdstyle="text-align: center;"><code>systemctl disable api.service</code></td></tr><tr><td style="text-align: center;">查看是否开机自启动</td><tdstyle="text-align: center;"><code>systemctl is-enabled api.service</code></td></tr><tr><td style="text-align: center;">查看各个级别服务的自启情况</td><tdstyle="text-align: center;"><code>systemctl list-unit-files --type=service</code></td></tr></tbody></table><h1 id="常用系统工作命令">常用系统工作命令</h1><p>Linux命令格式为<code>命令名称 [命令参数] [命令对象]</code></p><p>命令对象一般指要处理的文件、目录、用户等资源；命令参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用–与-作为前缀，段格式与短格式之间可以进行合并，合并后仅保留一个-（减号）即可。</p><h2 id="echo命令">echo命令</h2><p>用于输出字符串或变量提取后的值到终端。格式为<code>echo [字符串|$变量名]</code></p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202508151156427.png"alt="image-20250815115554255" /><figcaption aria-hidden="true">image-20250815115554255</figcaption></figure><h2 id="date命令">date命令</h2><p>显示或设置系统时间。格式为<code>date [选项] [+指定的格式]</code></p><h3 id="选项">选项</h3><ul><li><strong>-s, –set=STRING</strong>：根据字符串设置系统时间。</li><li><strong>-d, –date=STRING</strong>：通过字符串显示时间格式。</li></ul><h3 id="指定的格式如下">指定的格式如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">%%   输出字符 %</span><br><span class="line">%a   星期几的缩写 (Sun..Sat)</span><br><span class="line">%A   星期的完整名称(Sunday..Saturday)。 </span><br><span class="line">%b   缩写的月份名称（例如，Jan）</span><br><span class="line">%B   完整的月份名称（例如，January）</span><br><span class="line">%c   本地日期和时间（例如，Thu Mar  3 23:05:25 2005）</span><br><span class="line">%d   日 (01..31)</span><br><span class="line">%D   日期，等价于%m/%d/%y</span><br><span class="line">%e   一月中的一天，格式使用空格填充，等价于%_d</span><br><span class="line">%F   完整的日期；等价于 %Y-%m-%d</span><br><span class="line">%H   小时 (00..23)</span><br><span class="line">%I   小时 (01..12)</span><br><span class="line">%j   一年中的第几天 (001..366)</span><br><span class="line">%k   小时，使用空格填充 ( 0..23); 等价于 %_H</span><br><span class="line">%l   小时, 使用空格填充 ( 1..12); 等价于 %_I</span><br><span class="line">%m   月份 (01..12)</span><br><span class="line">%M   分钟 (00..59)</span><br><span class="line">%n   新的一行，换行符</span><br><span class="line">%p   用于表示当地的AM或PM，如果未知则为空白</span><br><span class="line">%P   类似 %p, 但是是小写的</span><br><span class="line">%r   本地的 12 小时制时间(例如 11:11:04 PM)</span><br><span class="line">%R   24 小时制 的小时与分钟; 等价于 %H:%M</span><br><span class="line">%s   自 1970-01-01 00:00:00 UTC 到现在的秒数</span><br><span class="line">%S   秒 (00..60)</span><br><span class="line">%t   插入水平制表符 tab</span><br><span class="line">%T   时间; 等价于 %H:%M:%S</span><br><span class="line">%u   一周中的一天 (1..7); 1 表示星期一</span><br><span class="line">%U   一年中的第几周，周日作为一周的起始 (00..53)</span><br><span class="line">%w   一周中的一天（0..6），0代表星期天</span><br><span class="line">%W   一年中的第几周，周一作为一周的起始（00..53）</span><br><span class="line">%x   本地的日期格式（例如，12/31/99）</span><br><span class="line">%X   本地的日期格式（例如，23:13:48）</span><br><span class="line">%y   年份后两位数字 (00..99)</span><br><span class="line">%Y   年</span><br><span class="line">%Z  时区缩写 （如 EDT）</span><br></pre></td></tr></table></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202508151220868.png"alt="image-20250815122051786" /><figcaption aria-hidden="true">image-20250815122051786</figcaption></figure><h3 id="示例">示例</h3><h4 id="指定格式">+指定格式</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@wq3stone:~# <span class="built_in">date</span></span><br><span class="line">Fri 15 Aug 2025 12:40:56 PM CST</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> <span class="string">&#x27;+%c&#x27;</span></span><br><span class="line">Fri 15 Aug 2025 12:41:06 PM CST</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> <span class="string">&#x27;+%D&#x27;</span></span><br><span class="line">08/15/25</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> <span class="string">&#x27;+%x&#x27;</span></span><br><span class="line">08/15/2025</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> <span class="string">&#x27;+%T&#x27;</span></span><br><span class="line">12:41:49</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> <span class="string">&#x27;+%X&#x27;</span></span><br><span class="line">12:41:59 PM</span><br></pre></td></tr></table></figure><p>当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 -符号，比如说 <strong>date ‘+%-H:%-M:%-S’</strong> 会把时分秒中无意义的 0给去掉，像是原本的 08:09:04 会变为 8:9:4。</p><h4 id="d参数">-d参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@wq3stone:~# <span class="built_in">date</span> +%Y%m%d                   <span class="comment"># 显示年月日</span></span><br><span class="line">20250815</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> -d <span class="string">&quot;+1 day&quot;</span> +%Y%m%d       <span class="comment"># 显示后一天的日期</span></span><br><span class="line">20250816</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> -d <span class="string">&quot;-1 day&quot;</span> +%Y%m%d       <span class="comment"># 显示前一天的日期</span></span><br><span class="line">20250814</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> -d <span class="string">&quot;-1 month&quot;</span> +%Y%m%d     <span class="comment"># 显示上一月的日期</span></span><br><span class="line">20250715</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> -d <span class="string">&quot;+1 month&quot;</span> +%Y%m%d     <span class="comment"># 显示下一月的日期</span></span><br><span class="line">20250915</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> -d <span class="string">&quot;-1 year&quot;</span> +%Y%m%d      <span class="comment"># 显示前一年的日期</span></span><br><span class="line">20240815</span><br><span class="line">root@wq3stone:~# <span class="built_in">date</span> -d <span class="string">&quot;+1 year&quot;</span> +%Y%m%d      <span class="comment"># 显示下一年的日期</span></span><br><span class="line">20260815</span><br></pre></td></tr></table></figure><h4 id="s参数">-s参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">date -s                         # 设置当前时间，只有root权限才能设置，其他只能查看</span><br><span class="line">date -s 20120523                # 设置成20120523，这样会把具体时间设置成00:00:00</span><br><span class="line">date -s 01:01:01                # 设置具体时间，不会对日期做更改</span><br><span class="line">date -s &quot;01:01:01 2012-05-23&quot;   # 这样可以设置全部时间</span><br><span class="line">date -s &quot;01:01:01 20120523&quot;     # 这样可以设置全部时间</span><br><span class="line">date -s &quot;2012-05-23 01:01:01&quot;   # 这样可以设置全部时间</span><br><span class="line">date -s &quot;20120523 01:01:01&quot;     # 这样可以设置全部时间</span><br></pre></td></tr></table></figure><p>只有取得权限者(比如说 root)才能设定系统时间。当您以 root身分更改了系统时间之后，请记得以 <strong>clock -w</strong>来将系统时间写入 <strong>CMOS</strong>中，这样下次重新开机时系统时间才会持续保持最新的正确值。</p><h2 id="reboot命令">reboot命令</h2><p>重启系统，默认只有root用户有此权限</p><h2 id="poweroff命令">poweroff命令</h2><p>关闭系统，默认只有root用户有此权限</p><h2 id="wget命令">wget命令</h2><p>用于在终端中下载网络文件，格式为<code>wget [参数选项] 下载地址</code></p><h3 id="下载控制选项">下载控制选项</h3><table><colgroup><col style="width: 16%" /><col style="width: 18%" /><col style="width: 64%" /></colgroup><thead><tr><th style="text-align: left;">选项</th><th style="text-align: left;">说明</th><th style="text-align: left;">示例</th></tr></thead><tbody><tr><td style="text-align: left;"><code>-O &lt;文件名&gt;</code></td><td style="text-align: left;">指定保存文件名</td><tdstyle="text-align: left;"><code>wget -O myfile.zip https://example.com/file.zip</code></td></tr><tr><td style="text-align: left;"><code>-P &lt;目录&gt;</code></td><td style="text-align: left;">指定下载目录</td><tdstyle="text-align: left;"><code>wget -P ~/downloads https://example.com/file.zip</code></td></tr><tr><td style="text-align: left;"><code>-c</code></td><td style="text-align: left;">断点续传</td><tdstyle="text-align: left;"><code>wget -c https://example.com/bigfile.iso</code></td></tr><tr><td style="text-align: left;"><code>-b</code></td><td style="text-align: left;">后台下载</td><tdstyle="text-align: left;"><code>wget -b https://example.com/largefile.mp4</code></td></tr></tbody></table><h3 id="连接设置选项">连接设置选项</h3><table><colgroup><col style="width: 24%" /><col style="width: 13%" /><col style="width: 61%" /></colgroup><thead><tr><th style="text-align: left;">选项</th><th style="text-align: left;">说明</th><th style="text-align: left;">示例</th></tr></thead><tbody><tr><tdstyle="text-align: left;"><code>--limit-rate=&lt;速度&gt;</code></td><td style="text-align: left;">限速下载</td><tdstyle="text-align: left;"><code>wget --limit-rate=200k https://example.com/file.iso</code></td></tr><tr><td style="text-align: left;"><code>-t &lt;次数&gt;</code></td><td style="text-align: left;">设置重试次数</td><tdstyle="text-align: left;"><code>wget -t 5 https://example.com/unstable.file</code></td></tr><tr><td style="text-align: left;"><code>--timeout=&lt;秒&gt;</code></td><td style="text-align: left;">设置超时时间</td><tdstyle="text-align: left;"><code>wget --timeout=30 https://example.com/slow.file</code></td></tr></tbody></table><h3 id="递归下载选项">递归下载选项</h3><table><colgroup><col style="width: 16%" /><col style="width: 21%" /><col style="width: 61%" /></colgroup><thead><tr><th style="text-align: left;">选项</th><th style="text-align: left;">说明</th><th style="text-align: left;">示例</th></tr></thead><tbody><tr><td style="text-align: left;"><code>-r</code></td><td style="text-align: left;">递归下载</td><tdstyle="text-align: left;"><code>wget -r https://example.com/directory/</code></td></tr><tr><td style="text-align: left;"><code>-l &lt;深度&gt;</code></td><td style="text-align: left;">设置递归深度</td><tdstyle="text-align: left;"><code>wget -r -l 2 https://example.com/</code></td></tr><tr><td style="text-align: left;"><code>-np</code></td><td style="text-align: left;">不追溯至父目录</td><tdstyle="text-align: left;"><code>wget -r -np https://example.com/path/</code></td></tr></tbody></table><h3 id="实用示例与应用场景">实用示例与应用场景</h3><h4 id="示例-1下载单个文件并重命名">示例 1：下载单个文件并重命名</h4><p><code>wget -O linux_distro.iso https://example.com/ubuntu-22.04.iso</code></p><p><strong>说明</strong>：</p><ul><li>从指定 URL 下载 Ubuntu 22.04 镜像</li><li>使用 <code>-O</code> 选项将文件保存为自定义名称<code>linux_distro.iso</code></li></ul><h4 id="示例-2限速下载大文件">示例 2：限速下载大文件</h4><p><code>wget --limit-rate=500k -c https://example.com/large_video.mp4</code></p><p><strong>说明</strong>：</p><ul><li><code>--limit-rate=500k</code> 将下载速度限制在 500KB/s</li><li><code>-c</code> 支持断点续传，网络中断后可继续下载</li></ul><h4 id="示例-3递归下载整个网站">示例 3：递归下载整个网站</h4><p><code>wget -r -l 5 --convert-links --wait=2 https://example-site.com</code></p><p><strong>说明</strong>：</p><ul><li><code>-r</code> 启用递归下载</li><li><code>-l 5</code> 设置最大递归深度为 5 层</li><li><code>--convert-links</code> 转换链接适合本地浏览</li><li><code>--wait=2</code> 每次下载间隔 2 秒，减轻服务器负担</li></ul><hr /><h3 id="高级技巧与注意事项">高级技巧与注意事项</h3><h4 id="批量下载文件">1. 批量下载文件</h4><p>创建一个包含多个 URL 的文本文件 <code>urls.txt</code>，然后使用：</p><p><code>wget -i urls.txt</code></p><h4 id="下载-ftp-资源">2. 下载 FTP 资源</h4><p><code>wget ftp://username:password@ftp.example.com/file.zip</code></p><p><strong>注意</strong>：密码会显示在命令历史中，建议使用<code>--ftp-user</code> 和 <code>--ftp-password</code>选项分开设置。</p><h4 id="常见问题解决">3. 常见问题解决</h4><p><strong>问题 1</strong>：证书错误</p><p><code>wget --no-check-certificate https://example.com</code></p><p><strong>问题 2</strong>：下载被拒绝（403 Forbidden）</p><p><code>wget --user-agent="Mozilla/5.0" https://example.com</code></p><h2 id="ps命令">ps命令</h2><p>ps命令用于查看进程状态。格式为<code>ps [参数]</code></p><p>参数</p><ul><li>a：显示所有进程（包括其他用户的进程）</li><li>u：用户以及其他详细信息</li><li>x：显示没有控制终端的进程</li></ul><p>输出各字段的含义如下：</p><ul><li><strong>USER</strong>: 进程的拥有者</li><li><strong>PID</strong>: 进程的 ID</li><li><strong>%CPU</strong>: 占用的 CPU 使用率</li><li><strong>%MEM</strong>: 占用的内存使用率</li><li><strong>VSZ</strong>: 占用的虚拟内存大小</li><li><strong>RSS</strong>: 占用的物理内存大小</li><li><strong>TTY</strong>: 终端的次要设备号</li><li><strong>STAT</strong>: 进程的状态（如 R 表示运行，S 表示睡眠，Z表示僵尸进程等）</li><li><strong>START</strong>: 进程的启动时间</li><li><strong>TIME</strong>: 进程的累计 CPU 时间</li><li><strong>COMMAND</strong>: 启动进程的命令</li></ul><h3 id="常用示例">常用示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep node</span><br></pre></td></tr></table></figure><p>显示包含node的详细信息</p><h2 id="top命令">top命令</h2><p>动态监视进程活动与系统负载等信息，相当于任务管理器。</p><p>参数</p><ul><li><code>-d &lt;秒数&gt;</code>：指定 top命令的刷新时间间隔，单位为秒。</li><li><code>-n &lt;次数&gt;</code>：指定 top命令运行的次数后自动退出。</li><li><code>-p &lt;进程ID&gt;</code>：仅显示指定进程ID的信息。</li><li><code>-u &lt;用户名&gt;</code>：仅显示指定用户名的进程信息。</li></ul><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202508151326858.png"alt="image-20250815132654756" /><figcaption aria-hidden="true">image-20250815132654756</figcaption></figure><h3 id="系统整体的统计信息">系统整体的统计信息</h3><p><strong>第一行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 13:46:29 up 3 days, 30 min,  2 users,  load average: 0.00, 0.00, 0.00</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">top：当前系统时间。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">up：机器运行了多长时间。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">users</span>：当前登录用户数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">load average：系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</span></span><br></pre></td></tr></table></figure><p><strong>第二行</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Tasks: 110 total,   1 running, 107 sleeping,   2 stopped,   0 zombie</span></span><br><span class="line"><span class="comment"># Tasks：当前有多少进程。</span></span><br><span class="line"><span class="comment"># running：正在运行的进程数。</span></span><br><span class="line"><span class="comment"># sleeping：正在休眠的进程数。</span></span><br><span class="line"><span class="comment"># stopped：停止的进程数。</span></span><br><span class="line"><span class="comment"># zombie：僵尸进程数。</span></span><br></pre></td></tr></table></figure><p><strong>第三行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  0.0 us,  3.2 sy,  0.0 ni, 96.8 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">us：用户空间占CPU的百分比</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sy：内核空间占CPU的百分比</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ni：调整过<span class="built_in">nice</span>值的进程消耗掉的CPU时间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">id</span>: 空闲CPU占用率。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wa: 等待输入输出的CPU时间百分比,一般这个值高代表磁盘io较大。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hi：硬中断占用百分比，硬中断是硬盘、网卡等硬件设备发送给CPU的中断消息，当CPU收到中断消息后需要进行适当的处理(消耗CPU时间)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">si：软中断占用百分比（软中断是由程序发出的中断，最终也会执行相应的处理程序，消耗CPU时间）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">st：Steal Time（窃取时间） ，当系统运行在虚拟化环境（如虚拟机）中时，物理 CPU 资源被同一物理机上的其他虚拟机占用，导致当前虚拟机无法使用 CPU 的时间比例。</span></span><br></pre></td></tr></table></figure><p><strong>第四行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MiB Mem :   1872.6 total,    341.1 free,    638.1 used,    893.5 buff/cache</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">total：物理内存总量。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">free：空闲内存量。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">used：使用的内存量。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">buffer/cache：用作内核缓存的内存量。</span></span><br></pre></td></tr></table></figure><p><strong>第五行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1075.4 avail Mem </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">total：交换区内存总量。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">free：空闲交换区总量。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">used：使用的交换区总量。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">buffer/cache：缓冲的交换区总量。</span></span><br></pre></td></tr></table></figure><p><strong>进程信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 1624 root      20   0  157612  18204  12096 S   2.0  1.0   3:44.32 AliYunDunMonito</span><br><span class="line"> 1603 root      20   0  148488  40856   7196 S   0.7  2.3   1:27.12 AliYunDun</span><br><span class="line">    1 root      20   0  125632   4072   2620 S   0.0  0.2   0:01.36 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0</span><br><span class="line">    4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line"></span><br><span class="line"># PID: 进程id</span><br><span class="line"># USER: 进程所有者的用户名</span><br><span class="line"># PR: 优先级</span><br><span class="line"># NI: nice值，负值表示高优先级，正值表示低优先级</span><br><span class="line"># VIRT: 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class="line"># RES: 代表进程实际使用的物理内存（未被换出到磁盘），单位kb。</span><br><span class="line"># SHR: 共享内存大小，单位kb</span><br><span class="line"># S: 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class="line"># %CPU: 上次更新到现在的CPU时间占用百分比</span><br><span class="line"># %MEM: 进程使用的物理内存百分比</span><br><span class="line"># TIME+: 进程使用的CPU时间总计，单位1/100秒</span><br><span class="line"># COMMAND: 命令名/命令行</span><br></pre></td></tr></table></figure><p>在此页面还可以输入以下按键执行相应的功能（注意大小写区分的）</p><table><thead><tr><th style="text-align: center;">参数</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr><td style="text-align: center;">?</td><td style="text-align: center;">显示在top当中可以输入的命令</td></tr><tr><td style="text-align: center;">P</td><td style="text-align: center;">以CPU的使用资源排序显示</td></tr><tr><td style="text-align: center;">M</td><td style="text-align: center;">以内存的使用资源排序显示</td></tr><tr><td style="text-align: center;">N</td><td style="text-align: center;">以pid排序显示</td></tr><tr><td style="text-align: center;">T</td><td style="text-align: center;">由进程使用的时间累计排序显示</td></tr><tr><td style="text-align: center;">k</td><tdstyle="text-align: center;">给某一个pid一个信号,可以用来杀死进程(9)</td></tr><tr><td style="text-align: center;">r</td><tdstyle="text-align: center;">给某个pid重新定制一个nice值（即优先级)</td></tr><tr><td style="text-align: center;">q</td><td style="text-align: center;">退出top（用Ctrl+C也可以退出top）</td></tr></tbody></table><h2 id="pidof命令">pidof命令</h2><p>查询某个指定服务进程的PID值，格式为<code>pidof [参数] [服务名称]</code></p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202508151401297.png"alt="image-20250815140103180" /><figcaption aria-hidden="true">image-20250815140103180</figcaption></figure><h2 id="kill命令">kill命令</h2><p>kill命令可以发送不同的信号给目标进程，来实现不同的操作，如果不指定信号，默认会发送TERM 信号（15），即终止。若仍无法终止该程序，可使用<code>SIGKILL(9)</code> 信息尝试强制删除程序。</p><h3 id="语法">语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [options] &lt;PID&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;PID&gt;</code> 是要终止进程的进程 ID。</p><p>最常用的信号是：</p><ul><li><code>SIGKILL</code>（信号9）：立即结束进程，不能被捕获或忽略。</li><li><code>SIGTERM</code>（信号15）：正常结束进程，可以被捕获或忽略。</li><li><code>SIGSTOP</code>（信号19）：暂停进程，不能被捕获、忽略或结束。</li><li><code>SIGCONT</code>（信号18）：继续执行被暂停的进程。</li><li><code>SIGINT</code>（信号2）：通常是Ctrl+C产生的信号，可以被进程捕获或忽略。</li></ul><h2 id="killall命令">killall命令</h2><p>killall命令用于终止某个指定名称的服务对应的全部进程，格式为<code>killall [参数] [进程名称]</code></p><p><strong>常用选项</strong></p><ul><li><strong>-e | –exact</strong>：进程名需要完全匹配</li><li><strong>-I | –ignore-case</strong>：忽略大小写</li><li><strong>-g | –process-group</strong>：终止进程组</li><li><strong>-i | –interactive</strong>：终止前询问用户确认</li><li><strong>-l | –list</strong>：列出所有信号名称</li><li><strong>-q | –quiet</strong>：进程未结束时不输出任何信息</li><li><strong>-r | –regexp</strong>：将进程名解释为正则表达式</li><li><strong>-s | –signal</strong>：发送指定信号</li><li><strong>-u | –user</strong>：终止指定用户的进程</li><li><strong>-v | –verbose</strong>：显示详细执行过程</li><li><strong>-w | –wait</strong>：等待所有进程结束</li><li><strong>-V | –version</strong>：显示版本信息</li><li><strong>–help</strong>：显示帮助信息</li></ul><h1 id="系统状态检测命令">系统状态检测命令</h1><h2 id="ifconfig命令">ifconfig命令</h2><p>ifconfig用于获取网卡配置与网络状态等信息，格式为<code>ifconfig [网络设备] [参数]</code></p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202508151421702.png"alt="image-20250815142122606" /><figcaption aria-hidden="true">image-20250815142122606</figcaption></figure><h2 id="uname命令">uname命令</h2><p>uname命令用于查看系统内核与系统版本等信息，格式为<code>uname [-a]</code></p><h2 id="uptime命令">uptime命令</h2><p>与top命令的第一行数据一样</p><h2 id="free命令">free命令</h2><p>free命令用于显示当前系统中内存的使用量</p><p><strong>输出信息</strong></p><ul><li>total：总物理内存</li><li>used：已经使用的物理内存</li><li>free：没有使用过的物理内存</li><li>shared：多进程共享内存</li><li>buff/cache：读写缓存内存，这部分内存是当空闲来用的，当free内存不足时，linux内核会将此内存释放</li><li>available：还可以被应用程序使用的物理内存</li></ul><h2 id="who命令">who命令</h2><p>查看当前登入主机的用户终端信息</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202508151439380.png"alt="image-20250815143959320" /><figcaption aria-hidden="true">image-20250815143959320</figcaption></figure><h2 id="last命令">last命令</h2><p>查看所有系统的登录信息</p><h2 id="history命令">history命令</h2><p>查看历史执行过的命令，可以使用<code>!编码数字</code>来重复执行某一次的命令，若使用<code>-c</code>参数，会清除所有的历史命令记录。</p><p>默认保存近1000条命令，可以修改<code>/etc/profile</code>中的<code>HISTSIZE</code>变量值修改保存命令数</p><p>历史命令被存储在用户家目录中的<code>.bash_history</code>文件中，可以使用<code>cat ~/.bash_history</code>查看</p><h1 id="工作目录切换命令">工作目录切换命令</h1><h2 id="pwd命令">pwd命令</h2><p>显示当前所处的工作目录</p><h2 id="cd命令">cd命令</h2><p>切换工作路径，格式为<code>cd [目录名称]</code></p><p>除此以外，cd命令还有以下用法</p><ul><li><code>cd ..</code>进入上级目录</li><li><code>cd ~</code>切换到当前用户的家目录</li><li><code>cd ~username</code>切换到其他用户的家目录</li><li><code>cd -</code>切换到上次所处的目录</li><li><code>cd /</code>切换到根目录</li></ul><h2 id="ls命令">ls命令</h2><p>显示目录中的文件信息，默认是当前目录。</p><p><strong>参数</strong></p><ul><li><code>-a</code>或<code>--all</code>：显示全部文件（包含隐藏文件）</li><li><code>-l</code>：显示当前目录下文件的详细信息</li><li><code>-d</code>：查看目录属性信息</li><li><code>-R</code>或<code>--recursive</code>：递归显示当前目录中的所有文件和子目录</li></ul><h1 id="文本文件编辑命令">文本文件编辑命令</h1><h2 id="cat命令">cat命令</h2><p>查看内容较少的纯文本文件，格式为<code>cat [选项] [文件]</code></p><p>可以使用<code>-n</code>参数显示行号</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202508151854450.png"alt="image-20250815185421242" /><figcaption aria-hidden="true">image-20250815185421242</figcaption></figure><ul><li>显示文件内容：<code>cat filename</code>会将指定文件的内容输出到终端上。</li><li>连接文件：<code>cat file1 file2 &gt; combined_file</code> 可以将file1 和 file2 的内容连接起来，并将结果输出到 combined_file 中。</li><li>创建文件：可以使用 <code>cat</code> 命令来创建文件，例如<code>cat &gt; filename</code>，然后你可以输入文本，按<font color='red'>Ctrl+D</font> 来保存并退出。</li><li>在终端显示文件：可以将 <code>cat</code>与管道（<code>|</code>）结合使用，用来显示其他命令的输出，例如<code>ls -l | cat</code> 会将 <code>ls -l</code> 的输出通过<code>cat</code> 打印到终端上。</li></ul><h3 id="实例">实例</h3><p><strong>查看文件内容：</strong>显示文件 filename 的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure><p><strong>创建文件：</strong>将标准输入重定向到文件filename，覆盖该文件的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; filename</span><br></pre></td></tr></table></figure><p><strong>追加内容到文件：</strong>将标准输入追加到文件 filename的末尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; filename</span><br></pre></td></tr></table></figure><p><strong>连接文件：</strong>将 file1 和 file2 的内容合并到 file3中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 &gt; file3</span><br></pre></td></tr></table></figure><p><strong>显示多个文件的内容：</strong>同时显示 file1 和 file2的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2</span><br></pre></td></tr></table></figure><p><strong>使用管道：</strong>将 cat命令的输出作为另一个命令的输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename | command</span><br></pre></td></tr></table></figure><p><strong>查看文件的最后几行：</strong>显示文件 filename 的最后 10行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename | tail -n 10</span><br></pre></td></tr></table></figure><p><strong>使用 -n 选项显示行号：</strong>显示文件 filename的内容，并在每行的前面加上行号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n filename</span><br></pre></td></tr></table></figure><p>使用 -b 选项仅显示非空行的行号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b filename</span><br></pre></td></tr></table></figure><p><strong>使用 -s 选项合并空行：</strong>显示文件 filename的内容，并合并连续的空行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -s filename</span><br></pre></td></tr></table></figure><p><strong>使用 -t 选项显示制表符：</strong>显示文件 filename的内容，并用 ^I 表示制表符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -t filename</span><br></pre></td></tr></table></figure><p><strong>使用 -e 选项显示行结束符：</strong>显示文件 filename的内容，并用 $ 表示行结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -e filename</span><br></pre></td></tr></table></figure><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><p>清空 /etc/test.txt 文档内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; /etc/test.txt</span><br></pre></td></tr></table></figure><h2 id="more命令">more命令</h2><p>more 命令类似 cat，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按b 键就会往回（back）一页显示。</p><p><strong>参数</strong>：</p><ul><li>-num 一次显示的行数</li><li>+num 从第 num 行开始显示</li></ul><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202508160045912.png"alt="image-20250816004515819" /><figcaption aria-hidden="true">image-20250816004515819</figcaption></figure><p><strong>常用操作命令</strong></p><ul><li>Enter 向下n行，需要定义。默认为1行</li><li>Ctrl+F 向下滚动一屏</li><li>空格键 向下滚动一屏</li><li>Ctrl+B 返回上一屏</li><li>= 输出当前行的行号</li><li><code>:f</code> 输出文件名和当前行的行号</li><li>V 调用vi编辑器</li><li>!命令 调用Shell，并执行命令</li><li>q 退出more</li></ul><h2 id="head命令">head命令</h2><p>head 命令可用于查看文件的开头部分的内容。</p><p><strong>参数</strong></p><ul><li><code>-n</code>：行数，默认为10</li><li><code>-c</code>：字节数</li></ul><h2 id="tail命令">tail命令</h2><p>tail 命令可用于查看文件结尾部分的内容。</p><p><strong>参数</strong></p><ul><li><code>-f</code>：循环读取，把最尾部的内容显示在屏幕上，并且不断刷新，只要文件更新就可以看到最新的文件内容。</li><li><code>-n</code>：显示文件的尾部的行数</li><li><code>-c</code>：显示文件的尾部的字节数</li></ul><p>显示文件 notes.log 的内容，从第 20 行至文件末尾:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n +20 notes.log</span><br></pre></td></tr></table></figure><h2 id="tr命令">tr命令</h2><h2 id="wc命令">wc命令</h2><p>统计文件的行数、单词数、字节数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。</p><p><strong>参数</strong>：</p><ul><li>-c或–bytes或–chars 只显示Bytes数。</li><li>-l或–lines 显示行数。</li><li>-w或–words 只显示字数。</li></ul><h2 id="stat命令">stat命令</h2><p>显示inode内容（文件状态信息）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@wq3stone:/home/project/nav# stat test</span><br><span class="line">  File: test</span><br><span class="line">  Size: 13        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fc03h/64515dInode: 402733      Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2025-08-16 01:28:22.984012957 +0800</span><br><span class="line">Modify: 2025-08-16 01:28:13.471715469 +0800</span><br><span class="line">Change: 2025-08-16 01:28:13.471715469 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><h2 id="cut命令">cut命令</h2><p>按列提取文本</p><h2 id="diff命令">diff命令</h2><p>比较文件的差异</p><h1 id="文件目录管理命令">文件目录管理命令</h1><h2 id="touch命令">touch命令</h2><p><strong>参数说明</strong>：</p><ul><li><code>-a</code>：改变档案的读取时间记录。</li><li><code>-m</code>：改变档案的修改时间记录。</li><li><code>-d</code>：设定时间与日期，可以使用各种不同的格式。</li></ul><h2 id="mkdir命令">mkdir命令</h2><p>创建目录，格式为<code>mkdir [-p] dirName</code></p><p><strong>参数说明</strong>：</p><ul><li>-p 确保目录名称存在，不存在的就建一个。</li></ul><p>在工作目录下的<code>test1</code>目录中，建立一个名为<code>test2</code>的子目录。若<code>test1</code>目录原本不存在，则新建一个。（注：本例若不加<code>-p</code>参数，且原本<code>test1</code>目录不存在，则产生错误。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p test1/test2</span><br></pre></td></tr></table></figure><h2 id="cp命令">cp命令</h2><p>将文件或目录从一个位置复制到另一个位置，同时可以选择保留原文件的属性（如权限、时间戳等）。格式为<code>cp [options] source dest</code></p><p><strong>命令参数</strong></p><ul><li><code>-r</code> 或<code>-R</code>：递归复制目录及其内容（用于复制目录）。</li><li><code>-i</code>：交互模式，覆盖前提示用户确认。</li><li><code>-f</code>：强制复制，覆盖目标文件而不提示。</li><li><code>-v</code>：显示详细的复制过程（verbose）。</li><li><code>-p</code>：保留文件的原始属性（如权限、时间戳等）。</li><li><code>-a</code>：归档模式，等同于<code>-dpR</code>，保留所有文件属性和递归复制目录。</li><li><code>-u</code>：仅当源文件比目标文件新时才复制（更新模式）。</li><li><code>-l</code>：创建硬链接而不是复制文件。</li><li><code>-s</code>：创建符号链接（软链接）而不是复制文件。</li></ul><h2 id="mv命令">mv命令</h2><p>为文件或目录改名、或将文件或目录移入其它位置。</p><p><strong>参数说明</strong>：</p><ul><li><strong>-b</strong>:当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</li><li><strong>-i</strong>:如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入y 表示直接覆盖，输入 n 表示取消该操作。</li><li><strong>-f</strong>:如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</li><li><strong>-n</strong>: 不要覆盖任何已存在的文件或目录。</li><li><strong>-u</strong>：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li></ul><table><colgroup><col style="width: 44%" /><col style="width: 55%" /></colgroup><thead><tr><th style="text-align: left;">命令格式</th><th style="text-align: left;">运行结果</th></tr></thead><tbody><tr><tdstyle="text-align: left;"><code>mv source_file(文件) dest_file(文件)</code></td><td style="text-align: left;">将源文件名 source_file 改为目标文件名dest_file</td></tr><tr><tdstyle="text-align: left;"><code>mv source_file(文件) dest_directory(目录)</code></td><td style="text-align: left;">将文件 source_file 移动到目标目录dest_directory 中</td></tr><tr><tdstyle="text-align: left;"><code>mv source_directory(目录) dest_directory(目录)</code></td><td style="text-align: left;">目录名 dest_directory 已存在，将source_directory 移动到目录名 dest_directory 中；目录名 dest_directory不存在则 source_directory 改名为目录名 dest_directory</td></tr><tr><tdstyle="text-align: left;"><code>mv source_directory(目录) dest_file(文件)</code></td><td style="text-align: left;">出错</td></tr></tbody></table><p>将<code>/usr/home</code>下的所有文件和目录移到当前目录下，命令行为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /usr/home/* .</span><br></pre></td></tr></table></figure><h2 id="rm命令">rm命令</h2><p>删除一个文件或目录。</p><p><strong>参数</strong>：</p><ul><li>-i 删除前逐一询问确认。</li><li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</li><li>-r 将目录及以下之档案亦逐一删除。</li></ul><p><strong>实例</strong></p><p>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># rm  test.txt </span><br><span class="line">rm：是否删除 一般文件 &quot;test.txt&quot;? y  </span><br><span class="line"># rm  homework  </span><br><span class="line">rm: 无法删除目录&quot;homework&quot;: 是一个目录  </span><br><span class="line"># rm  -r  homework  </span><br><span class="line">rm：是否删除 目录 &quot;homework&quot;? y </span><br></pre></td></tr></table></figure><p>删除当前目录下的所有文件及目录，命令行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm  -r  * </span><br></pre></td></tr></table></figure><p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p><h2 id="dd命令">dd命令</h2><h2 id="file命令">file命令</h2><h1 id="打包压缩与搜索命令">打包压缩与搜索命令</h1><h2 id="tar命令">tar命令</h2><p><strong>基本操作选项</strong></p><ul><li><p><code>-c</code>：创建一个新的归档文件。</p></li><li><p><code>-x</code>：解压归档文件。</p></li><li><p><code>-t</code>：列出归档文件的内容。</p></li><li><p><code>-r</code>：向现有归档文件中追加文件。</p></li><li><p><code>-u</code>：仅追加比归档文件中已有文件更新的文件。</p></li><li><p><code>-d</code>：找到归档文件中与文件系统不同步的差异。</p></li><li><p><code>-A</code>：将一个 <code>.tar</code> 文件追加到另一个<code>.tar</code> 文件中。</p></li><li><p><code>-f &lt;file&gt;</code>：指定归档文件的名称（必须放在选项列表的最后）</p></li></ul><p><strong>实例</strong></p><p><strong>1、创建归档文件：</strong>将文件 file1、file2 和 directory打包到一个名为 archive.tar 的归档文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf archive.tar file1 file2 directory</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>: 创建新的归档文件</li><li><code>-v</code>: 显示详细输出，列出被添加到归档中的文件</li><li><code>-f</code>: 指定归档文件的名称</li></ul><p><strong>2、解压归档文件：</strong>解压名为 archive.tar的归档文件，还原其中包含的文件和目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf archive.tar</span><br></pre></td></tr></table></figure><ul><li><code>-x</code>: 解压归档文件</li><li><code>-v</code>: 显示详细输出，列出被解压的文件</li><li><code>-f</code>: 指定要解压的归档文件的名称</li></ul><p><strong>3、压缩归档文件：</strong>将名为 directory的目录打包成一个归档文件，然后使用 gzip 进行压缩，生成名为archive.tar.gz 的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz directory</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>: 创建新的归档文件</li><li><code>-z</code>: 使用 gzip 压缩归档文件</li><li><code>-v</code>: 显示详细输出，列出被添加到归档中的文件</li><li><code>-f</code>: 指定归档文件的名称</li></ul><p><strong>4、列出归档文件中的内容：</strong>列出名为 archive.tar的归档文件中包含的所有文件和目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf archive.tar</span><br></pre></td></tr></table></figure><ul><li><code>-t</code>: 列出归档文件中的内容</li><li><code>-v</code>: 显示详细输出，列出归档文件中的所有文件和目录</li><li><code>-f</code>: 指定要列出内容的归档文件的名称</li></ul><p><strong>5、追加文件到已存在的归档中：</strong>将名为 newfile的文件添加到已存在的名为 archive.tar 的归档文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -rvf archive.tar newfile</span><br></pre></td></tr></table></figure><ul><li><code>-r</code>: 向已存在的归档中追加文件</li><li><code>-v</code>: 显示详细输出，列出被添加到归档中的文件</li><li><code>-f</code>: 指定已存在的归档文件的名称</li></ul><p><strong>6、创建一个经过 gzip 压缩的归档文件：</strong>打包 directory目录下的所有文件和子目录，并使用 gzip 压缩，生成名为 archive.tar.gz的归档文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf archive.tar.gz directory</span><br></pre></td></tr></table></figure><ul><li><code>-z</code>: 表示要使用 gzip 进行压缩。</li><li><code>-c</code>: 表示创建新的归档文件。</li><li><code>-v</code>: 表示详细输出，列出被添加到归档中的文件。</li><li><code>-f archive.tar.gz</code>: 指定归档文件的名称为<code>archive.tar.gz</code>。</li></ul><p><strong>7、解压一个已经被 gzip 压缩的归档文件：</strong>解压example.tar.gz 文件，并在当前目录下恢复其中包含的文件和目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf example.tar.gz</span><br></pre></td></tr></table></figure><ul><li><code>-z</code>: 表示要使用 gzip 解压归档文件。</li><li><code>-x</code>: 表示解压操作。</li><li><code>-v</code>: 表示详细输出，列出被解压的文件。</li><li><code>-f example.tar.gz</code>: 指定要解压的归档文件的名称为<code>example.tar.gz</code>。</li></ul><h3 id="指定压缩格式">指定压缩格式</h3><p>tar 可以结合不同的压缩程序来创建和解压压缩归档文件。</p><p><strong>z</strong> : 使用 gzip 压缩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz directory</span><br><span class="line">tar -xzvf archive.tar.gz</span><br></pre></td></tr></table></figure><p><strong>j</strong>: 使用 bzip2 压缩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cjvf archive.tar.bz2 directory</span><br><span class="line">tar -xjvf archive.tar.bz2</span><br></pre></td></tr></table></figure><p><strong>J</strong>: 使用 xz 压缩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cJvf archive.tar.xz directory</span><br><span class="line">tar -xJvf archive.tar.xz</span><br></pre></td></tr></table></figure><h2 id="grep命令">grep命令</h2><p><strong>常用选项：</strong>：</p><ul><li><code>-i</code>：忽略大小写进行匹配。</li><li><code>-v</code>：反向查找，只打印不匹配的行。</li><li><code>-n</code>：显示匹配行的行号。</li><li><code>-r</code>：递归查找子目录中的文件。</li><li><code>-l</code>：只打印匹配的文件名。</li><li><code>-c</code>：只打印匹配的行数。</li></ul><p><strong>实例</strong></p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><p>2、在文件夹 dir 中递归查找所有文件中匹配正则表达式 “pattern”的行，并打印匹配行所在的文件名和行号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r -n pattern dir/</span><br></pre></td></tr></table></figure><p>3、在标准输入中查找字符串 “world”，并只打印匹配的行数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello world&quot; | grep -c world</span><br></pre></td></tr></table></figure><p>4、在当前目录中，查找后缀有 file 字样的文件中包含 test字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep test *file </span><br></pre></td></tr></table></figure><p>结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  </span><br><span class="line">testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  </span><br><span class="line">testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  </span><br><span class="line">testfile_2:Linux test #列出testfile_2 文件中包含test字符的行 </span><br></pre></td></tr></table></figure><p>5、以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r update /etc/acpi </span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r update /etc/acpi #以递归的方式查找“etc/acpi”  </span><br><span class="line">#下包含“update”的文件  </span><br><span class="line">/etc/acpi/ac.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  </span><br><span class="line">Rather than  </span><br><span class="line">/etc/acpi/resume.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of  </span><br><span class="line">IO.) Rather than  </span><br><span class="line">/etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update </span><br></pre></td></tr></table></figure><p>6、反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。</p><p>查找文件名中包含 test 的文件中不包含test的行，此时，使用的命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v test *test*</span><br></pre></td></tr></table></figure><p>结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行  </span><br><span class="line">testfile1:helLinux!  </span><br><span class="line">testfile1:Linis a free Unix-type operating system.  </span><br><span class="line">testfile1:Lin  </span><br><span class="line">testfile_1:HELLO LINUX!  </span><br><span class="line">testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  </span><br><span class="line">testfile_1:THIS IS A LINUX TESTFILE!  </span><br><span class="line">testfile_2:HELLO LINUX!  </span><br><span class="line">testfile_2:Linux is a free unix-type opterating system. </span><br></pre></td></tr></table></figure><h2 id="egrep命令">egrep命令</h2><p>使用正则表达式匹配文本，格式为<code>egrep [范本模式] [文件或目录]</code></p><p><strong>参数说明：</strong></p><ul><li>[范本模式] ：查找的字符串规则。</li><li>[文件或目录] ：查找的目标文件或目录。</li></ul><h2 id="find命令">find命令</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Spring依赖注入详解</title>
      <link href="/posts/51928.html"/>
      <url>/posts/51928.html</url>
      
        <content type="html"><![CDATA[<h1 id="spring依赖注入详解">Spring依赖注入详解</h1><h2 id="一spring依赖注入概述">一、Spring依赖注入概述</h2><p>Spring框架是当今Java开发领域中不可或缺的一部分，它极大地简化了Java企业级应用的开发。Spring框架的核心功能之一是依赖注入（DependencyInjection，DI）。依赖注入是一种设计模式，用于实现对象之间的解耦。通过依赖注入，Spring容器负责管理对象的创建、依赖关系的配置和生命周期管理，从而让开发者可以专注于业务逻辑的实现。</p><p>在传统的Java开发中，对象之间的依赖关系通常是通过直接在代码中实例化对象来实现的。例如，一个<code>UserService</code>类可能直接创建一个<code>UserDao</code>类的实例，然后调用它的方法。这种方式的问题在于，<code>UserService</code>类与<code>UserDao</code>类之间存在紧密的耦合关系。如果将来需要更换<code>UserDao</code>的实现，或者对<code>UserDao</code>进行单元测试，就需要修改<code>UserService</code>类的代码。</p><p>依赖注入的核心思想是将对象之间的依赖关系从代码中分离出来，交由Spring容器进行管理。Spring容器会根据配置信息创建对象，并将它们之间的依赖关系注入到相应的对象中。这样，对象之间只需要声明依赖关系，而不需要关心依赖对象的具体创建过程。这种方式极大地降低了对象之间的耦合度，提高了代码的可维护性和可测试性。</p><h2 id="二依赖注入的实现方式">二、依赖注入的实现方式</h2><p>Spring提供了多种依赖注入的方式，主要包括基于XML配置文件、基于注解和基于Java配置类的方式。以下将详细介绍这三种方式。</p><h3id="一基于xml配置文件的依赖注入">（一）基于XML配置文件的依赖注入</h3><p>在Spring的早期版本中，XML配置文件是实现依赖注入的主要方式。通过在XML文件中定义Bean的配置信息，Spring容器可以创建对象并注入依赖关系。</p><h4 id="注入基本数据类型和字符串">1. 注入基本数据类型和字符串</h4><p>在XML配置文件中，可以使用<code>&lt;property&gt;</code>标签的<code>value</code>属性来注入基本数据类型和字符串。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>userService</code>Bean的<code>name</code>属性被注入了字符串<code>"John"</code>，<code>age</code>属性被注入了整数<code>25</code>。</p><h4 id="注入bean对象">2. 注入Bean对象</h4><p>当需要注入一个Bean对象时，可以使用<code>&lt;property&gt;</code>标签的<code>ref</code>属性。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>userService</code>的<code>userDao</code>属性被注入了<code>userDao</code>Bean。</p><h4 id="注入集合类型">3. 注入集合类型</h4><p>Spring支持注入多种集合类型，包括数组、<code>List</code>、<code>Set</code>、<code>Map</code>和<code>Properties</code>。</p><ul><li><strong>数组注入</strong>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataList&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.DataList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myArray&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>List注入</strong>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Set注入</strong>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mySet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Map注入</strong>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Properties注入</strong>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myProperties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;key1&quot;</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;key2&quot;</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这些例子中，<code>DataList</code>类的各个集合属性被注入了相应的值。</p><h4 id="使用spel表达式">4. 使用SpEL表达式</h4><p>Spring表达式语言（SpEL）是一种强大的表达式语言，可以在XML配置文件中使用。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;5&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;&#x27;John&#x27;&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;salayOfYear&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;salaryGenerator.getSalaryOfYear(5000)&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>count</code>属性被注入了整数<code>5</code>，<code>name</code>属性被注入了字符串<code>"John"</code>，<code>salayOfYear</code>属性通过调用<code>salaryGenerator</code>的<code>getSalaryOfYear</code>方法注入了返回值。</p><h3 id="二基于注解的依赖注入">（二）基于注解的依赖注入</h3><p>随着Spring框架的发展，注解逐渐成为一种更简洁、更灵活的依赖注入方式。使用注解可以在代码中直接声明依赖关系，而无需编写繁琐的XML配置文件。</p><h4 id="autowired注解">1. <span class="citation"data-cites="Autowired注解">@Autowired注解</span></h4><p><code>@Autowired</code>注解用于自动注入依赖关系。它可以应用于字段、构造器或setter方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>userDao</code>字段被自动注入了<code>UserDao</code>类型的Bean。</p><p><code>@Autowired</code>注解默认按照类型进行注入。如果容器中有多个同类型的Bean，Spring会抛出<code>NoUniqueBeanDefinitionException</code>异常。为了避免这种情况，可以使用<code>@Qualifier</code>注解指定注入的Bean的名称。</p><h4 id="qualifier注解">2. <span class="citation"data-cites="Qualifier注解">@Qualifier注解</span></h4><p>当存在多个同类型的Bean时，可以使用<code>@Qualifier</code>注解指定注入的Bean的名称。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDaoImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>userDao</code>字段被注入了名为<code>userDaoImpl</code>的<code>UserDao</code>类型的Bean。</p><h4 id="resource和inject注解">3. <span class="citation"data-cites="Resource和">@Resource和</span><span class="citation"data-cites="Inject注解">@Inject注解</span></h4><p><code>@Resource</code>和<code>@Inject</code>注解也可以用于依赖注入。<code>@Resource</code>是JavaEE的标准注解，而<code>@Inject</code>是JSR-330标准注解。它们与<code>@Autowired</code>注解类似，但有一些细微的差别。</p><p><code>@Resource</code>注解默认按照名称进行注入。如果找不到与名称匹配的Bean，则会按照类型进行注入。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;userDaoImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>userDao</code>字段被注入了名为<code>userDaoImpl</code>的<code>UserDao</code>类型的Bean。</p><p><code>@Inject</code>注解与<code>@Autowired</code>注解类似，但它不支持<code>@Qualifier</code>注解。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>userDao</code>字段被自动注入了<code>UserDao</code>类型的Bean。</p><h4 id="value注解">4. <span class="citation"data-cites="Value注解">@Value注解</span></h4><p><code>@Value</code>注解用于注入基本数据类型和字符串。它可以与SpEL表达式一起使用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;John&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;5&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;salaryGenerator.getSalaryOfYear(5000)&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salayOfYear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>name</code>字段被注入了字符串<code>"John"</code>，<code>count</code>字段被注入了整数<code>5</code>，<code>salayOfYear</code>字段通过调用<code>salaryGenerator</code>的<code>getSalaryOfYear</code>方法注入了返回值。</p><h3 id="三基于java配置类的依赖注入">（三）基于Java配置类的依赖注入</h3><p>从Spring3.0开始，Spring引入了基于Java配置类的依赖注入方式。这种方式使用注解和Java代码来定义Bean的配置信息，而无需编写XML配置文件。基于Java配置类的依赖注入更加简洁、灵活，也更容易理解和维护。</p><h4 id="configuration注解">1. <span class="citation"data-cites="Configuration注解">@Configuration注解</span></h4><p><code>@Configuration</code>注解用于定义配置类。配置类可以包含多个<code>@Bean</code>注解的方法，这些方法返回的实例将被注册为Spring容器中的Bean。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>AppConfig</code>类是一个配置类，它定义了两个Bean：<code>userDao</code>和<code>userService</code>。<code>userDao</code>方法返回一个<code>UserDaoImpl</code>实例，<code>userService</code>方法返回一个<code>UserServiceImpl</code>实例，并将<code>userDao</code>注入到<code>userService</code>中。</p><h4 id="component注解">2. <span class="citation"data-cites="Component注解">@Component注解</span></h4><p><code>@Component</code>注解用于标记一个类为Spring的组件。Spring会自动扫描带有<code>@Component</code>注解的类，并将其注册为Spring容器中的Bean。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>UserDaoImpl</code>类被标记为一个Spring组件，Spring会自动扫描并注册这个类为一个Bean。</p><h4 id="componentscan注解">3. <span class="citation"data-cites="ComponentScan注解">@ComponentScan注解</span></h4><p><code>@ComponentScan</code>注解用于指定Spring扫描组件的包路径。默认情况下，Spring会扫描配置类所在的包及其子包。如果需要扫描其他包，可以使用<code>@ComponentScan</code>注解指定包路径。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Spring会扫描<code>com.example</code>包及其子包中的组件。</p><h4 id="bean注解">4. <span class="citation"data-cites="Bean注解">@Bean注解</span></h4><p><code>@Bean</code>注解用于定义一个Bean。它通常用于配置类中的方法上，方法的返回值将被注册为Spring容器中的Bean。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>userDao</code>方法和<code>userService</code>方法都被标记为<code>@Bean</code>注解，它们的返回值将被注册为Spring容器中的Bean。</p><h2 id="三依赖注入的原理">三、依赖注入的原理</h2><p>Spring依赖注入的原理基于反射和代理机制。Spring容器通过反射机制创建对象，并通过代理机制管理对象之间的依赖关系。</p><h3 id="一反射机制">（一）反射机制</h3><p>反射机制是Java语言的一个重要特性，它允许程序在运行时动态地获取类的信息、创建对象、调用方法等。Spring容器利用反射机制来创建Bean对象。</p><p>当Spring容器启动时，它会加载配置信息，并根据配置信息创建Bean对象。Spring容器会使用反射机制调用Bean类的构造器来创建对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br></pre></td></tr></table></figure><p>Spring容器会使用反射机制调用<code>UserServiceImpl</code>类的构造器来创建<code>userService</code>对象。</p><h3 id="二代理机制">（二）代理机制</h3><p>代理机制是Spring依赖注入的另一个重要特性。Spring容器通过代理机制管理对象之间的依赖关系。</p><p>当一个Bean对象需要注入依赖关系时，Spring容器会创建一个代理对象。代理对象会拦截对Bean对象的调用，并在调用之前注入依赖关系。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>UserServiceImpl</code>类的<code>userDao</code>属性需要注入依赖关系。Spring容器会创建一个代理对象，拦截对<code>userService</code>对象的调用，并在调用之前注入<code>userDao</code>依赖关系。</p><h3 id="三依赖注入的生命周期">（三）依赖注入的生命周期</h3><p>Spring容器管理Bean对象的生命周期，包括创建、初始化、使用和销毁。Spring容器会在Bean对象的生命周期中调用相应的回调方法。</p><ul><li><strong>创建</strong>：Spring容器通过反射机制调用Bean类的构造器来创建对象。</li><li><strong>初始化</strong>：Spring容器会在创建对象之后调用Bean的初始化方法。初始化方法可以使用<code>@PostConstruct</code>注解或<code>InitializingBean</code>接口来定义。</li><li><strong>使用</strong>：Spring容器会将创建好的Bean对象注入到其他Bean对象中，并调用它们的方法。</li><li><strong>销毁</strong>：Spring容器会在Bean对象不再使用时调用Bean的销毁方法。销毁方法可以使用<code>@PreDestroy</code>注解或<code>DisposableBean</code>接口来定义。</li></ul><h2 id="四依赖注入的优缺点">四、依赖注入的优缺点</h2><p>依赖注入是一种非常有用的设计模式，但它也有一些优缺点。以下将详细介绍依赖注入的优缺点。</p><h3 id="一优点">（一）优点</h3><ul><li><strong>降低耦合度</strong>：依赖注入将对象之间的依赖关系从代码中分离出来，交由Spring容器进行管理。这样可以降低对象之间的耦合度，提高代码的可维护性和可测试性。</li><li><strong>提高可测试性</strong>：依赖注入使得对象之间的依赖关系可以通过注入的方式进行替换，这使得单元测试变得更加容易。例如，可以将一个真实的依赖对象替换为一个模拟对象，从而方便地进行单元测试。</li><li><strong>提高代码的可重用性</strong>：依赖注入使得对象之间的依赖关系可以通过配置的方式进行管理，这使得代码的可重用性得到了提高。例如，一个Bean对象可以在不同的应用程序中被重用，而无需修改代码。</li><li><strong>提高开发效率</strong>：依赖注入使得Spring容器可以自动管理对象的创建和依赖关系的注入，这使得开发效率得到了提高。开发者可以专注于业务逻辑的实现，而无需关心对象的创建和依赖关系的管理。</li></ul><h3 id="二缺点">（二）缺点</h3><ul><li><strong>增加学习成本</strong>：依赖注入是一种比较复杂的设计模式，需要开发者花费一定的时间来学习和理解。对于初学者来说，可能会有一定的学习难度。</li><li><strong>增加配置复杂度</strong>：虽然依赖注入可以降低代码的耦合度，但同时也增加了配置的复杂度。特别是当应用程序比较大时，配置文件可能会变得非常庞大和复杂。</li><li><strong>性能问题</strong>：依赖注入可能会对应用程序的性能产生一定的影响。例如，Spring容器需要花费一定的时间来解析配置文件、创建对象和注入依赖关系。在某些情况下，这可能会导致应用程序的启动时间变长。</li></ul><h2 id="五依赖注入的最佳实践">五、依赖注入的最佳实践</h2><p>依赖注入是一种非常有用的设计模式，但在使用过程中也需要遵循一些最佳实践。以下将详细介绍依赖注入的最佳实践。</p><h3 id="一合理使用依赖注入">（一）合理使用依赖注入</h3><p>虽然依赖注入可以降低对象之间的耦合度，但并不是所有的依赖关系都需要使用依赖注入。对于一些简单的依赖关系，可以直接在代码中实例化对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>UserServiceImpl</code>类的<code>userDao</code>属性直接实例化了一个<code>UserDaoImpl</code>对象。这种方式虽然会增加对象之间的耦合度，但代码更加简洁，也更容易理解。</p><h3 id="二使用构造器注入">（二）使用构造器注入</h3><p>构造器注入是一种比较好的依赖注入方式。通过构造器注入，可以保证Bean对象在创建时就注入了所有必要的依赖关系，从而避免了对象的不一致状态。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>UserServiceImpl</code>类的<code>userDao</code>属性通过构造器注入。这种方式可以保证<code>userService</code>对象在创建时就注入了<code>userDao</code>依赖关系，从而避免了对象的不一致状态。</p><h3 id="三使用字段注入">（三）使用字段注入</h3><p>字段注入是一种比较简洁的依赖注入方式，但它也有一些缺点。例如，字段注入会增加对象之间的耦合度，使得对象的依赖关系不明确。因此，建议尽量使用构造器注入或setter方法注入，而不是字段注入。</p><h3 id="四合理使用spel表达式">（四）合理使用SpEL表达式</h3><p>SpEL表达式是一种非常强大的表达式语言，但它也有一些缺点。例如，SpEL表达式可能会增加配置的复杂度，使得配置文件难以理解和维护。因此，建议合理使用SpEL表达式，避免过度使用。</p><h3 id="五使用java配置类">（五）使用Java配置类</h3><p>从Spring3.0开始，Spring引入了基于Java配置类的依赖注入方式。这种方式使用注解和Java代码来定义Bean的配置信息，而无需编写繁琐的XML配置文件。基于Java配置类的依赖注入更加简洁、灵活，也更容易理解和维护。因此，建议尽量使用Java配置类，而不是XML配置文件。</p><h2 id="六依赖注入的案例分析">六、依赖注入的案例分析</h2><p>为了更好地理解依赖注入的概念和应用，以下将通过一个案例来分析依赖注入的实现和使用。</p><h3 id="一案例背景">（一）案例背景</h3><p>假设我们正在开发一个用户管理系统，该系统需要实现用户信息的增删改查功能。用户信息包括用户名、密码、邮箱等字段。</p><h3 id="二案例实现">（二）案例实现</h3><h4 id="定义用户实体类">1. 定义用户实体类</h4><p>首先，定义一个用户实体类<code>User</code>，用于表示用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义用户数据访问接口">2. 定义用户数据访问接口</h4><p>定义一个用户数据访问接口<code>UserDao</code>，用于操作用户数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(String id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现用户数据访问接口">3. 实现用户数据访问接口</h4><p>实现<code>UserDao</code>接口，提供具体的用户数据操作方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现用户数据的保存逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现根据ID查询用户数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现用户数据的更新逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现用户数据的删除逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义用户服务接口">4. 定义用户服务接口</h4><p>定义一个用户服务接口<code>UserService</code>，用于提供用户相关的业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span>;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(String id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现用户服务接口">5. 实现用户服务接口</h4><p>实现<code>UserService</code>接口，提供具体的用户业务逻辑方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        userDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置spring容器">6. 配置Spring容器</h4><p>使用Java配置类配置Spring容器，注册<code>UserDao</code>和<code>UserService</code>为Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>(userDao());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用spring容器">7. 使用Spring容器</h4><p>使用Spring容器获取<code>UserService</code> Bean，并调用其方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;john@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三案例分析">（三）案例分析</h3><p>通过上述案例，我们可以看到依赖注入在用户管理系统中的应用。<code>UserService</code>类依赖于<code>UserDao</code>类，Spring容器负责创建<code>UserDao</code>对象，并将其注入到<code>UserService</code>对象中。这样，<code>UserService</code>类只需要声明对<code>UserDao</code>类的依赖关系，而无需关心<code>UserDao</code>对象的具体创建过程。</p><p>依赖注入使得<code>UserService</code>类与<code>UserDao</code>类之间实现了解耦，提高了代码的可维护性和可测试性。同时，依赖注入也使得代码更加简洁，减少了冗余代码。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生周报</title>
      <link href="/posts/39537.html"/>
      <url>/posts/39537.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="错误，密码是作者名字全拼" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e7804fe58260c767c5e2e79e61f87e1d3770d47dbf4db147cadcfae3c13ae03f">25d90d729731e7dd7f7ec72587e5f71c59831376496af50b13fbe3e825688c47356551f0fd94e6b541927885a7c0030f968801577ac8b5e197389db95ddd324b91c83474c6d1d9aeded3b14ea79e9997a186d094ee37de88d1ef13ef37bf0e916b216246b21c857877daa9dffc6ff566d4733c510dd10c4d9c474db784b897b096c5dfa9ef6184c1bf8a8b75b2c9d2d9cf300ba1017107b8743f2c186219092ae25e15f31c71ca4894df111983332872c3684ce284c205c054d56d06cee33c57ee49a088f1d0a0a3c017b0a5576f887091ba8de1dc027ae9fb8094b90a49b7703d8c8e9239b650cc916e82be812ceb7b300cb8a12463813d2176ae3ff741d58e79e3fc255f884568d5e57db267dca4279b215acec35b85e1ec6407183c57fb22e1b5ede4feeae40ecffde0a8c8bee1a64cd5d3f6ac0446c28e66ba709f239967ab49616485bf4c7bd1903ed73097f919681a86ea60beae9f792f494aaddb8747c77872ee497086772ef2705df90404600dfcb82374c20265d7c4be7549e1781efdd659ced9620ae79d6f153abd8cd787696baa63b4a99ad6134b209c22bfb67eb6853ef4ddd1661ee466d54cad98a4979d8a48a98d0c3f1cd9c3df6633bd455210f5610c04efc4aa34eaf5debd7ae5d4a4314db03d0bb12f8d7c0cfeb9b38328fc1fcbc0f4216fa2450dca9b22edb83780d7521ef99dec57c90e9aee2051765ce7149bfcdc17cd82c368c47c9004ea610b61604c2d7a044e03ffdb72fccbcea71f535e5a8daecf6e289e03315920dbf404c83d0ba18127b9b78ed9873598f45b31b047aeb10ce75fc92523e0d809f46c35e8b2216bbfba5ce4a0122d9654418a184cc9b728300e6a6351488b1b4549f6ac9dde9877f0ef9c7e3f1304df892e69d8e1b0d573e3c8d067a1061718a70e1e847242e53aa6be88137701759a99e7b0818dab3ec257781521cf53fea7257ffaeaa5d70424dbd089706ce28346524c13d39401e6ed2554dad762f67bdbc4222e07f7b0b9017a817bb2a632902be86e0d9166b50403e24170d31fcead9661fe907898928a0ccb6b9ab4c52420da5446ff156a45f41da0df60f09f1470d2b91691186d95e8cc7d5fa81f71a662b1db517af7d72cc4d4105378fcf23d5410754fbc35d69c2daf94f8def35e0f9e1d3889552bbab02dbd2bcdcc642b78ee5e86b47eaba3931baff08ffc5806909a30bc95b65ded6f9a870deb04630f09aaa93b017b90324226c13104f67b9cbb8bd715a7f25cfa83509bb772a1a6915c2a62aedd1722dd41cde5d83a1c2d60f09569eff34f4dea64e08373e890948d28180475989280205ad91ed1d15d1a5774bad3015e192adab1d6fda65049ed28f24f90d88b3ae4c5fd6b5467c0e47dbd5cc894e4ee1d061d60950000f932c002a8794228467e9aadb7f7f8d440d80caa9dff6396309aa4c9b3200bbd81bd139e2719f2f7a5b89bd726ac6a9bca48764d70cdc2daa5d89dc13729f7e354cb979c3487810139723f4ff22918089d314301eac38840799e25c6a57c581354c4efcb094a8170bf35cce534ece2c24544f128f34fa7f87d405b5698e24bd40a83ab72c7b08b530fc7cdfb93227d01f40014d3ce8c8cc4ec403062705a904aa79d22dd12426d241b9490cf84706985df8a063b8501232b310a58c907c07cd18b57e4f3ac8ba6fc7842850d0153345904e42e3d834fa3c005819098c2473303b21c2e2f280baecb69f896c971a1c1f696a51e4c83bb3ec0a2f13c815f6c6fc25a6e13f4559436d0280348be7e1a5191d3c302c4684105429a292ccb12fcd7b0a2e8637cefb7e58572f8395e37b6b96a5b5b4b90e735e9928fb85989d329a777209186030fcfb46f4651b1c3bedc0f84b0d11ff8074f68f87273be31d0cb1c7b8ec8e3aff4d60884894943dd2a9f04adcb24c027135a33157b2f38eee09632691c81006a17503d2cee4310be8896035e868b3f2480e8052b7ff1cf4b1c1b29799699601069be33e431ad6177a905d9ec515b7a0121653d481f51177854e1231b173db08a932e5da150c4b31700da4b4ceeccca28f41a2af2e21a1c3890847fffa9d54411aa938fd11b8f8fe56f2032e1bb6b06d7c0864e2b4c86fb418158e0700f4df16421b3faab210b947e5a97aac6ea0b25f7cc49d42b23143a9aa7bfcf91abbdcf89601954bf77d147922191c98bfabbe4ba9a31ef333ef0fce087d355c88241f0447b38e7143607dccda40fb41f6c8aef1bafa488c8ddfc61fa3d1f95e53f5f9f314bfe12a45e620990943609523beaad50649e742097351443d68a48cd5993f871730419a4c353adc8fad5cb473523301d7a27475f200e357034001459388079274517c81258c5c1bd95f6f264ed34f470b2342206e4b5ec29f8e26ef0473dab433d499570ec6ec3ead18ecef5047d7045c1b61b64e00f7e42c8fc9db57fd2572c15775596d2fa4b59a1c4820df2a8f3305ec556228d5db8fe32b9c003366b43b22367cb295359f320c3f81ed816d96a4ccc6efe635c12b9ff24545ab4abb99852df73708bb71ee3204432144b41ffcdc571438bae6cc1e52eb13b4fcb1fafb12b2fe8c95cbb3b77efbdf8e5afbbd17d1734a8d27b0430387542fa2dab4bb238f6d4d6465e28bda0ab7f5360a33e8fee039ee7d8e80cf3751758dae074181c68fa8e5626d3287edd3cbfd81ce62fc8c718b6bc4974112e2da1b4ac4e153b98990fc8ad39f20bd3a022676e04f23af0bbedadb8ff211ef912f1c98d63970701710727189788e9641c6e0e6658b512bc80e306e71749991c3cc43682a16cc93644fec7dddb925206c587cddb1ebbf238447a0de3aadac4fb6f813a3b407e2cc62862aec7800c31fce5e6c9cecccbc1b32da6cb139a27b08ab854557050779968ecb112aa344a043353a52f5e9e8dc5b21acab081a7d1cc63bc5e85ab0f080e969ab966be610f0914afc318b8301788c67d19c4c3e7a5320e5ead6bda41bb22bcc1261affb72872cfeeab42a5e0a1ce4da26e3b93ae6f4fe0c3b75f5efa9e6ca9621efc2c97e6e0c8040ddf85ce19a055186a38e18980b939cb679aac4c6a8719a15117c0d6e84e2fac5071ac5c7fa5b6d631fbf528b13f91129881be8e183ad5f13f20a3a8b1996594d05e275c2096ae0fc925f4d0229e2d687694f80a60e3b7ba6cb41b78df9b5f5e42f60ccd16cb9b05bbc94348f55ce5048bc2d57a0252c972fa362bb48d762491575bcb7c551a1a9c5b49ac2f1f1af85cf1ca57d8cee2624d7c3a8273c9f1eccec6be80832934f83408223fae96045ce2f3125a69a0e1ad937d56eb892d887397bc6508306e9534e9eb79ea36cfa9cfa0267779667649f63045e9e3157fb3e83c59314039c5e2c22da0c53fa5b3c92878f74ae809d8976776fc29fe5fac54ded0b7283c2124d23c2d81b7ced5b414f25b1f015902b747a19b71c70e9c523032e16f10b5ffe055abb9fbc36aeaf80768414174601b698ff9d8e9c03fd76d777283bf11db3c6109a289f556ebd6b7d59b3a4878b1d2c8727b5997b81ba4012ff0584e44ef159d50a876405d697bdfcd279055e7763462974a52a49974aa55cd18fd17c2731d1125900d81c28741a2d398d88b17cb294c65b800d027103534806be0fbf32effa43d26ae3ee5a10c61a3437fb899adb1c87af0ee10fac941c4bbd0c299decd40f645be647295a69f518f7348ffd9ac3671427bfed671cff40e7816f364431f2601c03a2c7b495d8413e90b23024f2d4c88c51e719eb70e3e00ea42cc9179ba5d708a9c426c79b093a8366b9993163085ae82b302ddc428c3e17a0543bacaca9c1230338f2348d3f8a2ec99cf4f13dff8da409d0b65d8ba04536c507f5642e82be4563430e2542b8d6af11d7becb98bc22c1a7a74e54dfa4b3176ff401e20d5c02a232d3f3640b44f1bb517337a138d5ddb0c86938ec1642f37177fbb1f1ba6b1a92921e5d8ba297aab00547cb95827c16e3f87b8c0ffb7cb07ce28fda75b5ef15260b243f624e45ac6614bf1b2782cb23a743fe5c5101c027596da705cb8dab8544f987460bd8f6393f5bfc2ce90e25ed2d6afb103e40e146b7351956262db4b1b72c7938b79d37945c57f564f923c0ab31b2c3e06c47e6ee51eb33ee912858234e817cb906ef77a013e74555b47a0d7512fdfffc90791f67bea57c858227a31a0f19f14d39605c762a9ed</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">名字全拼</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周报 </tag>
            
            <tag> 组会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【杂谈】读研规划</title>
      <link href="/posts/34437.html"/>
      <url>/posts/34437.html</url>
      
        <content type="html"><![CDATA[<h1 id="研一学理论打基础">研一（学理论打基础）</h1><h2 id="学习深度学习基础知识">学习深度学习基础知识</h2><h3 id="python基础知识">Python基础知识</h3><p>菜鸟教程学到内置函数即可</p><h3 id="深度学习数学知识">深度学习数学知识</h3><p>《机器学习的数学》——雷明</p><h3 id="深度学习概念原理">深度学习概念、原理</h3><p>李宏毅的《深度学习课程》2022版</p><h2 id="确定研究方向">确定研究方向</h2><ul><li><p>对语音交互、C++感兴趣的可选择<strong>语音识别、语音交互</strong></p></li><li><p>对文本对话、Python感兴趣的可选择<strong>自然语言处理</strong></p></li><li><p>对图片、视频、Python感兴趣的可选择<strong>计算机视觉</strong></p></li><li><p>基础较好的可选择强化学习、深度学习理论研究（门槛较高、谨慎入坑）</p></li></ul><h2 id="阅读经典前沿论文">阅读经典前沿论文</h2><h2 id="动手做简单的练手项目">动手做简单的练手项目</h2><h1 id="研二选择科研或工作">研二（选择科研或工作）</h1><h2 id="科研">科研</h2><p>多看论文多思考、发掘优质论文idea，尽可能多发几篇论文满足升博条件，学习写作技巧、自身快速迭代实验验证结果能力，学习投稿技巧！</p><h2 id="工作">工作</h2><h3 id="实习研二下学期">实习（研二下学期）</h3><blockquote><p>如果你不打算走科研这条路的话，当然是越早越好，前提是你能说服你的导师。</p><p>针对应届生的大规模实习招聘在研二下学期，也就是秋招之前春天的三月份开始，持续到暑期，这时候招的实习生基本都有转正机会，只要能够通过公司的转正面试，就可以拿到校招offer了。</p><p>这个时候你拿到了实习offer的话，最好能在6月份之前就去实习，因为大公司的实习转正都要求实习的期限满两个月，这样你在八月中旬就可以转正了，然后可以离职、从容的准备接下来的秋招。如果你八月底能拿到转正的校招offer的话，那么秋招就可以悠哉游哉的去寻找更好的平台了，你手里的offer会过滤掉一大波公司，只要瞄准更好的公司去准备就行了。</p><p>找工作一定要趁早，秋招是大神出没的季节，他们这些人会出来收割掉一大批offer的名额，能拿到阿里offer的人，肯定也能拿到百度和腾讯的offer，80%的offer集中在20%人手里，要是不早点跑、快掉跑，我们也会被收割掉的，别等秋招</p><p>作者：牛客2017链接：https://www.nowcoder.com/discuss/353153985110548480来源：牛客网</p></blockquote><p>看了下往年课题组的周报，研二下学期应该不放实习，这倒也无妨，毕竟我也不想进厂卷，还是好好准备国企、公考、编制吧。</p><h1 id="研三毕业">研三（毕业）</h1><p>毕业论文、找工作</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机技术 </tag>
            
            <tag> 规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给自己的毕业设计做个总结</title>
      <link href="/posts/57543.html"/>
      <url>/posts/57543.html</url>
      
        <content type="html"><![CDATA[<h1 id="项目介绍">项目介绍</h1><p>本项目为我的本科毕业设计（2025届），基于原作者<ahref="https://gitee.com/jiangzhengshuai">江政帅</a>的<ahref="https://gitee.com/jiangzhengshuai/small-program-campus-help">小程序校园帮</a>项目进行二次开发。</p><p>该项目包含了<ahref="https://gitee.com/wq3stone/campus-life-service-platform/tree/master/miniprogram">用户小程序</a>和<ahref="https://gitee.com/wq3stone/campus-life-service-platform/tree/master/admin">管理员后台管理系统</a>，两个前端共用同一个<ahref="https://gitee.com/wq3stone/campus-life-service-platform/tree/master/server">后端接口</a>。</p><h2 id="摘要">摘要</h2><p>​本系统主要使用了微信标记语言（WXML）、微信样式语言（WXSS）、JavaScript作为用户前端语言开发小程序，使用Vue进行管理员Web前端页面开发，使用Node.js作为后端语言与前端进行数据交互，使用MongoDB作为数据库进行数据存储。基于以上技术，本系统已实现快递代取、打印服务等8个跑腿功能模块，用户可以选择以上任意模块发起订单，在用户身份审核后可以进行接单赚取服务费，用户手机号经授权后可以发起拼车订单，由系统进行匹配相似路线的订单并通知用户。系统经测试，功能可用，使用比较方便。</p><h2 id="技术栈">技术栈</h2><p>用户小程序：微信小程序原生开发</p><p>管理员后台管理系统：Vue.js</p><p>后端接口：Node.js</p><p>数据库：MongoDB</p><h2 id="主要功能">主要功能</h2><p>1.用户操作</p><p>（1）用户信息管理模块：登录、注册、修改用户的个人信息</p><p>（2）生活模块：校园跑腿、拼车匹配。</p><p>2.管理员操作</p><p>（1）管理员信息管理：登录、注册、找回密码。</p><p>（2）拼车模块管理：对于用户在小程序端已提交的拼车贴管理。</p><p>（3）跑腿模块管理：对于用户在小程序端已提交的跑腿贴管理。</p><p>（4）用户信息管理：查询(浏览)全部或所需用户信息</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301604275.png"alt="系统功能结构图" /><figcaption aria-hidden="true">系统功能结构图</figcaption></figure><p><font color='red'><b>功能详情及页面截图见论文</b></font>，功能演示见<ahref="https://www.bilibili.com/video/BV1QmjBzQEoo">视频</a></p><h1 id="部署步骤">部署步骤</h1><p>首先请确保系统上已安装Node、npm、MongoDB。如下为我的本地环境与服务器环境：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301604509.png" /></p><p>如果没有小程序上线需求，可以仅本地部署，无需上传到服务器，但是本地部署会受到微信的限制无法使用授权手机号（可以直接修改数据库）、联系官方客服功能，主要功能不受限制。</p><p>温馨提示：若想上线或使用完整功能，需要一台具有公网ip的服务器运行后端程序、一个域名解析到后端程序所在的服务器进行微信小程序的可信域名配置，此外还需要营业执照进行小程序的注册与认证，步骤非常繁琐。</p><h2 id="后端">后端</h2><h3 id="修改数据库文件">修改数据库文件</h3><p>打开<code>model</code>中的<code>db.js</code>文件，修改以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://username:password@localhost:27017/schoolRun?authSource=admin&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>username改为自己的数据库用户名，password改为自己的数据库密码，localhost为数据库地址（本地部署无需修改），schoolRun为数据库名，authSource默认即可</p></blockquote><p>然后找到以下内容根据提示修改（openid可以先默认，等用户创建出来去userInfo表查看自己的openid）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次运行时将下面注释打开，创建一个管理员用户，openid要改成自己的</span></span><br><span class="line"> admin.<span class="title function_">create</span>(&#123; </span><br><span class="line"> openid : <span class="string">&#x27;oa7me7Yqwmce6xFZHOtbzVfyhfH0&#x27;</span>, </span><br><span class="line"> username : <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line"> password : <span class="string">&#x27;123456&#x27;</span>, </span><br><span class="line"> role : <span class="string">&#x27;超级管理员&#x27;</span>, </span><br><span class="line"> nickName : <span class="string">&#x27;王勤磊&#x27;</span>, </span><br><span class="line"> time : <span class="string">&#x27;2024-12-31 23:59:59&#x27;</span> </span><br><span class="line"> &#125;) </span><br></pre></td></tr></table></figure><h3 id="修改邮箱授权码">修改邮箱授权码</h3><p>打开<code>model</code>中的<code>utils.js</code>文件，修改邮箱授权码。（发邮件功能仅拼车匹配模块使用，可根据自身需求二创）</p><h3 id="修改小程序的appid和appsecret">修改小程序的appID和AppSecret</h3><p>打开<code>router</code>中的<code>userRouter.js</code>，修改以下内容为自己的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> appID = <span class="string">`wxdff4801780968d5d`</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AppSecret</span> = <span class="string">`347d6f58b4e7648ecf4ede072152bb56`</span></span><br></pre></td></tr></table></figure><p>进入到<a href="./server">后端目录</a>，打开命令行窗口，运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p>此命令的含义为安装<code>package.json</code>中要求的包，类似于python的<code>pip install -r requirement.txt</code>或maven根据<code>pom.xml</code>文件安装依赖。</p><p>该命令执行后会在当前目录生成一个<code>node_modules</code>文件夹，其中包含了各种项目运行所需的模块。</p></blockquote><p>再运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><blockquote><p>运行后端启动文件。</p></blockquote><h2 id="后台前端">后台前端</h2><p>进入到<a href="./admin">前端目录</a>，打开命令行窗口，运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>再运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><blockquote><p>运行vue启动文件。</p></blockquote><h2 id="小程序端">小程序端</h2><p>使用微信开发者工具打开<ahref="./miniprogram">小程序端目录</a>，不使用云开发。</p><p>进入后检查<code>app.js</code>中的<code>globalData.server</code>是否和自己部署的接口地址端口相同。</p><p>然后点击编译-&gt;预览即可。</p><h2 id="提示">提示</h2><p>若计划上线或使用完整功能：</p><p>需要修改<code>app.js</code>中的<code>globalData.server</code>为后端接口地址，如<code>https://mini.wq3stone.cn</code>。</p><p>需要修改后端的<code>db.js</code>中的连接地址为自己的。（这里我把MongoDB安装在了自己服务器上，创建一个具有以下权限的用户，然后<code>localhost</code>改为自己的服务器公网地址）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">****以下是查看权限命令而不是创建命令****</span><br><span class="line">····自行寻找创建用户的方法····</span><br><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">use admin</span></span><br><span class="line">switched to db admin</span><br><span class="line"><span class="meta prompt_">admin&gt; </span><span class="language-bash">db.auth(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;xxxxxx&quot;</span>)</span></span><br><span class="line">&#123; ok: 1 &#125;</span><br><span class="line"><span class="meta prompt_">admin&gt; </span><span class="language-bash">db.getUsers()</span></span><br><span class="line">&#123;</span><br><span class="line">  users: [</span><br><span class="line">    &#123;</span><br><span class="line">      _id: &#x27;admin.admin&#x27;,</span><br><span class="line">      userId: UUID(&#x27;d0cee021-6aac-4a33-a3ed-d921e552ae4e&#x27;),</span><br><span class="line">      user: &#x27;admin&#x27;,</span><br><span class="line">      db: &#x27;admin&#x27;,</span><br><span class="line">      roles: [ &#123; role: &#x27;root&#x27;, db: &#x27;admin&#x27; &#125; ],</span><br><span class="line">      mechanisms: [ &#x27;SCRAM-SHA-1&#x27;, &#x27;SCRAM-SHA-256&#x27; ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  ok: 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">admin&gt; </span></span><br></pre></td></tr></table></figure><p>需要修改<code>model</code>中<code>utils.js</code>文件的邮箱授权码。（发邮件功能仅拼车匹配模块使用，可根据自身需求二创）。</p><p>需要修改小程序的<code>appID</code>和<code>AppSecret</code>：打开<code>router</code>中的<code>userRouter.js</code>，修改以下内容为自己的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> appID = <span class="string">`wxdff4801780968d5d`</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AppSecret</span> = <span class="string">`347d6f58b4e7648ecf4ede072152bb56`</span></span><br></pre></td></tr></table></figure><p>由于微信小程序源代码上传限制，我将大部分图片文件放在了我的图床，若不进行上线，可以使用本地图片（我放在了<code>./README_files/部分图床文件</code>文件夹中）。若有上线计划，为避免后续图床关闭，建议将文件保存到自己的图床。</p><h3 id="配置nginx">配置nginx</h3><p>进行如下所示的配置，并使用certbot进行https证书申请。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301605279.png"alt="image-20250530152753722" /><figcaption aria-hidden="true">image-20250530152753722</figcaption></figure><h3 id="配置可信域名">配置可信域名</h3><p>在微信公众平台配置为解析到运行后端程序的nginx服务器IP地址才能使用。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301605567.png"alt="image-20250530141423304" /><figcaption aria-hidden="true">image-20250530141423304</figcaption></figure><h1 id="改进与创新">改进与创新</h1><ol type="1"><li><p>由于原作者是2022年9月开发的项目，微信官方在 2022 年 10 月 25 日24 时后<ahref="https://developers.weixin.qq.com/community/develop/doc/00022c683e8a80b29bed2142b56c01">对用户头像昵称获取规则进行了调整</a>，由原有的<code>wx.getUserInfo</code>接口获取用户昵称头像更改为<strong>头像昵称填写能力</strong>。本人根据此接口对于用户授权功能进行了处理。</p></li><li><p>新增用户头像昵称填写能力，用户手机号码由手动填写更改为微信官方实时验证组件。</p></li><li><p>新增性别只能设置一次功能。默认性别是暂不设置，当用户从暂不设置切换到男或女时进行提醒，当用户处于男或女时将选择框锁定。（2025-2-1801:40）</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301605057.png"alt="b1c696d8-121c-40a5-8fd0-3b602daf5fd8" /><figcaptionaria-hidden="true">b1c696d8-121c-40a5-8fd0-3b602daf5fd8</figcaption></figure></li><li><p>新增邮件发送功能，便于订单提醒。</p></li><li><p>新增拼车匹配模块。</p></li><li><p>删除“代扔垃圾”模块。</p></li></ol><h1 id="展望">展望</h1><ol type="1"><li>用户头像的存取：对于同一openid应仅保存一份头像文件以节省资源。</li><li>原作者写的设置默认地址我测试时不失效，未进行处理。</li><li>拼车匹配模块的出发时间应该回显点击选择器时的时间（目前显示的进入模块的时间）</li><li>根据性别和人数要求进行拼车匹配，需要设计一个合理的算法。目前我只实现了最简单的不限性别的两人匹配。</li><li>订单提交按钮双击会重复提交订单。</li><li>订单数量较多时订单页会显示异常。</li><li>发单者若删除订单会导致接单者的收益也被删除，应该对订单设置状态码而非直接删除记录。</li></ol><h1 id="致谢">致谢</h1><h2 id="谢自己的努力">谢自己的努力</h2><p>在本项目的开发过程中，首先要感谢的就是自己，从大一刚入学时便埋下了一颗种子，想要实现一个解决实际问题的项目。</p><p>和姐姐探讨了下选题意义，进一步明确了此目标。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301605632.png"alt="当时是微电子专业，毕业设计选题大多为硬件设计，后来转专业到软件工程。" /><figcaptionaria-hidden="true">当时是微电子专业，毕业设计选题大多为硬件设计，后来转专业到软件工程。</figcaption></figure><p>以下是当时发现的问题，后来发现市面上已有众多校园跑腿小程序，但拼车功能的小程序寥寥无几（和市面上的打车程序的拼车不同，那种拼车系统考虑了司机端接单，用户支付的总金额还是要高于一个人打车所使用的金额）</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301605607.png"alt="image-20250530145407800" /><figcaption aria-hidden="true">image-20250530145407800</figcaption></figure><p>从2月9日下午两点到2月10日早上7点通宵做此项目，应该是人生中第一次通宵（过年也就撑到三四点），第二天有实训课，谎称火车晚点未到实则补觉。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301605370.png"alt="其实是通了宵做此项目" /><figcaption aria-hidden="true">其实是通了宵做此项目</figcaption></figure><p>然后往后的日子几乎天天熬夜做这个项目。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301605490.jpg"alt="几乎天天熬夜在做这个项目" /><figcaption aria-hidden="true">几乎天天熬夜在做这个项目</figcaption></figure><p>从完全零基础，摸索着学习微信小程序、Node.js、Vue、MongoDB、Nginx，虽然大多都是比着葫芦画瓢，但是确实有所收获。</p><h2 id="谢原作者">谢原作者</h2><p><ahref="https://gitee.com/jiangzhengshuai/small-program-campus-help">小程序校园帮:校园帮微信小程序</a></p><p>没有此项目的框架，我不可能从0开始完成此项目，正因此项目的代码规范性，我可以轻松的阅读源码进行二次开发。</p><h2 id="谢一路提供帮助的所有人">谢一路提供帮助的所有人</h2><p>从选题到项目完成，一步步的操作，互联网提供了巨大的帮助，包括DeepSeek、通义千问以及众多博客，把项目部署到服务器姐姐为我解决了出现的部分问题，让我基本掌握了项目从撰写到上线的全过程。</p><h1 id="插曲">插曲</h1><p><strong>数据库被黑</strong></p><p>原来的表全被删除。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301605374.png"alt="数据库被黑" /><figcaption aria-hidden="true">数据库被黑</figcaption></figure><p><strong>xshell连的服务器，为啥我把xshell关了我当前那个进程就不运行了？</strong></p><blockquote><p>没用后台启动，启动时使用：<code>nohup 启动命令 &amp;</code>，如果要打印日志则使用<code>nohup 启动命令 &gt; output.log 2&gt;&amp;1 &amp;</code></p><p>想关闭只能<code>kill -9 进程号</code>，日志文件覆盖是&gt;追加是&gt;&gt;</p></blockquote><p><strong>Linux创建了用户并指定了家目录，不另外授予权限它是不是只能在家目录里进行读写操作，在家目录外只能读不可写</strong></p><blockquote><p>默认是这样的</p></blockquote><p><strong>使用nginx让<code>domain.com:80</code>代理到<code>domain.com:3000</code>，这个过程用户可感知吗</strong></p><p>反向代理感知不到。</p><p>终于体会到了反向代理，nginx太厉害了。比如一个api服务就要占用一个端口，但是api网站却都能够使用80端口去请求，这就肯定用到了反向代理。https上的网页请求http会被浏览器拦截，使用nginx配置好证书也能让资源被正常访问。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505301605685.png"alt="a661d75c7025dc7716a5a8e637161919" /><figcaptionaria-hidden="true">a661d75c7025dc7716a5a8e637161919</figcaption></figure><p>这个问题终于被解决了。</p><p><strong>还遇到了跨域CORS问题，通过Node.js中配置即可</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 允许跨域请求</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>(&#123;</span><br><span class="line">    <span class="attr">origin</span>: <span class="string">&#x27;https://nav.wq3stone.cn&#x27;</span>, <span class="comment">// 允许的域名</span></span><br><span class="line">    <span class="attr">methods</span>: [<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;DELETE&#x27;</span>], <span class="comment">// 允许的 HTTP 方法</span></span><br><span class="line">    <span class="attr">allowedHeaders</span>: [<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;Authorization&#x27;</span>, <span class="string">&#x27;X-Custom-Header&#x27;</span>] <span class="comment">// 允许的请求头</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
            <tag> Node.js </tag>
            
            <tag> Vue.js </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】边缘检测与轮廓检测</title>
      <link href="/posts/23154.html"/>
      <url>/posts/23154.html</url>
      
        <content type="html"><![CDATA[<h3 id="轮廓的定义">轮廓的定义</h3><p>轮廓是一系列相连的点组成的曲线，代表了物体的基本外形。</p><h3 id="区别">区别</h3><p>​谈起轮廓不免想到边缘，它们确实很像。简单的说，轮廓是连续的，边缘并不全都连续（下图）。其实边缘主要是作为图像的特征使用，比如可以用边缘特征可以区分脸和手，而轮廓主要用来分析物体的形态，比如物体的周长和面积等，可以说边缘包括轮廓。</p><h4 id="检测目的和对象不同">1.检测目的和对象不同：</h4><ul><li>边缘检测主要是为了找到图像中颜色、亮度变化明显的点，反映在图像矩阵上，就是要找到相对周围其他像素点，像素值或者梯度值变化明显的像素点。</li><li>轮廓检测就是要找到一个物体的边界，确定物体的形状。物体的轮廓一定是闭合的、连续的，而图像的边缘不一定是闭合的、连续的。</li></ul><h4 id="检测手段不同">2.检测手段不同：</h4><ul><li>边缘检测主要使用sobel算子、Canny算子、Laplacian算子等检测像素间的梯度变化来标识边缘。</li><li>轮廓检测主要使用<code>cv2.findcontours()</code>找到物体的轮廓。</li></ul><h4 id="检测结果不同">3.检测结果不同：</h4><ul><li>边缘检测先检测出每个像素点的梯度值，然后对梯度值进行阈值处理获得一个与原图宽高一致的二值图像。</li><li>轮廓检测获得的是物体轮廓中各点的坐标集合和轮廓间的层次关系（包含关系）。</li></ul><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505041823807.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>特别感谢：<ahref="https://blog.csdn.net/raychiu757374816/article/details/119892630">opencv-python详解轮廓-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】仿射变换与透视变换</title>
      <link href="/posts/19806.html"/>
      <url>/posts/19806.html</url>
      
        <content type="html"><![CDATA[<h1 id="仿射变换">仿射变换</h1><h2 id="什么是仿射变换">1 什么是仿射变换</h2><p>仿射变换（AffineTransformation）其实是另外两种简单变换的叠加：一个是线性变换，一个是平移变换</p><p>仿射变换变化包括缩放（Scale、平移(transform)、旋转(rotate)、反射（reflection,对图形照镜子）、错切(shearmapping，感觉像是一个图形的倒影)，原来的直线仿射变换后还是直线，原来的平行线经过仿射变换之后还是平行线，这就是仿射。</p><p>仿射变换中集合中的一些性质保持不变： （1）凸性（2）共线性：若几个点变换前在一条线上，则仿射变换后仍然在一条线上（3）平行性：若两条线变换前平行，则变换后仍然平行（4）共线比例不变性：变换前一条线上两条线段的比例，在变换后比例不变</p><h2 id="仿射变换数学表达">2 仿射变换数学表达</h2><p><spanclass="math display"><em>f</em>(<em>x</em>) = <em>A</em><em>x</em> + <em>b</em>,  <em>x</em> ∈ <em>X</em></span></p><p>仿射变换是二维平面中一种重要的变换，在图像图形领域有广泛的应用，在二维图像变换中，一般表达为：<span class="math display">$$\left[\begin{array}{c}x^{\prime} \\y^{\prime} \\1\end{array}\right]=\left[\begin{array}{ccc}R_{00} &amp; R_{01} &amp; T_x \\R_{10} &amp; R_{11} &amp; T_y \\0 &amp; 0 &amp; 1\end{array}\right]\left[\begin{array}{l}x \\y \\1\end{array}\right]$$</span> 可以视为线性变换R和平移变换T的叠加</p><h2 id="仿射变换的理解">3 仿射变换的理解</h2><p>要熟练应用仿射变换，则需先理解仿射变换，说白了就是要弄清楚上面的R，T矩阵各个参数代表什么含义，用图像来表达：</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505040325264.png"alt="仿射变换过程" /><figcaption aria-hidden="true">仿射变换过程</figcaption></figure><h3 id="平移变换">平移变换</h3><p>不难想象，就是将x，y平移指定值，则R矩阵为单位矩阵，T矩阵为指定值，如上图中，第一行第二列图<span class="math display">$$M=\left[\begin{array}{ccc}1 &amp; 0 &amp; T_x \\0 &amp; 1 &amp; T_y \\0 &amp; 0 &amp; 1\end{array}\right]$$</span></p><h3 id="反射变换">反射变换</h3><p>见图最后一行，如相对x轴放射，则x不变，y变为相反号 <spanclass="math display">$$M=\left[\begin{array}{ccc}1 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right]$$</span></p><h3 id="旋转变换">旋转变换</h3><p>关于旋转矩阵，这里详细来看看，网上博客中，有朋友在疑惑旋转矩阵中，<spanclass="math inline"><em>s</em><em>i</em><em>n</em>(<em>θ</em>)</span>的负号位置问题，下面我谈谈我个人想法，若有错误请大家指点。为简单起见，只从一个点的旋转来看….具体请查看原作者博客原文</p><h1 id="透视变换">透视变换</h1><h2 id="什么是透视变换">1 什么是透视变换</h2><blockquote><p>透视变换（PerspectiveTransformation）的本质是<strong>将图像投影到一个新的视平面</strong>(ViewingPlane)，也称作投影映射(Projective Mapping)。</p></blockquote><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505041742095.png"alt="投影" /><figcaption aria-hidden="true">投影</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505041743989.png"alt="image-20250504174331914" /><figcaption aria-hidden="true">image-20250504174331914</figcaption></figure><h2 id="透视变换的数学表达">2 透视变换的数学表达</h2><p>透视变换（PerspectiveTransformation）的本质是将图像投影到一个新的视平面，其通用变换公式为：<span class="math display">$$\left[\begin{array}{c}X \\Y \\Z\end{array}\right]=\left[\begin{array}{lll}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33}\end{array}\right]\left[\begin{array}{l}x \\y \\z\end{array}\right]$$</span> 这两篇文章写得很好：<ahref="https://blog.csdn.net/m0_43609475/article/details/112847314">（十四）透视变换-CSDN博客</a>、<ahref="https://zhuanlan.zhihu.com/p/641970591">透视变换（PerspectiveTransformation） - 知乎</a>可以围观一下</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202505031705202.png"alt="图形变换" /><figcaption aria-hidden="true">图形变换</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】opencv-python学习</title>
      <link href="/posts/38253.html"/>
      <url>/posts/38253.html</url>
      
        <content type="html"><![CDATA[<h2 id="显示图像">显示图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&quot;../images/leijun/3.jpg&quot;</span>)  <span class="comment"># 参数为图像路径，不可包含中文</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.检查图像是否成功读取</span></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;错误：无法加载图像，请检查路径是否正确！&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.显示图像</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;Display&quot;</span>, img)  <span class="comment"># 第一个参数为窗口名，第二个参数为要显示的图像对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 4.等待用户按键</span></span><br><span class="line">    <span class="comment"># 参数0表示无限等待，直到用户按下任意键</span></span><br><span class="line">    key = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5.根据用户按键执行操作</span></span><br><span class="line">    <span class="comment"># print(key)  # 发现打印结果为按键的ASCII码</span></span><br><span class="line">    <span class="keyword">if</span> key &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;s&#x27;</span>):</span><br><span class="line">        cv2.imwrite(<span class="string">&#x27;saved.jpg&#x27;</span>, img)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;图片已保存&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> key &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;您按下了&#123;&#125;键&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">chr</span>(key)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.关闭窗口</span></span><br><span class="line">cv2.destroyWindow(<span class="string">&quot;Display&quot;</span>)  <span class="comment"># 关闭名为Display的窗口</span></span><br><span class="line">cv2.destroyAllWindows()  <span class="comment"># 关闭所有窗口</span></span><br></pre></td></tr></table></figure><p>读取图片报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ WARN:0@0.025] global loadsave.cpp:268 cv::findDecoder imread_(&#x27;../images/雷军/1.jpg&#x27;): can&#x27;t open/read file: check file path/integrity</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;F:\repo\Python\opencv-leaning\chapter1\BaseOperation.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    cv2.imshow(&quot;雷军&quot;, img)</span><br><span class="line">cv2.error: OpenCV(4.11.0) D:\a\opencv-python\opencv-python\opencv\modules\highgui\src\window.cpp:973: error: (-215:Assertion failed) size.width&gt;0 &amp;&amp; size.height&gt;0 in function &#x27;cv::imshow&#x27;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504272102590.png"alt="含中文路径的图片" /><figcaption aria-hidden="true">含中文路径的图片</figcaption></figure><p>猜测是中文路径问题，将文件夹重命名为leijun即可</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504272104988.png"alt="image-20250427210458763" /><figcaption aria-hidden="true">image-20250427210458763</figcaption></figure><p>图片可显示，但是图片分辨率太高，我的显示器显示不全</p><p>可以使用<code>cv2.resize(src, dsize, fx, fy, interpolation)</code>方法</p><ul><li><strong><code>src</code></strong>：<ul><li>输入图像（通常是 NumPy 数组）。</li><li>示例：<code>src = cv2.imread("image.jpg")</code></li></ul></li><li><strong><code>dsize</code></strong>：<ul><li>输出图像的尺寸，格式为 <code>(width, height)</code>。</li><li>如果指定了 <code>dsize</code>，则忽略 <code>fx</code> 和<code>fy</code>。</li><li>示例：<code>(300, 200)</code> 表示输出图像宽度为 300 像素，高度为200 像素。</li></ul></li><li><strong><code>fx</code></strong>：<ul><li>水平方向的缩放比例（宽度方向）。</li><li>默认值为 <code>0</code>，表示不使用此参数。</li><li>示例：<code>fx=0.5</code> 表示水平方向缩小到原来的 50%。</li></ul></li><li><strong><code>fy</code></strong>：<ul><li>垂直方向的缩放比例（高度方向）。</li><li>默认值为 <code>0</code>，表示不使用此参数。</li><li>示例：<code>fy=2.0</code> 表示垂直方向放大到原来的 2 倍。</li></ul></li><li><strong><code>interpolation</code></strong>：<ul><li>插值方法，用于决定如何调整像素值。</li><li>常见的插值方法及其适用场景如下：<ul><li><code>cv2.INTER_NEAREST</code>：最近邻插值（速度最快，但质量较差，适用于对质量要求不高的场景）。</li><li><code>cv2.INTER_LINEAR</code>：双线性插值（默认值，适用于缩小或放大）。</li><li><code>cv2.INTER_CUBIC</code>：三次插值（质量更高，但速度较慢，适用于对质量要求较高的场景）。</li><li><code>cv2.INTER_AREA</code>：区域插值（适用于缩小图像，效果较好）。</li><li><code>cv2.INTER_LANCZOS4</code>：Lanczos插值（高质量插值，但计算成本高，适用于对质量要求极高的场景）。</li></ul></li></ul></li></ul><h2 id="显示视频">显示视频</h2><p>视频的显示是通过<code>imshow</code>方法逐帧显示每一帧的画面组合起来从而形成的视频效果</p><h3 id="捕获视频">1.捕获视频</h3><h4 id="捕获本机摄像头">捕获本机摄像头</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>参数0为默认摄像头，1/2/…为本机其他摄像头（如有）</p><h4 id="捕获本地视频文件">捕获本地视频文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="string">&#x27;video.mp4&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="捕获网络视频流">捕获网络视频流</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="string">&#x27;https://vjs.zencdn.net/v/oceans.mp4&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="设置属性">设置属性</h3><p>使用 <code>set()</code>方法来设置摄像头或视频捕获的各种属性，例如分辨率、帧率等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置视频分辨率为 1280x720</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">1280</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">720</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置帧率为 30 FPS</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FPS, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><h3 id="获取属性">获取属性</h3><p>使用 <code>get()</code>方法可以获取当前视频捕获的各种属性，比如宽度、高度、帧率等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)</span><br><span class="line">height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)</span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Width: <span class="subst">&#123;width&#125;</span>, Height: <span class="subst">&#123;height&#125;</span>, FPS: <span class="subst">&#123;fps&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>可操作的属性列表如下</p><table><colgroup><col style="width: 27%" /><col style="width: 6%" /><col style="width: 55%" /><col style="width: 10%" /></colgroup><thead><tr><th><strong>参数名称</strong></th><th><strong>值</strong></th><th><strong>说明</strong></th><th><strong>读/写</strong></th></tr></thead><tbody><tr><td>CV.CAP_PROP_POS_MSEC</td><td>0</td><td>当前视频文件的时间位置（返回毫秒）或视频捕获时间戳</td><td>Y/N</td></tr><tr><td>CV.CAP_PROP_POS_FRAMES</td><td>1</td><td>从0开始的解码/捕获时间帧</td><td>Y/N</td></tr><tr><td>CV.CAP_PROP_POS_AVI_RATIO</td><td>2</td><td>返回视频文件的相关位置：0，视频开始。1，视频结束</td><td>Y/N</td></tr><tr><td>CV.CAP_PROP_FRAME_WIDTH</td><td>3</td><td>视频流中的帧宽</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_FRAME_HEIGHT</td><td>4</td><td>视频流中的帧高</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_FPS</td><td>5</td><td>帧率</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_FOURCC</td><td>6</td><td>返回解码方式中的四字符</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_FRAME_COUNT</td><td>7</td><td>视频文件的总帧数</td><td>Y/N</td></tr><tr><td>CV.CAP_PROP_FORMAT</td><td>8</td><td>由retrieve()函数返回的矩阵对象的格式</td><td>Y/N</td></tr><tr><td>CV.CAP_PROP_MODE</td><td>9</td><td>用于预测当前捕获模式的后端专用值</td><td>Y/N</td></tr><tr><td>CV.CAP_PROP_BRIGHTNESS</td><td>10</td><td>图像的亮度（仅用于摄像头）</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_CONTRAST</td><td>11</td><td>图像的对比度（仅用于摄像头）</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_SATURATION</td><td>12</td><td>图像的饱和度（仅用于摄像头）</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_HUE</td><td>13</td><td>图像的色调（仅用于摄像头）</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_GAIN</td><td>14</td><td>图像增益（仅用于摄像头）</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_EXPOSURE</td><td>15</td><td>曝光度（仅用于摄像头）</td><td>Y/Y</td></tr><tr><td>CV.CAP_PROP_CONVERT_RGB</td><td>16</td><td>用于预测图像是否应该被转换为RGB的布尔位</td><td>Y/N</td></tr><tr><td>CV.CAP_PROP_WHITE_BALANCE</td><td>17</td><td>白平衡（当前不支持）</td><td>Y/N</td></tr><tr><td>CV.CAP_PROP_RECTIFICATION</td><td>18</td><td>立体相机的纠正位</td><td>Y/N</td></tr></tbody></table><h3 id="检查是否成功打开视频源">检查是否成功打开视频源</h3><p>使用<code>cap.isOpened()</code>方法检查是否成功打开视频源</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法打开摄像头&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="逐帧读取视频">2.逐帧读取视频</h3><p>使用 <code>read()</code> 方法逐帧读取视频。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()  <span class="comment"># 返回一个元组，第一个元素为布尔值，第二个元素为实际读取到的图像帧（是一个 NumPy 数组）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 显示帧</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;Frame&quot;</span>, frame)</span><br><span class="line">    <span class="comment"># 等待1毫秒的获取按键的 ASCII 值的低 8 位</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><code>waitKey(1)</code>非常容易忽略，会看到一个<strong>空白或冻结的窗口</strong>，即使程序正在运行。</p><p><code>waitKey(0)</code>表示无限等待，直到用户按下任意键。显示图像后，程序会<strong>暂停</strong>，画面保持不动。直到你按下任意键（比如空格、q、回车等），程序才会继续往下执行。适合逐帧手动播放视频。</p><h3 id="释放视频捕获对象">3.释放视频捕获对象</h3><p>用完视频捕获对象后，应该调用 <code>cap.release()</code>来释放资源。</p><h3 id="含有视频保存的示例">含有视频保存的示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开摄像头（设备索引号根据你的设备调整，默认是 0）</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取帧的宽度和高度</span></span><br><span class="line">frame_width = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">frame_height = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编码格式，创建 VideoWriter 对象</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;XVID&#x27;</span>)  <span class="comment"># 编码格式（常见：XVID, MJPG, DIVX 等）</span></span><br><span class="line">out = cv2.VideoWriter(<span class="string">&#x27;output.avi&#x27;</span>, fourcc, <span class="number">20.0</span>, (frame_width, frame_height))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始录制... 按 &#x27;q&#x27; 键停止并保存视频&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入帧到视频文件</span></span><br><span class="line">    out.write(frame)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示画面（可选）</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Recording...&#x27;</span>, frame)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按 q 键停止录制</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放资源</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;视频已保存为 output.avi&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="videowriter参数说明">📝 VideoWriter()参数说明</h4><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>'output.avi'</code></td><td>输出视频文件名</td></tr><tr><td><code>fourcc</code></td><td>视频编码器，决定视频格式和压缩方式</td></tr><tr><td><code>20.0</code></td><td>帧率（每秒帧数），通常设为 20~30</td></tr><tr><td><code>(width, height)</code></td><td>帧的分辨率，必须与输入帧一致</td></tr></tbody></table><hr /><h4 id="支持的编码格式fourcc">🎞️ 支持的编码格式（FourCC）</h4><p>你可以使用不同的 FourCC 编码来生成不同格式的视频文件：</p><table><thead><tr><th>编码</th><th>文件格式</th><th>备注</th></tr></thead><tbody><tr><td><code>'XVID'</code></td><td><code>.avi</code></td><td>最常用，兼容性好</td></tr><tr><td><code>'MP4V'</code></td><td><code>.mp4</code></td><td>MP4 格式，清晰度高</td></tr><tr><td><code>'MJPG'</code></td><td><code>.avi</code></td><td>不压缩，体积大但速度快</td></tr><tr><td><code>'DIVX'</code></td><td><code>.avi</code></td><td>老版本编码器</td></tr></tbody></table><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;MP4V&#x27;</span>)</span><br><span class="line">out = cv2.VideoWriter(<span class="string">&#x27;output.mp4&#x27;</span>, fourcc, <span class="number">20.0</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br></pre></td></tr></table></figure><hr /><h4 id="注意事项">⚠️ 注意事项</h4><ul><li><strong>视频尺寸必须匹配输入帧大小</strong>，否则会写入失败。</li><li><strong>不要在没有写完所有帧时就调用<code>release()</code></strong>，否则可能损坏视频文件。</li><li><strong>某些编码格式在某些系统上不支持</strong>，可以尝试更换FourCC。</li></ul><h2 id="core模块">Core模块</h2><p><strong>功能:</strong> 提供 OpenCV的核心功能，包括基本数据结构、矩阵操作、绘图函数等。</p><p><strong>主要类和函数:</strong></p><ul><li><strong>Mat:</strong> OpenCV中用于存储图像和矩阵的基本数据结构。</li><li><strong>Scalar:</strong> 用于表示颜色或像素值。</li><li><strong>Point、Size、Rect:</strong> 用于表示点、尺寸和矩形。</li><li><strong>基本绘图函数:</strong><code>cv.line()</code>、<code>cv.circle()</code>、<code>cv.rectangle()</code>、<code>cv.putText()</code>等。</li></ul><h3 id="示例">示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空白图像 (500x500 像素，3 通道 BGR)</span></span><br><span class="line">image = np.zeros((<span class="number">500</span>, <span class="number">500</span>, <span class="number">3</span>), dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改(450,450-499,499)处的像素值</span></span><br><span class="line">image[<span class="number">450</span>,<span class="number">450</span>:<span class="number">499</span>] = [<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制一条直线</span></span><br><span class="line">cv2.line(image, (<span class="number">50</span>, <span class="number">50</span>), (<span class="number">400</span>, <span class="number">400</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">2</span>)</span><br><span class="line">cv2.line(image,(<span class="number">300</span>,<span class="number">400</span>),(<span class="number">400</span>,<span class="number">300</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>),thickness=<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 绘制一个圆</span></span><br><span class="line">cv2.circle(image, (<span class="number">250</span>, <span class="number">250</span>), <span class="number">100</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line">cv2.circle(image,(<span class="number">100</span>,<span class="number">100</span>),<span class="number">100</span>,(<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>),<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 绘制一个矩形</span></span><br><span class="line">cv2.rectangle(image, (<span class="number">100</span>, <span class="number">100</span>), (<span class="number">300</span>, <span class="number">300</span>), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">5</span>)</span><br><span class="line">cv2.rectangle(image,(<span class="number">300</span>,<span class="number">400</span>),(<span class="number">400</span>,<span class="number">300</span>),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 添加文本</span></span><br><span class="line">cv2.putText(image, <span class="string">&quot;OpenCV Drawing&quot;</span>, (<span class="number">50</span>, <span class="number">450</span>), cv2.FONT_HERSHEY_COMPLEX,<span class="number">1</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;Drawing Example&quot;</span>, image)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待按键并关闭窗口</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>图像在计算机中是以三维数组进行存储的，比如<code>(300,300,3)</code>表示宽为300，高为300，通道数为3的一张图像，一张标量图可以看作三张二维数组的叠加态，具体自行了解吧。</p><h3 id="方法参数记忆">方法参数记忆</h3><h4 id="cv2.line">cv2.line()</h4><p>线段的绘制首先需要给出在哪张<strong>图像</strong>（img）上进行绘制，然后再给出待绘制线段的<strong>起点</strong>（pt1）与<strong>终点</strong>（pt2）坐标，再给出线段的<strong>颜色</strong>（color），以及线段的<strong>粗细</strong>（thickness）</p><h4 id="cv2.circle">cv2.circle()</h4><p>圆形的绘制首先需要确定在哪张<strong>图像</strong>（img）上进行绘制，然后给出<strong>圆心坐标</strong>（center）与<strong>半径</strong>（radius），再给出<strong>颜色</strong>（color）和线的<strong>粗细</strong>（thickness）</p><h4 id="cv2.rectangle">cv2.rectangle()</h4><p>矩形的绘制首先需要确定在哪张<strong>图像</strong>（img）上进行绘制，然后给出<strong>两个</strong>对角的<strong>坐标</strong>（pt1、pt2），再给出线的<strong>颜色</strong>（color）和<strong>粗细</strong>（thickness）</p><h4 id="cv2.puttext">cv2.putText()</h4><p>添加文字首先需要确定在哪张<strong>图像</strong>上进行绘制，然后给出<strong>文字内容</strong>，再给出文字起始点<strong>左下角坐标</strong>（org）和<strong>字体类型</strong>（fontFace），再给出<strong>字体大小缩放因子</strong>（fontScale）、<strong>字体颜色</strong>（color）、<strong>字体粗细</strong>（thickness）</p><blockquote><p>综上来说，先确定图像、然后所绘制图形的属性，主要内容在前，位置在后，最后是图形颜色与粗细。</p></blockquote><h2 id="imgproc-模块">Imgproc 模块</h2><p><strong>功能:</strong>提供图像处理功能，包括图像滤波、几何变换、颜色空间转换等。</p><p><strong>主要类和函数:</strong></p><ul><li><strong>图像滤波:</strong><code>cv.blur()</code>、<code>cv.GaussianBlur()</code>、<code>cv.medianBlur()</code>等。</li><li><strong>几何变换:</strong><code>cv.resize()</code>、<code>cv.warpAffine()</code>、<code>cv.warpPerspective()</code>等。</li><li><strong>颜色空间转换:</strong> <code>cv.cvtColor()</code>（如 BGR转灰度、BGR 转 HSV）。</li><li><strong>阈值处理:</strong><code>cv.threshold()</code>、<code>cv.adaptiveThreshold()</code>。</li><li><strong>边缘检测:</strong><code>cv.Canny()</code>、<code>cv.Sobel()</code>、<code>cv.Laplacian()</code>。</li></ul><p><strong>应用场景:</strong></p><ul><li>图像平滑、锐化、边缘检测。</li><li>图像缩放、旋转、仿射变换。</li><li>图像二值化、颜色空间转换。</li></ul><h3 id="示例-1">示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 1. 读取图像 ===================</span></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;../images/lena.png&#x27;</span>)  <span class="comment"># 读取图像文件</span></span><br><span class="line"><span class="keyword">if</span> image <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;❌ 错误：图像未找到，请检查路径是否正确！&quot;</span>)</span><br><span class="line">    exit()  <span class="comment"># 如果图像为空，退出程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 2. 图像滤波（去噪）===================</span></span><br><span class="line"><span class="comment"># 高斯模糊：使用 11x11 的核进行平滑处理，σ=0 表示自动计算标准差</span></span><br><span class="line">blurred = cv2.GaussianBlur(image, (<span class="number">11</span>, <span class="number">11</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中值滤波：用于去除椒盐噪声，5x5 核大小</span></span><br><span class="line">median_blurred = cv2.medianBlur(image, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 3. 几何变换（缩放、旋转）===================</span></span><br><span class="line"><span class="comment"># 缩放图像：缩小为原来的一半，使用线性插值</span></span><br><span class="line">resized = cv2.resize(image, <span class="literal">None</span>, fx=<span class="number">0.5</span>, fy=<span class="number">0.5</span>, interpolation=cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺时针旋转90度：仅支持 90 度倍数旋转</span></span><br><span class="line">rotated = cv2.rotate(image, cv2.ROTATE_90_CLOCKWISE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 4. 颜色空间转换 ===================</span></span><br><span class="line"><span class="comment"># BGR 转灰度图：单通道图像</span></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># BGR 转 HSV：色调（Hue）、饱和度（Saturation）、明度（Value）</span></span><br><span class="line">hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度图转BGR：将单通道图像复制为三通道</span></span><br><span class="line">gray2bgr = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># HSV 转 BGR：还原为原始颜色空间</span></span><br><span class="line">hsv2bgr = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># HSV 转 RGB：常用于显示或深度学习模型输入</span></span><br><span class="line">hsv2rgb = cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># RGB 转 BGR：OpenCV默认是BGR格式</span></span><br><span class="line">rgb2bgr = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># BGR 转 RGB：用于兼容Matplotlib等库</span></span><br><span class="line">bgr2rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 5. 阈值处理（二值化）===================</span></span><br><span class="line"><span class="comment"># 固定阈值处理：大于128设为255（白色），否则为0（黑色）</span></span><br><span class="line">_, binary = cv2.threshold(gray, <span class="number">128</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自适应阈值处理：基于局部区域均值，窗口大小11x11，C=2</span></span><br><span class="line">adaptive_binary = cv2.adaptiveThreshold(</span><br><span class="line">    gray, <span class="number">255</span>,</span><br><span class="line">    cv2.ADAPTIVE_THRESH_MEAN_C,</span><br><span class="line">    cv2.THRESH_BINARY,</span><br><span class="line">    <span class="number">11</span>, <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 6. 边缘检测 ===================</span></span><br><span class="line"><span class="comment"># Canny边缘检测：低阈值50，高阈值150</span></span><br><span class="line">edges_canny = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sobel算子：X方向边缘检测，ksize=5</span></span><br><span class="line">edges_sobel = cv2.Sobel(gray, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Laplacian算子：所有方向边缘检测</span></span><br><span class="line">edges_laplacian = cv2.Laplacian(gray, cv2.CV_64F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 7. 显示图像 ===================</span></span><br><span class="line"><span class="comment"># 所有处理结果都会在一个个窗口中显示出来</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;Original&quot;</span>, image)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Gaussian Blur&quot;</span>, blurred)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Median Blur&quot;</span>, median_blurred)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Resized&quot;</span>, resized)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Rotated&quot;</span>, rotated)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Gray&quot;</span>, gray)</span><br><span class="line">cv2.imshow(<span class="string">&quot;HSV&quot;</span>, hsv)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Binary Threshold&quot;</span>, binary)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Adaptive Threshold&quot;</span>, adaptive_binary)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Canny Edges&quot;</span>, edges_canny)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Sobel Edges&quot;</span>, edges_sobel)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Laplacian Edges&quot;</span>, edges_laplacian)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Gray2BGR&quot;</span>, gray2bgr)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Hsv2BGR&quot;</span>, hsv2bgr)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Hsv2RGB&quot;</span>, hsv2rgb)</span><br><span class="line">cv2.imshow(<span class="string">&quot;BGR2RGB&quot;</span>, bgr2rgb)</span><br><span class="line">cv2.imshow(<span class="string">&quot;RGB2BGR&quot;</span>, rgb2bgr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 8. 等待按键并关闭窗口 ===================</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;✅ 程序已启动，请按任意键关闭所有窗口...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待任意按键按下</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有OpenCV创建的窗口</span></span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="highgui-模块">HighGUI 模块</h2><p><strong>功能:</strong> 提供高层 GUI 和媒体 I/O功能，用于图像的显示和交互。</p><p><strong>主要类和函数:</strong></p><ul><li><strong>图像显示:</strong><code>cv.imshow()</code>、<code>cv.waitKey()</code>、<code>cv.destroyAllWindows()</code>。</li><li><strong>视频捕获:</strong><code>cv.VideoCapture()</code>、<code>cv.VideoWriter()</code>。</li><li><strong>鼠标和键盘事件:</strong><code>cv.setMouseCallback()</code>。</li></ul><p><strong>应用场景:</strong></p><ul><li>显示图像和视频。</li><li>捕获摄像头或视频文件。</li><li>处理用户交互（如鼠标点击、键盘输入）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  <span class="comment"># 导入OpenCV库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 功能一：图像显示 ===================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_image</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    功能描述：</span></span><br><span class="line"><span class="string">        - 读取一张图片并显示在一个窗口中。</span></span><br><span class="line"><span class="string">        - 按下 &#x27;q&#x27; 键关闭窗口。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取图像文件</span></span><br><span class="line">    image = cv2.imread(<span class="string">&#x27;../images/lena.png&#x27;</span>)  <span class="comment"># 替换为你自己的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否成功读取图像</span></span><br><span class="line">    <span class="keyword">if</span> image <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: Image not found!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个名为 &quot;Image Window&quot; 的窗口并显示图像</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;Image Window&quot;</span>, image)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待键盘输入（0 表示无限等待）</span></span><br><span class="line">    key = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果按下的是 &#x27;q&#x27; 键，输出提示信息</span></span><br><span class="line">    <span class="keyword">if</span> key == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Quit&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭所有OpenCV创建的窗口</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 功能二：视频捕获和保存 ===================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">capture_and_save_video</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    功能描述：</span></span><br><span class="line"><span class="string">        - 打开默认摄像头（通常是0号设备）进行实时视频采集。</span></span><br><span class="line"><span class="string">        - 将每一帧写入输出视频文件 output.avi。</span></span><br><span class="line"><span class="string">        - 按下 &#x27;q&#x27; 键退出录制。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开摄像头（参数 0 表示默认摄像头）</span></span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否成功打开摄像头</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: Could not open camera!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置视频编码格式（这里使用 XVID 编码）</span></span><br><span class="line">    fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;XVID&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 VideoWriter 对象，用于写入视频</span></span><br><span class="line">    <span class="comment"># 参数说明：</span></span><br><span class="line">    <span class="comment">#   - 文件名：output.avi</span></span><br><span class="line">    <span class="comment">#   - 编码器：fourcc</span></span><br><span class="line">    <span class="comment">#   - 帧率：20.0 FPS</span></span><br><span class="line">    <span class="comment">#   - 分辨率：640x480</span></span><br><span class="line">    out = cv2.VideoWriter(<span class="string">&#x27;output.avi&#x27;</span>, fourcc, <span class="number">20.0</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环读取每一帧</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 读取当前帧</span></span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果读取失败（如摄像头断开），退出循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error: Could not read frame!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示当前帧</span></span><br><span class="line">        cv2.imshow(<span class="string">&quot;Video Capture&quot;</span>, frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写入当前帧到输出文件</span></span><br><span class="line">        out.write(frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检测是否按下 &#x27;q&#x27; 键，是则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 释放摄像头资源</span></span><br><span class="line">    cap.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 释放视频写入资源</span></span><br><span class="line">    out.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭所有OpenCV窗口</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 功能三：鼠标事件处理 ===================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_mouse_events</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    功能描述：</span></span><br><span class="line"><span class="string">        - 在图像窗口中监听鼠标事件。</span></span><br><span class="line"><span class="string">        - 当用户左键或右键点击时，在控制台打印坐标信息。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义鼠标回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mouse_callback</span>(<span class="params">event, x, y, flags, param</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        参数说明：</span></span><br><span class="line"><span class="string">            event: 事件类型（如单击、移动等）</span></span><br><span class="line"><span class="string">            x, y: 发生事件时的坐标</span></span><br><span class="line"><span class="string">            flags: 特殊按键状态（如Shift、Ctrl等）</span></span><br><span class="line"><span class="string">            param: 用户自定义传参（本例未使用）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 左键单击</span></span><br><span class="line">        <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Left button clicked at (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)</span><br><span class="line">        <span class="comment"># 右键单击</span></span><br><span class="line">        <span class="keyword">elif</span> event == cv2.EVENT_RBUTTONDOWN:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Right button clicked at (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)</span><br><span class="line">        <span class="comment"># 鼠标移动（可选）</span></span><br><span class="line">        <span class="comment"># elif event == cv2.EVENT_MOUSEMOVE:</span></span><br><span class="line">        <span class="comment">#     print(f&quot;Move by &#123;x&#125;,&#123;y&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载图像</span></span><br><span class="line">    image = cv2.imread(<span class="string">&#x27;../images/lena.png&#x27;</span>)  <span class="comment"># 替换为你自己的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否成功读取图像</span></span><br><span class="line">    <span class="keyword">if</span> image <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: Image not found!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个窗口，并绑定鼠标事件回调函数</span></span><br><span class="line">    cv2.namedWindow(<span class="string">&quot;Mouse Events&quot;</span>)  <span class="comment"># 创建一个名为 &quot;Mouse Events&quot; 的窗口</span></span><br><span class="line">    cv2.setMouseCallback(<span class="string">&quot;Mouse Events&quot;</span>, mouse_callback)  <span class="comment"># 绑定回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主循环：持续显示图像，直到按下 &#x27;q&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cv2.imshow(<span class="string">&quot;Mouse Events&quot;</span>, image)  <span class="comment"># 显示图像</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):     <span class="comment"># 按下 &#x27;q&#x27; 键退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭所有OpenCV窗口</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 主程序入口 ===================</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    主程序逻辑：</span></span><br><span class="line"><span class="string">        - 提供一个简单的文本菜单，让用户选择要执行的功能</span></span><br><span class="line"><span class="string">        - 支持：</span></span><br><span class="line"><span class="string">            1. 显示图像</span></span><br><span class="line"><span class="string">            2. 捕获并保存视频</span></span><br><span class="line"><span class="string">            3. 处理鼠标事件</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印功能菜单</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Choose an option:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1. Display Image&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2. Capture and Save Video&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3. Handle Mouse Events&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取用户输入</span></span><br><span class="line">    choice = <span class="built_in">input</span>(<span class="string">&quot;Enter your choice (1/2/3): &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据选择调用对应函数</span></span><br><span class="line">    <span class="keyword">if</span> choice == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        display_image()</span><br><span class="line">    <span class="keyword">elif</span> choice == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        capture_and_save_video()</span><br><span class="line">    <span class="keyword">elif</span> choice == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        handle_mouse_events()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid choice!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="video模块">Video模块</h2><h3 id="示例-2">示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 功能一：背景减除 ===================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">background_subtraction</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    功能描述：</span></span><br><span class="line"><span class="string">        - 使用摄像头实时获取视频流。</span></span><br><span class="line"><span class="string">        - 利用 OpenCV 提供的 MOG2 背景建模算法进行背景减除。</span></span><br><span class="line"><span class="string">        - 输出当前帧的前景掩膜图像。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开默认摄像头（设备索引号为0）</span></span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查摄像头是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: Could not open camera!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建背景减除器（MOG2算法）</span></span><br><span class="line">    subtractor = cv2.createBackgroundSubtractorMOG2(</span><br><span class="line">        history=<span class="number">500</span>,          <span class="comment"># 历史帧数，用于构建背景模型</span></span><br><span class="line">        varThreshold=<span class="number">16</span>,      <span class="comment"># 方差阈值，用于判断是否为前景</span></span><br><span class="line">        detectShadows=<span class="literal">True</span>    <span class="comment"># 是否检测阴影</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 读取当前帧</span></span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果读取失败，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 应用背景减除器，得到前景掩膜</span></span><br><span class="line">        mask = subtractor.apply(frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示原始帧和前景掩膜</span></span><br><span class="line">        cv2.imshow(<span class="string">&quot;Original&quot;</span>, frame)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;Background Subtraction&quot;</span>, mask)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按下 &#x27;q&#x27; 键退出循环</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 释放摄像头资源</span></span><br><span class="line">    cap.release()</span><br><span class="line">    <span class="comment"># 关闭所有OpenCV窗口</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 功能二：光流法（Lucas-Kanade）===================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">optical_flow</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    功能描述：</span></span><br><span class="line"><span class="string">        - 使用 Lucas-Kanade 光流法追踪特征点运动轨迹。</span></span><br><span class="line"><span class="string">        - 在视频中绘制跟踪点的移动路径。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开默认摄像头</span></span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查摄像头是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: Could not open camera!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取第一帧</span></span><br><span class="line">    ret, prev_frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将第一帧转为灰度图，用于后续处理</span></span><br><span class="line">    prev_gray = cv2.cvtColor(prev_frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测初始特征点（最多检测100个）</span></span><br><span class="line">    prev_points = cv2.goodFeaturesToTrack(prev_gray, maxCorners=<span class="number">100</span>, qualityLevel=<span class="number">0.01</span>, minDistance=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 读取下一帧</span></span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换为灰度图像</span></span><br><span class="line">        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算光流，找到当前帧中特征点的位置</span></span><br><span class="line">        next_points, status, _ = cv2.calcOpticalFlowPyrLK(prev_gray, gray, prev_points, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 只保留状态为1（成功跟踪）的点</span></span><br><span class="line">        good_prev = prev_points[status == <span class="number">1</span>]</span><br><span class="line">        good_next = next_points[status == <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制光流轨迹</span></span><br><span class="line">        <span class="keyword">for</span> i, (p, n) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(good_prev, good_next)):</span><br><span class="line">            x1, y1 = p.ravel()   <span class="comment"># 上一帧点坐标</span></span><br><span class="line">            x2, y2 = n.ravel()   <span class="comment"># 当前帧点坐标</span></span><br><span class="line">            cv2.line(frame, (<span class="built_in">int</span>(x1), <span class="built_in">int</span>(y1)), (<span class="built_in">int</span>(x2), <span class="built_in">int</span>(y2)), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示结果</span></span><br><span class="line">        cv2.imshow(<span class="string">&quot;Optical Flow&quot;</span>, frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新上一帧和特征点</span></span><br><span class="line">        prev_gray = gray.copy()</span><br><span class="line">        prev_points = good_next.reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按下 &#x27;q&#x27; 键退出</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 释放资源</span></span><br><span class="line">    cap.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 功能三：目标跟踪（KCF）===================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">object_tracking</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    功能描述：</span></span><br><span class="line"><span class="string">        - 使用 KCF 目标跟踪器实现手动选择目标并持续跟踪。</span></span><br><span class="line"><span class="string">        - 用户通过鼠标框选目标区域后开始跟踪。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开默认摄像头</span></span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查摄像头是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: Could not open camera!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取第一帧</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 弹出窗口让用户选择跟踪目标区域（ROI）</span></span><br><span class="line">    bbox = cv2.selectROI(<span class="string">&quot;Select ROI&quot;</span>, frame, fromCenter=<span class="literal">False</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化 KCF 跟踪器</span></span><br><span class="line">    tracker = cv2.TrackerKCF_create()</span><br><span class="line">    tracker.init(frame, bbox)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 读取当前帧</span></span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新跟踪器</span></span><br><span class="line">        success, bbox = tracker.update(frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果跟踪成功，绘制矩形框</span></span><br><span class="line">        <span class="keyword">if</span> success:</span><br><span class="line">            x, y, w, h = [<span class="built_in">int</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> bbox]</span><br><span class="line">            cv2.rectangle(frame, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则显示跟踪失败提示</span></span><br><span class="line">            cv2.putText(frame, <span class="string">&quot;Tracking failure detected&quot;</span>, (<span class="number">100</span>, <span class="number">80</span>),</span><br><span class="line">                        cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.75</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示跟踪结果</span></span><br><span class="line">        cv2.imshow(<span class="string">&quot;Object Tracking&quot;</span>, frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按下 &#x27;q&#x27; 键退出</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 释放资源</span></span><br><span class="line">    cap.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== 主程序入口 ===================</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    主程序逻辑：</span></span><br><span class="line"><span class="string">        - 提供一个简单的文本菜单，让用户选择要执行的功能</span></span><br><span class="line"><span class="string">        - 支持：</span></span><br><span class="line"><span class="string">            1. 背景减除</span></span><br><span class="line"><span class="string">            2. 光流法</span></span><br><span class="line"><span class="string">            3. 目标跟踪</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印功能菜单</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Choose an option:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1. Background Subtraction&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2. Optical Flow&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3. Object Tracking&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取用户输入</span></span><br><span class="line">    choice = <span class="built_in">input</span>(<span class="string">&quot;Enter your choice (1/2/3): &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据选择调用对应函数</span></span><br><span class="line">    <span class="keyword">if</span> choice == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        background_subtraction()</span><br><span class="line">    <span class="keyword">elif</span> choice == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        optical_flow()</span><br><span class="line">    <span class="keyword">elif</span> choice == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        object_tracking()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid choice!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用opencv自带的目标跟踪准确率非常低，以下是使用yolo的目标检测代码：</p><h3 id="yolov8目标检测cpu">YOLOv8目标检测（CPU）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载预训练模型（可选：yolov8n.pt, yolov8s.pt, yolov8m.pt...）</span></span><br><span class="line">model = YOLO(<span class="string">&#x27;yolov8s.pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开摄像头</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用YOLO进行推理</span></span><br><span class="line">    results = model(frame)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可视化结果</span></span><br><span class="line">    annotated_frame = results[<span class="number">0</span>].plot()</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&quot;YOLOv8 Detection&quot;</span>, annotated_frame)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="yolov8目标检测gpu">YOLOv8目标检测（GPU）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># ================== 1. 加载预训练模型 ==================</span></span><br><span class="line"><span class="comment"># 支持 yolov8n.pt / yolov8s.pt / yolov8m.pt / yolov8l.pt / yolov8x.pt</span></span><br><span class="line">model = YOLO(<span class="string">&#x27;yolov8s.pt&#x27;</span>)  <span class="comment"># 加载模型，会自动从网络下载到本地缓存目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制使用 GPU（如果可用）</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> model.device.<span class="built_in">type</span> == <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前使用的设备: <span class="subst">&#123;device&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ================== 2. 打开摄像头 ==================</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)  <span class="comment"># 打开默认摄像头（索引号为0）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;错误：无法打开摄像头&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置摄像头分辨率（可选）</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">640</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ================== 3. 实时检测循环 ==================</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始检测，请查看摄像头窗口... 按 q 键退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">prev_time = time.time()  <span class="comment"># 用于计算帧率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;读取帧失败，退出...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 GPU 进行推理</span></span><br><span class="line">    results = model(frame, device=device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制检测结果</span></span><br><span class="line">    annotated_frame = results[<span class="number">0</span>].plot()  <span class="comment"># 自动绘制边界框和标签</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算帧率</span></span><br><span class="line">    current_time = time.time()</span><br><span class="line">    fps = <span class="number">1</span> / (current_time - prev_time)</span><br><span class="line">    prev_time = current_time</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在图像上显示帧率</span></span><br><span class="line">    cv2.putText(annotated_frame, <span class="string">f&quot;FPS: <span class="subst">&#123;<span class="built_in">int</span>(fps)&#125;</span>&quot;</span>, (<span class="number">10</span>, <span class="number">30</span>),</span><br><span class="line">                cv2.FONT_HERSHEY_SIMPLEX, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示结果</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;YOLOv8 实时目标检测&quot;</span>, annotated_frame)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按下 &#x27;q&#x27; 键退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户已按下 q 键，退出检测...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ================== 4. 释放资源 ==================</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b><font color='red'>注意：如果你是笔记本电脑自带的 Intel 集成显卡或AMD 显卡，目前无法使用 CUDA 加速 YOLOv8</font></b></p><h2 id="常用总结">常用总结</h2><table><colgroup><col style="width: 7%" /><col style="width: 37%" /><col style="width: 55%" /></colgroup><thead><tr><th>类别</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>图像读取</td><td><code>cv2.imread</code>, <code>cv2.imwrite</code></td><td><code>image = cv2.imread('lena.png')</code></td></tr><tr><td>视频处理</td><td><code>cv2.VideoCapture</code>, <code>cv2.VideoWriter</code></td><td><code>cap = cv2.VideoCapture(0)</code></td></tr><tr><td>几何变换</td><td><code>cv2.resize</code>, <code>cv2.rotate</code></td><td><code>resized = cv2.resize(image, None, fx=0.5, fy=0.5)</code></td></tr><tr><td>颜色空间</td><td><code>cv2.cvtColor</code></td><td><code>gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</code></td></tr><tr><td>滤波去噪</td><td><code>cv2.GaussianBlur</code>, <code>cv2.medianBlur</code></td><td><code>blurred = cv2.GaussianBlur(image, (11, 11), 0)</code></td></tr><tr><td>边缘检测</td><td><code>cv2.Canny</code>, <code>cv2.Sobel</code></td><td><code>edges = cv2.Canny(gray, 50, 150)</code></td></tr><tr><td>阈值处理</td><td><code>cv2.threshold</code>, <code>cv2.adaptiveThreshold</code></td><td><code>_, binary = cv2.threshold(gray, 128, 255, cv2.THRESH_BINARY)</code></td></tr><tr><td>目标跟踪</td><td><code>cv2.TrackerKCF_create</code></td><td><code>tracker = cv2.TrackerKCF_create()</code></td></tr><tr><td>绘制图形</td><td><code>cv2.putText</code>, <code>cv2.rectangle</code></td><td><code>cv2.rectangle(image, (100, 100), (200, 200), (0, 255, 0), 2)</code></td></tr></tbody></table><h3 id="补充">补充：</h3><p>opencv中图像坐标的原点 (0, 0) 在 <strong>左上角</strong></p><p>一般来说，在深度学习中，<strong>NCHW</strong> 和<strong>NHWC</strong>是两种常见的数据格式，用于表示图像数据的存储方式。它们分别代表不同的维度排列顺序。</p><ul><li><strong>NCHW</strong>：N 表示批量大小（Batch），C表示通道数（Channel），H 表示高度（Height），W 表示宽度（Width）。</li><li><strong>NHWC</strong>：N 表示批量大小（Batch），H表示高度（Height），W 表示宽度（Width），C 表示通道数（Channel）。</li></ul><p><strong>性能差异</strong>：在 GPU 上，<strong>NCHW</strong>格式更适合，因为它可以利用 GPU 的并行性，计算卷积时比 NHWC 要快约 2.5倍。在 CPU 上，NHWC 格式更适合，因为它可以利用 SSE 或 AVX优化，沿着最后一维（即 C 维）计算会更快</p><p>不同的深度学习框架对 NCHW 和 NHWC 格式的支持情况如下：</p><ul><li><strong>TensorFlow</strong>：默认使用 NHWC 格式，GPU 也支持NCHW。</li><li><strong>Caffe</strong>：使用 NCHW 格式。</li><li><strong>PyTorch</strong>：使用 NCHW 格式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件分享】Bandicam破解版</title>
      <link href="/posts/18751.html"/>
      <url>/posts/18751.html</url>
      
        <content type="html"><![CDATA[<h3 id="安装bandicam">安装Bandicam</h3><p>将下载好的压缩包解压到某位置即为安装成功</p><h3 id="使用">使用</h3><p>打开BandicamPortable授权管理员权限（如有）即可正常使用</p><h3 id="下载">下载</h3><p><a class="wp-block-button__link has-text-color has-background" href="https://pan.baidu.com/s/16pouEHOON8tKdbFEDwk1bg?pwd=7sny" style="border-radius:2px;background-color:#ba0c49;color:#fffffa" target="_blank" rel="noreferrer noopener">百度网盘下载【提取码7sny】</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 录屏软件 </tag>
            
            <tag> Bandicam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件分享】PS形状与系统字体分享</title>
      <link href="/posts/13664.html"/>
      <url>/posts/13664.html</url>
      
        <content type="html"><![CDATA[<h3 id="部分形状预览">部分形状预览</h3><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504252310614.png"alt="csh-0048" /><figcaption aria-hidden="true">csh-0048</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504252311346.png"alt="csh-0047" /><figcaption aria-hidden="true">csh-0047</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504252311591.png"alt="csh-0046" /><figcaption aria-hidden="true">csh-0046</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504252311433.png"alt="csh-0045" /><figcaption aria-hidden="true">csh-0045</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504252315616.png"alt="image-20250425231534533" /><figcaption aria-hidden="true">image-20250425231534533</figcaption></figure><h3 id="部分字体预览">部分字体预览</h3><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504252313573.png"alt="image-20250425231317506" /><figcaption aria-hidden="true">image-20250425231317506</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504252313435.png"alt="image-20250425231338366" /><figcaption aria-hidden="true">image-20250425231338366</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504252314424.png"alt="image-20250425231402362" /><figcaption aria-hidden="true">image-20250425231402362</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202504252314695.png"alt="image-20250425231441628" /><figcaption aria-hidden="true">image-20250425231441628</figcaption></figure><h3 id="下载">下载</h3><p><a class="wp-block-button__link has-text-color has-background" href="https://pan.baidu.com/s/18WrdpD6-QVehJ4rUncApTA?pwd=qmu2" style="border-radius:2px;background-color:#ba0c49;color:#fffffa" target="_blank" rel="noreferrer noopener">百度网盘下载【提取码qmu2】</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PS </tag>
            
            <tag> 字体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】使用pm2管理进程时环境变量读取问题</title>
      <link href="/posts/6998.html"/>
      <url>/posts/6998.html</url>
      
        <content type="html"><![CDATA[<p>今天想把我Linux上的项目做到开机自启，通过上网查阅发现可以通过pm2进程管理工具或者自定义服务实现开机自启动，但就当我使用pm2服务启动后，发现我的项目并未生效，提示我的服务为500错误，于是我使用<code>pm2 list</code>查看项目状态<imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202503201128405.png"alt="image-20250320112830364" /></p><p>显示状态正常，于是使用<code>pm2 logs api-nav</code>查看日志发现报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoDB连接失败: MongooseError: The `uri` parameter to `openUri()` must be a string, got &quot;undefined&quot;. Make sure the first parameter to `mongoose.connect()` or `mongoose.createConnection()` is a string.</span><br></pre></td></tr></table></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202503201130189.png"alt="image-20250320113019137" /><figcaption aria-hidden="true">image-20250320113019137</figcaption></figure><p>这个错误我在本地部署以及直接node运行都从未出现过</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202503201132990.png"alt="image-20250320113217955" /><figcaption aria-hidden="true">image-20250320113217955</figcaption></figure><p>显然是正常的，翻译错误提示易知：uri应该是字符串类型，而实际运行时获取到的是undefined，然后我在数据库连接对象中把uri更改为字符串，而非通过<code>.env</code>文件获取，项目就正常运行了，也就是说明在项目运行时对<code>.env</code>文件没有正确的读取</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202503201145516.png" /></p><p>将红框中的删除，蓝框中的修改为实际值，可以暂时解决此问题，但是并非长远之计。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】内大复试</title>
      <link href="/posts/54903.html"/>
      <url>/posts/54903.html</url>
      
        <content type="html"><![CDATA[<h2 id="复试科目">复试科目</h2><table><tr><td t="s" id="sjs-A1">复试批次</td><td t="s" id="sjs-B1">科目名称</td><td t="s" id="sjs-C1">分值</td><td t="s" id="sjs-D1">考试方式</td><td t="s" id="sjs-E1">考试时间</td></tr><tr><td rowspan="3" t="s" id="sjs-A2">一志愿</td><td t="s" id="sjs-B2">程序设计</td><td t="n" id="sjs-C2">50</td><td t="s" id="sjs-D2">笔试</td><td t="s" id="sjs-E2">3月31日晚上20:00-21:00<br>考场安排另行通知</td></tr><tr><td t="s" id="sjs-B3">外国语</td><td t="n" id="sjs-C3">20</td><td rowspan="2" t="s" id="sjs-D3">面试</td><td rowspan="2" t="s" id="sjs-E3">4月1日-4月2日<br>考场安排另行通知</td></tr><tr><td t="s" id="sjs-B4">专业能力</td><td t="n" id="sjs-C4">30</td></tr><tr><td rowspan="2" t="s" id="sjs-A5">调剂</td><td t="s" id="sjs-B5">外国语</td><td t="n" id="sjs-C5">20</td><td rowspan="2" t="s" id="sjs-D5">面试</td><td rowspan="2" t="s" id="sjs-E5">另行通知</td></tr><tr><td t="s" id="sjs-B6">专业能力</td><td t="n" id="sjs-C6">80</td></tr></table><h3 id="成绩计算">成绩计算</h3><blockquote><p><strong>复试成绩</strong>计算公式如下： 一志愿考生复试成绩 =程序设计成绩 + 外国语成绩 + 专业能力成绩 调剂考生复试成绩 = 外国语成绩 +专业能力成绩</p></blockquote><blockquote><p><strong>入学考试总成绩</strong>计算公式如下： 入学考试总成绩（满分100 分） = 初试成绩（折合为百分制） × 50% + 复试成绩 × 50%</p></blockquote><h2 id="程序设计笔试">程序设计（笔试）</h2><h3 id="真题">2024真题</h3><h4 id="题目1">题目1</h4><blockquote><p>输入一个字符串，设计一个算法处理后可以从大到小输出每种字符（包含空格）及其个数</p></blockquote><p>尝试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span> <span class="comment">//strlen函数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">    <span class="type">int</span> index,temp,count[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">128</span>; i++)&#123;  <span class="comment">//将统计数组初值赋0</span></span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(str); i++)&#123;<span class="comment">//统计每个字符出现的次数</span></span><br><span class="line">        index = <span class="type">int</span>(str[i]);</span><br><span class="line">        count[index] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">128</span>; i++)&#123;<span class="comment">//交换排序统计数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]&gt;count[j])&#123;</span><br><span class="line">                temp = count[i];</span><br><span class="line">                count[i] = count[j];</span><br><span class="line">                count[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">128</span>; i++)&#123;<span class="comment">//输出统计数组 </span></span><br><span class="line">        <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c : %d\n&quot;</span>,<span class="type">char</span>(i),count[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 字符数组未初始化</span><br><span class="line">你声明了 char *str; 但没有分配内存或初始化它。这会导致未定义行为。</span><br><span class="line"></span><br><span class="line">2. 输入字符串的读取方式</span><br><span class="line">使用 scanf(&quot;%s&quot;, str); 会忽略空格字符，并且如果 str 没有分配内存，会导致段错误。你应该使用 fgets 来读取包含空格的字符串。</span><br><span class="line"></span><br><span class="line">3. 字符到整数的转换</span><br><span class="line">index = int(str[i]); 和 printf(&quot;%c : %d\n&quot;, char(i), count[i]); 这些写法在 C 语言中是无效的。应该直接使用 (unsigned char)str[i] 和 %c 格式化符。</span><br><span class="line"></span><br><span class="line">4. 冒泡排序逻辑错误</span><br><span class="line">内层循环条件 for(int j=i+1; j&lt;i; j++) 是错误的，应该是 j &lt; 128 - i - 1。此外，只交换频率而不交换对应的字符会导致频率和字符不匹配。</span><br><span class="line"></span><br><span class="line">5. 缺少字符和频率的同步交换</span><br><span class="line">需要同时交换字符和频率，因此最好使用结构体来封装字符和频率。</span><br><span class="line"></span><br><span class="line">6. C语言数组初始化为0可以更简洁</span><br><span class="line">在定义数组时int count[CHAR_MAX] = &#123;0&#125;;</span><br></pre></td></tr></table></figure><p>标答</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CHAR 128  <span class="comment">// ASCII 字符集大小（0-127）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体来存储字符及其频率</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125; CharCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(CharCount *char_counts, <span class="type">int</span> num_chars)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_chars - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num_chars - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (char_counts[j].count &lt; char_counts[j + <span class="number">1</span>].count) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                CharCount temp = char_counts[j];</span><br><span class="line">                char_counts[j] = char_counts[j + <span class="number">1</span>];</span><br><span class="line">                char_counts[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">count_and_sort_chars</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *input_string)</span> &#123;</span><br><span class="line">    <span class="type">int</span> char_freq[MAX_CHAR] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 初始化字符频率数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计每个字符的频率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; input_string[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        char_freq[(<span class="type">unsigned</span> <span class="type">char</span>)input_string[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 CharCount 数组并填充</span></span><br><span class="line">    CharCount char_counts[MAX_CHAR];</span><br><span class="line">    <span class="type">int</span> num_chars = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CHAR; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (char_freq[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            char_counts[num_chars].ch = (<span class="type">char</span>)i;</span><br><span class="line">            char_counts[num_chars].count = char_freq[i];</span><br><span class="line">            num_chars++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对字符频率进行排序</span></span><br><span class="line">    bubble_sort(char_counts, num_chars);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_chars; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c ：%d\n&quot;</span>, char_counts[i].ch, char_counts[i].count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> input_string[<span class="number">1000</span>];  <span class="comment">// 假设输入字符串长度不超过 1000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串: &quot;</span>);</span><br><span class="line">    fgets(input_string, <span class="keyword">sizeof</span>(input_string), <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去掉可能的换行符</span></span><br><span class="line">    input_string[<span class="built_in">strcspn</span>(input_string, <span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    count_and_sort_chars(input_string);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目2">题目2</h4><blockquote><p>实现栈 stack 的基本操作函数。初始化(Init_Stack)。创建一个空栈并分配必要的存储空间。 判空(Stack_Empty)。检查栈是否为空，并返回相应的布尔值。进栈(Push)。向栈中添加一个元素，这个操作通常将新元素添加到栈顶。出栈(Pop)。从栈中移除一个元素，这个操作通常是移除栈顶元素。读栈顶元素(GetTop)。返回栈顶元素但不删除它，如果栈是空的，这个操作可能会失败或返回一个特殊值。 销毁栈(DestroyStack)。释放栈占用的所有存储空间，并设置指针为 NULL。</p></blockquote><p>答案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *data;    <span class="comment">// 存储栈元素的数组</span></span><br><span class="line">    <span class="type">int</span> top;      <span class="comment">// 栈顶元素的索引</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 栈的容量</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Init_Stack</span><span class="params">(Stack *s, <span class="type">int</span> capacity)</span></span><br><span class="line">&#123;</span><br><span class="line">    s-&gt;data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 内存分配失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;            <span class="comment">// 栈空，栈顶索引为 -1</span></span><br><span class="line">    s-&gt;capacity = capacity; <span class="comment">// 设置栈的容量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Stack_Empty</span><span class="params">(Stack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>; <span class="comment">// 如果栈顶索引为 -1，表示栈为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(Stack *s, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == s-&gt;capacity - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈满，不能再进栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = value; <span class="comment">// 将元素压入栈顶</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(Stack *s, <span class="type">int</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Stack_Empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈空，不能出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    *value = s-&gt;data[s-&gt;top--]; <span class="comment">// 弹出栈顶元素，并更新栈顶索引</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(Stack *s, <span class="type">int</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Stack_Empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈空，无法获取栈顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    *value = s-&gt;data[s-&gt;top]; <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(Stack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;data);   <span class="comment">// 释放栈的存储空间</span></span><br><span class="line">    s-&gt;data = <span class="literal">NULL</span>;  <span class="comment">// 将指针置为 NULL</span></span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;     <span class="comment">// 重置栈顶索引</span></span><br><span class="line">    s-&gt;capacity = <span class="number">0</span>; <span class="comment">// 重置栈容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试栈的基本操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化栈，容量为 5</span></span><br><span class="line">    <span class="keyword">if</span> (!Init_Stack(&amp;s, <span class="number">5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈初始化失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进栈操作</span></span><br><span class="line">    Push(&amp;s, <span class="number">10</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">20</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (GetTop(&amp;s, &amp;value))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈顶元素是: %d\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="keyword">if</span> (Pop(&amp;s, &amp;value))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈元素: %d\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法出栈！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (GetTop(&amp;s, &amp;value))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈顶元素是: %d\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁栈</span></span><br><span class="line">    DestroyStack(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目3">题目3</h4><blockquote><p>设计一个算法实现输入一个数字将其转换成汉语大写并输出 例：输入 0 输出零 输入 121 输出 一百二十一 输入 -121 输出 负一百二十一</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试</span><br></pre></td></tr></table></figure><h3 id="真题-1">2023真题</h3><h4 id="题目1-1">题目1</h4><blockquote><p>帮助大家利用鞋码算出脚长。要求：1、允许用户输入自己的鞋码，并有提示语’请输入你的鞋码：‘，不需要包括单引号；2、计算鞋码，脚长＝（鞋码＋10)/2; 3、输出脚长，并有提示语’你的脚长是：’示例 输入：38 输出：你的脚长是：24.0</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> <span class="title function_">footLength</span><span class="params">(<span class="type">int</span> shoeSize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> shoeSize;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你的鞋码：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;shoeSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的脚长是：%.1f&quot;</span>,footLength(shoeSize));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">footLength</span><span class="params">(<span class="type">int</span> shoeSize)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (shoeSize+<span class="number">10</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目2-1">题目2</h4><blockquote><p>给定一个以秒为单位的时间t，要求用“H:M:S”的格式来表示这个时间。H表示时间，M表示分钟，而S表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。输入格式 　　输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。 输出格式　　输出只有一行，是以“H:M:S”的格式所表示的时间，不包括引号。 样例输入5436 样例输出 1:30:36</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="type">int</span> S = t%<span class="number">60</span>;</span><br><span class="line">    <span class="type">int</span> M = (t/<span class="number">60</span>)%<span class="number">60</span>;</span><br><span class="line">    <span class="type">int</span> H = t/<span class="number">60</span>/<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d:%d&quot;</span>,H,M,S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目3-1">题目3</h4><blockquote><p>有n个学生的信息(包括学号，姓名，成绩)，存入结构体中，要求按照成绩的高低顺序输出学生的信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> stuNum;</span><br><span class="line">    <span class="type">char</span> stuName[<span class="number">100</span>];</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; Student;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Student *stuList; <span class="comment">//学生结构体数组</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">//学生数量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    stuList = (Student*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(Student)); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n ; i++)&#123;</span><br><span class="line">        Student stu;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %f&quot;</span>,&amp;stu.stuNum,stu.stuName,&amp;stu.grade);  <span class="comment">//这里格式化输入使用逗号排序就不生效，使用空格可以？？因为%s！！！</span></span><br><span class="line">        stuList[i] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span> ; j&lt;n-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stuList[j].grade&lt;stuList[j+<span class="number">1</span>].grade)&#123;</span><br><span class="line">                Student temp = stuList[j];</span><br><span class="line">                stuList[j] = stuList[j+<span class="number">1</span>];</span><br><span class="line">                stuList[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n ; i++)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d,%s,%.1f\n&quot;</span>,stuList[i].stuNum,stuList[i].stuName,stuList[i].grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> stuNum;</span><br><span class="line">    <span class="type">char</span> stuName[<span class="number">100</span>];</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于 qsort</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    Student *studentA = (Student *)a;</span><br><span class="line">    Student *studentB = (Student *)b;</span><br><span class="line">    <span class="keyword">if</span> (studentA-&gt;grade &gt; studentB-&gt;grade) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (studentA-&gt;grade &lt; studentB-&gt;grade) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 学生数量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入学生数量: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;学生数量必须大于0。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student *stuList = (Student *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(Student));</span><br><span class="line">    <span class="keyword">if</span> (stuList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入学生信息(学号 姓名 成绩):\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;学生 %d: &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d,%s,%f&quot;</span>, &amp;stuList[i].stuNum, stuList[i].stuName, &amp;stuList[i].grade) != <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入格式错误。\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(stuList);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 qsort 进行排序</span></span><br><span class="line">    qsort(stuList, n, <span class="keyword">sizeof</span>(Student), compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按成绩从高到低排序后的学生信息:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %.2f\n&quot;</span>, stuList[i].stuNum, stuList[i].stuName, stuList[i].grade);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(stuList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目4">题目4</h4><blockquote><p>输入字符串A、字符串B，求在字符串A、字符串B中相同的字符个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数用于计算字符串中相同字符的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countSameChars</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">    <span class="comment">// 遍历字符串1中的每个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str1[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历字符串2中的每个字符，与字符串1中的字符比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; str2[j] != <span class="string">&#x27;\0&#x27;</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果两个字符相同，则计数器加1</span></span><br><span class="line">            <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到相同字符后，结束当前循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数用于从字符串中去除重复字符，并将结果存储在新的字符串中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> *result)</span> &#123;</span><br><span class="line">    <span class="type">int</span> visited[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 用于标记字符是否已经被访问过</span></span><br><span class="line">    <span class="comment">// 遍历原字符串中的每个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果字符未被访问过，则将其添加到结果字符串中，并标记为已访问</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[(<span class="type">unsigned</span> <span class="type">char</span>)str[i]]) &#123;</span><br><span class="line">            result[j++] = str[i];</span><br><span class="line">            visited[(<span class="type">unsigned</span> <span class="type">char</span>)str[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在结果字符串末尾添加结束符</span></span><br><span class="line">    result[<span class="built_in">strlen</span>(result)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> strA[<span class="number">100</span>], strB[<span class="number">100</span>]; <span class="comment">// 定义两个字符串数组</span></span><br><span class="line">    <span class="type">char</span> strC[<span class="number">100</span>]; <span class="comment">// 用于存储字符串A去除重复字符后的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串A: &quot;</span>);</span><br><span class="line">    gets(strA); <span class="comment">// 输入字符串A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串B: &quot;</span>);</span><br><span class="line">    gets(strB); <span class="comment">// 输入字符串B</span></span><br><span class="line">    <span class="comment">// 去除字符串A中的重复字符</span></span><br><span class="line">    removeDuplicates(strA, strC);</span><br><span class="line">    <span class="comment">// 调用函数计算相同字符的个数并输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串A（去重）和字符串B中相同字符的个数为: %d\n&quot;</span>, countSameChars(strC, strB));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中，我们用 <code>gets()</code> 函数代替了<code>scanf()</code>函数，确保了可以一次性读取一整行输入。然后我们需要确保输入的字符串不会超出数组的容量，以避免缓冲区溢出的情况。</p><blockquote><p>上述scanf语句中可以把A写成＆A吗？</p></blockquote><p>不可以，scanf函数中应该直接使用数组名，而不需要加上取地址符号&amp;。数组名本身就代表数组在内存中的地址，因此不需要使用&amp;。所以正确的写法是： scanf(“%s”, A); scanf(“%s”, B);</p><blockquote><p>若输入的是%c则可以写成＆A吗</p></blockquote><p>对于%c格式的输入，需要使用 &amp;取地址符号来获取输入的字符的地址。因此，对于%c格式的输入，可以写成&amp;A。所以正确的写法是：scanf(“%c”, &amp;A); scanf(“%c”, &amp;B);</p><blockquote><p>其中%s是什么意思</p></blockquote><p>%s 是 scanf 函数的格式控制符，用于读取字符串。当使用 %s 时，scanf会从输入中读取字符，直到遇到空白字符（空格、制表符、换行符）或者字符串结束符\0 为止，并将读取的字符序列存储到指定的字符串变量中，以空字符 \0 结尾。例如，scanf(“%s”, str); 会从标准输入中读取一个字符串，并将其存储到 str中。</p><h3 id="真题-2">2019真题</h3><h4 id="题目1-2">题目1</h4><blockquote><p>输入10个人的成绩，计算平均分，记录低于平均分的人数，并将他们的成绩输入到一个数组中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">float</span> a[<span class="number">10</span>], b[<span class="number">10</span>], sum = <span class="number">0</span>, n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个人的成绩：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;a[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    n = sum / <span class="number">10</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不合格的学生成绩为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; n) &#123;</span><br><span class="line">            b[j++] = a[i];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, a[i]);  <span class="comment">// 输出不合格的学生成绩</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不合格总人数为：%d\n&quot;</span>, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平均分为：%.2f\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目2-2">题目2</h4><blockquote><p>使用递归方法从数组中找出最大值</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 递归函数，用于寻找数组中的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> index, <span class="type">int</span> n, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == n)</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    max = (max &gt; arr[index]) ? max : arr[index];</span><br><span class="line">    <span class="keyword">return</span> findMax(arr, index + <span class="number">1</span>, n, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, i, max;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组的长度：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个数：\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    max = a[<span class="number">0</span>]; <span class="comment">// 初始最大值为数组的第一个元素</span></span><br><span class="line">    max = findMax(a, <span class="number">0</span>, n, max); <span class="comment">// 调用递归函数查找最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组中的最大值为：%d\n&quot;</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目3-2">题目3</h4><blockquote><p>求解一元二次方程组（三种情况）（一个解，两个，复数解）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b, <span class="type">double</span> c)</span>&#123;</span><br><span class="line">    <span class="type">double</span> dlt = b*b<span class="number">-4</span>*a*c;</span><br><span class="line">    <span class="keyword">if</span>(dlt&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">double</span> x1 = (-b+<span class="built_in">sqrt</span>(dlt))/<span class="number">2</span>/a;</span><br><span class="line">        <span class="type">double</span> x2 = (-b-<span class="built_in">sqrt</span>(dlt))/<span class="number">2</span>/a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个解为%.2lf,%.2lf&quot;</span>,x1,x2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dlt=-dlt;</span><br><span class="line">        <span class="type">double</span> shi = -b/<span class="number">2</span>/a;</span><br><span class="line">        <span class="type">double</span> xu = <span class="built_in">sqrt</span>(dlt)/<span class="number">2</span>/a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个解为%.2lf±%.2lfi&quot;</span>,shi,xu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    solve(a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目4-1">题目4</h4><blockquote><p>输入字符串和一个数字，并将字符串以数组方式存储并进行平移操作，如abdcf 向前平移2个 变成dcfab</p></blockquote><p>尝试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入字符串和一个数字，并将字符串以数组方式存储并进行平移操作， 如abdcf 向前平移2个 变成dcfab</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shiftString</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length ; i++)&#123;</span><br><span class="line">temp = str[i];</span><br><span class="line">str[i] = str[(i+n)%length];</span><br><span class="line">str[(i+n)%length] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入字符串：&quot;</span>); </span><br><span class="line">gets(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入向前移动的位数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">shiftString(str,<span class="built_in">strlen</span>(str),n); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标答</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数用于实现字符串的平移操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shiftString</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> shift, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> temp[shift]; <span class="comment">// 创建临时数组保存平移后的字符串</span></span><br><span class="line">    <span class="comment">// 将前半部分字符移动到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shift; i++) &#123;</span><br><span class="line">        temp[i] = str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余部分整体前移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = shift; i &lt; len; i++) &#123;</span><br><span class="line">        str[i - shift] = str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组中的字符放置到字符串末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shift; i++) &#123;</span><br><span class="line">        str[len - shift + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1024</span>]; <span class="comment">// 存储字符串的数组</span></span><br><span class="line">    <span class="type">int</span> shift; <span class="comment">// 平移的个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str); <span class="comment">// 输入字符串</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// 计算字符串的长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入平移的个数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;shift); <span class="comment">// 输入平移的个数</span></span><br><span class="line">    <span class="comment">// 调用函数进行字符串的平移操作</span></span><br><span class="line">    shiftString(str, shift, len);</span><br><span class="line">    <span class="comment">// 输出平移后的字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平移后的字符串：%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目5">题目5</h4><blockquote><p>用二维数组实现矩阵乘法</p></blockquote><p>尝试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用二维数组实现矩阵乘法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> rowA,rowB,colA,colB;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵A的行数和列数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;rowA,&amp;colA);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵B的行数和列数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;rowB,&amp;colB);</span><br><span class="line"><span class="keyword">if</span>(colA!=rowB)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不满足A*B的条件（A的列数等于B的行数）&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A[rowA][colA],B[rowB][colB],C[rowA][colB];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rowA ; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵A的第%d行元素：&quot;</span>,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;colA; j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rowB ; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵B的第%d行元素：&quot;</span>,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;colB; j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;B[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rowA; i++)&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>,j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;colA; j++)&#123;</span><br><span class="line">sum += A[i][j]*B[j][i];</span><br><span class="line">&#125;</span><br><span class="line">C[i][j] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rowA; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;colB; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,C[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标答</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rowA, rowB, colA, colB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入矩阵A的行数和列数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵A的行数和列数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;rowA, &amp;colA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入矩阵B的行数和列数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵B的行数和列数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;rowB, &amp;colB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否满足矩阵乘法条件</span></span><br><span class="line">    <span class="keyword">if</span> (colA != rowB) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不满足A*B的条件（A的列数等于B的行数）\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配矩阵A、B和C的空间</span></span><br><span class="line">    <span class="type">int</span> **A = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rowA * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;</span><br><span class="line">        A[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(colA * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> **B = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rowB * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowB; i++) &#123;</span><br><span class="line">        B[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(colB * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> **C = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rowA * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;</span><br><span class="line">        C[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(colB * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入矩阵A的元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵A的元素：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; colA; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入矩阵B的元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵B的元素：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowB; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; colB; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算矩阵乘法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; colB; j++) &#123;</span><br><span class="line">            C[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; colA; k++) &#123;</span><br><span class="line">                C[i][j] += A[i][k] * B[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果矩阵C</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;矩阵A * 矩阵B 的结果是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; colB; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, C[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowB; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(C);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目6">题目6</h4><blockquote><p>输入工人的工资，要求工资从小到大进行排序，并以链表的形式进行存储并输出</p></blockquote><p>尝试 由AI完善</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">WorkerNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> salary;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">WorkerNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; WorkerNode, *WorkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertSorted</span><span class="params">(WorkList *head, <span class="type">int</span> salary)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(WorkList head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WorkList L = <span class="literal">NULL</span>; <span class="comment">// 初始化空链表</span></span><br><span class="line">    <span class="type">int</span> salary;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入工人工资（输入0结束）\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个工人工资：&quot;</span>, ++i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;salary);</span><br><span class="line">        <span class="keyword">if</span> (salary == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入工资到有序链表中</span></span><br><span class="line">        insertSorted(&amp;L, salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的链表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的工人工资：\n&quot;</span>);</span><br><span class="line">    printList(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入函数，保持链表有序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertSorted</span><span class="params">(WorkList *head, <span class="type">int</span> salary)</span> &#123;</span><br><span class="line">    WorkerNode *newNode = (WorkerNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(WorkerNode));</span><br><span class="line">    <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;salary = salary;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">NULL</span> || (*head)-&gt;salary &gt;= salary) &#123;</span><br><span class="line">        newNode-&gt;next = *head;</span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        WorkerNode *current = *head;</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span> &amp;&amp; current-&gt;next-&gt;salary &lt; salary) &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = current-&gt;next;</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(WorkList head)</span> &#123;</span><br><span class="line">    WorkerNode *current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;salary);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目7">题目7</h4><blockquote><p>快速排序</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个整数的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high]; <span class="comment">// 选择最后一个元素作为基准</span></span><br><span class="line">    <span class="type">int</span> i = (low - <span class="number">1</span>); <span class="comment">// i是较小元素的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素小于或等于基准</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++; <span class="comment">// 增加较小元素的索引</span></span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[i + <span class="number">1</span>], &amp;arr[high]);</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// pi 是分区索引，arr[pi] 已经排好序</span></span><br><span class="line">        <span class="type">int</span> pi = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别对左右子数组进行递归排序</span></span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未排序数组：\n&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后数组：\n&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真题-3">2018真题</h3><h4 id="题目1-3">题目1</h4><blockquote><p>两个正整数间所有偶数和</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumOfEvenNumbers</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 确保 start 和 end 是较小的数和较大的数</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="type">int</span> temp = start;</span><br><span class="line">        start = end;</span><br><span class="line">        end = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历从 start 到 end 的所有数字，将偶数加到总和中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个正整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;start, &amp;end);</span><br><span class="line">    <span class="type">int</span> result = sumOfEvenNumbers(start, end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从 %d 到 %d 之间所有偶数的和为：%d\n&quot;</span>, start, end, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目2-3">题目2</h4><blockquote><p>输入一个数，计算 <spanclass="math display">1 × 1 + 2 × 2 + ... + <em>n</em> × <em>n</em></span></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个正整数 n：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 到 %d 之间所有整数的平方和为：%d\n&quot;</span>, n, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目3-3">题目3</h4><blockquote><p>迭代法求平方根 迭代公式为： <span class="math display">$$x_{n+1}=\frac{1}{2}(x_n+\frac{a}{x_n})$$</span> 要求前后两次求出的得差的绝对值少于0.00001</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> n, x1, x2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数 n：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);</span><br><span class="line">    x2 = n;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x1 = x2;</span><br><span class="line">        x2 = (x1 + n / x1) / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">fabs</span>(x1 - x2) &gt;= <span class="number">0.00001</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数 %lf 的平方根为：%lf\n&quot;</span>, n, x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目4-2">题目4</h4><blockquote><p>读文件，统计行数，大小写字母，数字</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> lines = <span class="number">0</span>, uppercase = <span class="number">0</span>, lowercase = <span class="number">0</span>, digits = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> last_char_was_newline = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入文件名: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%99s&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    file = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字符读取文件内容</span></span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(file)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            lines++;</span><br><span class="line">            last_char_was_newline = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last_char_was_newline = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch)) &#123;</span><br><span class="line">                uppercase++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">islower</span>(ch)) &#123;</span><br><span class="line">                lowercase++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                digits++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件不以换行符结束，则最后一行也算一行</span></span><br><span class="line">    <span class="keyword">if</span> (!last_char_was_newline &amp;&amp; lines &gt; <span class="number">0</span> || (lines == <span class="number">0</span> &amp;&amp; ch != EOF)) &#123;</span><br><span class="line">        lines++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出统计结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;行数: %d\n&quot;</span>, lines);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;大写字母: %d\n&quot;</span>, uppercase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;小写字母: %d\n&quot;</span>, lowercase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数字: %d\n&quot;</span>, digits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目5-1">题目5</h4><blockquote><p>(a+b)的n次方方程的展开后的各项系数,即杨辉三角</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：用于在每一行前打印指定数量的空格，以使输出对齐成三角形</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">space</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">// 打印 n - i - 1 个空格</span></span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 每次打印一个空格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, i, j;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">21</span>][<span class="number">21</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 初始化一个21x21的二维数组，所有元素初始为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示用户输入杨辉三角的行数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入行数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 读取用户输入的行数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化杨辉三角的第一行和第二行</span></span><br><span class="line">    a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成杨辉三角的其余部分</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++) <span class="comment">// 从第3行开始计算</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 每一行的第一个元素总是1</span></span><br><span class="line">        a[i][i] = <span class="number">1</span>; <span class="comment">// 每一行的最后一个元素总是1</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            a[i][j] = a[i - <span class="number">1</span>][j] + a[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 计算当前元素为上一行相邻两个元素之和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印杨辉三角</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        space(n, i); <span class="comment">// 调用space函数打印适当数量的空格，使输出对齐成三角形</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]); <span class="comment">// 打印当前行的所有元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目6-1">题目6</h4><blockquote><p>输入一个整数，递归逆序输出这个整数的各位数，例如n为4892，则输出2984</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数：逆序输出整数的每一位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出当前数字的最后一位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数字大于等于10，则递归调用自身处理去掉最后一位后的剩余部分</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">10</span>)</span><br><span class="line">        rs(n / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示用户输入一个整数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取用户输入的整数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查输入是否为负数，并处理负号</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>); <span class="comment">// 输出负号</span></span><br><span class="line">        n = -n;      <span class="comment">// 将负数转换为正数处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归函数逆序输出整数的每一位</span></span><br><span class="line">    rs(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他">其他</h3><blockquote><p>输入两个数m，n，然后输入一个m进制字符串，将其转化为n进制</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将m进制字符串转换为十进制整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">m_to_decimal</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="type">int</span> decimal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> digit = str[i] &gt;= <span class="string">&#x27;A&#x27;</span> ? str[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span> : str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (digit &gt;= m) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无效的m进制数字\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        decimal += digit * <span class="built_in">pow</span>(m, len - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decimal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十进制整数转换为n进制字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decimal_to_n</span><span class="params">(<span class="type">int</span> decimal, <span class="type">int</span> n, <span class="type">char</span> *result)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (decimal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> remainder = decimal % n;</span><br><span class="line">        <span class="keyword">if</span> (remainder &lt; <span class="number">10</span>)</span><br><span class="line">            result[index++] = remainder + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result[index++] = remainder - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        decimal /= n;</span><br><span class="line">    &#125;</span><br><span class="line">    result[index] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转结果字符串以得到正确的n进制表示</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = index - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="type">char</span> temp = result[i];</span><br><span class="line">        result[i] = result[j];</span><br><span class="line">        result[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">char</span> m_str[<span class="number">65</span>]; <span class="comment">// 假设最大支持64位字符（包括字母和数字）</span></span><br><span class="line">    <span class="type">char</span> n_str[<span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示用户输入m和n</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入m进制和n进制：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示用户输入m进制字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个m进制字符串：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, m_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将m进制字符串转换为十进制</span></span><br><span class="line">    <span class="type">int</span> decimal = m_to_decimal(m_str, m);</span><br><span class="line">    <span class="keyword">if</span> (decimal == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 如果输入无效，程序退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将十进制转换为n进制字符串</span></span><br><span class="line">    decimal_to_n(decimal, n, n_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;转换后的n进制字符串是：%s\n&quot;</span>, n_str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C语言中使用快速排序</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含 qsort 函数声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于比较两个整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始数组: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 qsort 函数进行排序</span></span><br><span class="line">    qsort(arr, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外国语面试">外国语（面试）</h2><h3 id="自我介绍self-introduction">自我介绍（self-introduction）</h3><h4 id="逐句翻译">逐句翻译</h4><blockquote><p>Good morning/afternoon, dear professors.</p><p>尊敬的各位教授，早上/下午好。</p><p>It is my honor to meet all of you here.</p><p>非常荣幸能在这里与大家见面。</p><p>My name is XXX, (you know), “X” in Chinese means XX and XX while “X”represents XX and XX.</p><p>我叫XXX，“X”在中文里意为XX，“X”则代表XX。</p><p>These qualities truly reflect who I am.</p><p>这些品质正是我的真实写照。</p><p>I’m twenty-two years old and come from Jining, Shandong Province, acity with rich history and vivid culture.</p><p>我今年二十二岁，来自山东省济宁市，一个拥有丰富历史和生动文化的美丽城市。</p><p>I will be graduating this year from Linyi University with aBachelor’s degree in Software Engineering, which let me step into thedoor of computer and programming.</p><p>今年我将从临沂大学软件工程专业毕业，获得学士学位，这让我踏上了计算机和编程的大门。</p><p>During my undergraduate studies, I gained some relevant skills, suchas CET4 (College English Test Band 4), database system engineer insoftware examination, second prize in ‘LanQiao Cup’ algorithmcompetition, second prize in CUMCM (China Undergraduate MathematicalContest in Modeling) and so on, which developed my programming literacyand teamwork capability.</p><p>在本科期间，我掌握了一些相关技能，例如通过了大学英语四级考试（CET4），获得了软件评测师（数据库系统工程师）证书，在“蓝桥杯”算法竞赛中获得二等奖，在全国大学生数学建模竞赛（CUMCM）中也获得了二等奖等。这些经历不仅提升了我的编程素养，还锻炼了我的团队合作能力。</p><p>I kept writing blogs in my spare time, now I’ve written about onehundred blogs.</p><p>课余时间，我一直坚持写博客，至今已经撰写了大约一百篇技术文章。</p><p>With the advent of autonomous driving and ChatGPT, I becameincreasingly interested in computer vision and large models.</p><p>随着自动驾驶和ChatGPT等新兴技术的发展，我对计算机视觉和大模型产生了浓厚的兴趣。</p><p>And I know university education only offers a rough understanding ofprogramming, deeper researches are needed.</p><p>我知道，大学教育只能提供编程的初步理解，深入的研究还需要进一步的学习。</p><p>So, I took this examination to further my academic study.</p><p>因此，我参加了这次考试，以继续深造。</p><p>I am determined to further my academic pursuit here.</p><p>我决心在这里进一步追求学术研究。</p><p>Finally, I ended my self-introduction with a sentence.</p><p>最后，我想用一句话结束我的自我介绍。</p><p>I do not know where to go, but I have been on the road.</p><p>我不知道要去哪里，但我一直在路上。</p><p>That’s all about me. Thanks for your listening!</p><p>这就是我，谢谢大家的聆听！</p></blockquote><h3 id="提问">提问</h3><ol type="1"><li><p>研究生期间计划（plans in the postgraduate study）</p><blockquote><p><strong>What are your plans for graduate school？</strong></p></blockquote></li><li><p>职业规划（career planning）</p><blockquote><p><strong>What are your career plans for the future?</strong></p></blockquote></li><li><p>介绍你的家庭（family）</p><blockquote><p><strong>Please introduce your family?</strong></p></blockquote><blockquote><p><strong>The person in your family who has the most influence on you,and explain？</strong></p></blockquote></li><li><p>介绍你的大学（university）</p><blockquote><p><strong>When and where did you graduate?</strong></p></blockquote></li><li><p>介绍你的家乡（hometown）</p><blockquote><p><strong>Please introduce your hometown</strong></p></blockquote><blockquote><p><strong>Tell me about a traditional culture in yourhometown</strong></p></blockquote><blockquote><p><strong>Tell me about your hometown cuisine</strong></p></blockquote></li><li><p>兴趣爱好（hobby）</p><blockquote><p><strong>Describe your interests</strong></p></blockquote><blockquote><p><strong>What’s your favorite movies? </strong></p></blockquote><blockquote><p><strong>What is your favorite sport?</strong></p></blockquote><blockquote><p><strong>What is your favorite song and why do you likeit?</strong></p></blockquote><blockquote><p><strong>What kind of job do you like to give threereasons?</strong></p></blockquote><blockquote><p><strong>What’s your favorite food? Why is that?</strong></p></blockquote></li><li><p>性格特点（personality）</p><blockquote><p><strong>What are your strengths andweaknesses/personalities？</strong></p></blockquote></li><li><p>印象中最深刻的一件事（memory）</p></li><li><p>如果这次失败了,你会怎么做？</p><blockquote><p><strong>If you fail this time, what will you do?</strong></p></blockquote></li><li><p>研究生需要具备哪些(品质)能力？</p><blockquote><p><strong>What abilities are required of graduatestudents？</strong></p></blockquote></li><li><p>你在大学里参加过什么社团或者活动？并获得了什么？</p><blockquote><p><strong>What clubs or activities did you participate in atuniversity? And what did you get?</strong></p></blockquote></li><li><p>你最喜欢的老师？对你影响最大的老师？</p><blockquote><p><strong>The teacher who influenced you the most</strong></p><p><strong>Which kind of professors do you like best? </strong></p></blockquote></li><li><p>介绍一下你的大学生活</p><blockquote><p><strong>Tell me about your college life</strong></p></blockquote></li><li><p>你认为最好的大学生活是怎样的？</p><blockquote><p><strong>What is the best university life in youropinion?</strong></p></blockquote></li><li><p>你最怀念现在学校的什么？</p><blockquote><p><strong>What do you miss most about your current school?</strong></p></blockquote></li><li><p>明年你想要做什么？</p><blockquote><p><strong>What you want to do next year?</strong></p></blockquote></li><li><p>如果你成功通过复试，你是否有心仪的老师？</p><blockquote><p><strong>If you successfully pass the second interview, do you have afavorite teacher?</strong></p></blockquote></li><li><p>说说你的获奖情况</p><blockquote><p><strong>Tell me about your awards</strong></p></blockquote><blockquote><p><strong>What qualifications have you obtained?</strong></p></blockquote></li><li><p>我们为什么录取你？你和其他人有什么不同？</p><blockquote><p><strong>Why did we admit you? What makes you different from the othercandidates?</strong></p></blockquote></li><li><p>本科学习阶段最大的挑战是什么？并且是如何克服的？</p><blockquote><p><strong>What are the biggest challenges in undergraduate study?Andhow did they overcome it?</strong></p></blockquote></li><li><p>你如何解决你曾经犯过的错误？</p><blockquote><p><strong>How do you solve a mistake you once made?</strong></p></blockquote></li><li><p>寒假假期干了什么？</p><blockquote><p><strong>What did you do during your winter vacation？</strong></p></blockquote></li><li><p>最擅长的课程？最喜欢的课程？</p><blockquote><p><strong>What is your best subject？What is your favoritesubject?</strong></p></blockquote></li><li><p>数学在计算机中重要吗？为什么？给出三个理由</p><blockquote><p><strong>Is mathematics important in computers? Why give threereasons？</strong></p></blockquote></li><li><p>你最后悔的事？最怕的事？</p><blockquote><p><strong>What’s your biggest regret?</strong></p></blockquote></li><li><p>人生方向</p><blockquote><p><strong>If you were given only one choice, would you choose aspecialized life direction or a divergent life direction?</strong></p></blockquote></li><li><p>如果团队里有人不干活，你会怎么处理？</p><blockquote><p><strong>What do you do when other people on your team don’t do theirjobs？</strong></p></blockquote></li><li><p>使你感到最兴奋的一件事，说出三个原因？</p><blockquote><p><strong>What is the one thing you are most excited about, and namethree reasons why?</strong></p></blockquote></li><li><p>你最害怕什么？</p><blockquote><p><strong>What are you most afraid of?</strong></p></blockquote></li><li><p>如何解决压力？</p><blockquote><p><strong>How do you deal with stress?</strong></p></blockquote></li><li><p>如何平衡学习和生活？</p><blockquote><p><strong>How to balance study and life?</strong></p></blockquote></li><li><p>你的强项是什么？</p><blockquote><p><strong>What are your strengths?</strong></p></blockquote></li><li><p>你现在最在意什么？</p><blockquote><p><strong>What is your biggest concern right now?</strong></p></blockquote></li><li><p>怎么庆祝生日？</p><blockquote><p><strong>How do you celebrate your birthday?</strong></p></blockquote></li><li><p>人工智能是什么？</p><blockquote><p><strong>What is artificial intelligence?</strong></p></blockquote></li><li><p>你对科技的看法？</p><blockquote><p><strong>Talk about your views on technology</strong></p></blockquote></li><li><p>说一下互联网的优缺点</p><blockquote><p><strong>Let’s talk about the advantages and disadvantages of theInternet</strong></p></blockquote></li><li><p>你认为对我们专业影响最大的人是谁？</p><blockquote><p><strong>Who do you think has had the greatest impact on ourprofession?</strong></p></blockquote></li><li><p>你认为是哪一个学科推动了社会的进步？</p></li><li><p>QQ和微信你觉得哪一个更好？</p></li><li><p>good和excellent的区别</p><blockquote><p><strong>What’s difference between good and excellent? </strong></p></blockquote></li><li><p>大学生的使命？</p><blockquote><p><strong>Mission of college students</strong></p></blockquote></li><li><p>你觉得钱不重要得三个原因？</p><blockquote><p><strong>Do you have three reasons why money is not important?</strong></p></blockquote></li><li><p>你为什么选择内蒙古大学？</p><blockquote><p><strong>Why did you choose Inner Mongolia University?</strong></p></blockquote></li><li><p>为什么不选择本校的研究生？</p><blockquote><p><strong>Why not choose a graduate student from an undergraduateschool?</strong></p></blockquote></li><li><p>为什么考研？</p><blockquote><p><strong>Why do you plan to make master’ s degree?</strong></p></blockquote></li><li><p>为什么选择这个专业？</p><blockquote><p><strong>Why did you study this major?</strong></p></blockquote></li></ol><ul><li><p>应急措施：</p><ol type="1"><li><p>问题没听清时：</p><blockquote><p>I’m sorry, I didn’t get your question.</p><p>Could you say it again?</p></blockquote></li><li><p>问题不会时：</p><blockquote><p>I’m so sorry. I find it hard for me to answer this question.</p><p>So could you mind asking another question?</p></blockquote></li><li><p>等待一分钟：</p><blockquote><p>I’m so sorry. I find it hard for me to answer this question. So,may Ihave two minutes to think about it?</p></blockquote></li></ol></li></ul><h3 id="总结">总结</h3><h4 id="smile-bar">smile bar</h4><ul><li><strong>s-3 个</strong></li></ul><p>-studying in a great academic atmosphere 好的学术氛围学习</p><p>-searching literature quickly and accurately 快速准确搜索⽂献</p><p>-shortening the distance with friends 拉近和朋友的距离</p><ul><li><strong>m-3 个</strong></li></ul><p>-making more excellent/outstanding friends(new)认识更多优秀的朋友</p><p>-maintaining my continuous passion for study 保持持续的热情</p><p>-making great efforts for my goals 努⼒实现⽬标</p><ul><li><strong>i-1 个</strong></li></ul><p>improving my study efficiency 提⾼学习效率/ competence 竞争力/socialresponsibility 社会责任感</p><ul><li><strong>l-2 个</strong></li></ul><p>-living in a beautiful campus ⽣活在美丽的校园</p><p>-learning more things 学到更多东⻄/learning more knowledge 知识</p><ul><li><strong>e-3 个</strong></li></ul><p>-enriching my (spiritual) life</p><p>-enjoying the great teaching faculty.享有好的师资⼒量</p><p>-exploring new things 探索新事物</p><ul><li><strong>b-3 个</strong></li></ul><p>-bearing hardships and sufferings 吃苦耐劳</p><p>-becoming a more positive/optimistic person 更乐观</p><p>-broadening my horizons 开阔视野</p><ul><li><strong>a-2 个</strong></li></ul><p>-acquiring X 获得 X</p><p>先进知识 more advanced knowledge</p><p>更⾼平台 a higher platform</p><p>更多快乐和满⾜感 more happiness and satisfaction</p><p>更⼤动⼒ more motivation</p><p>-adapting to the new environment quickly 适应新环境</p><ul><li><strong>r-2 个</strong></li></ul><p>-relaxing myself 放松自己</p><p>-relieving my pressure 缓解压力</p><h4 id="你喜欢的">你喜欢的？</h4><p>模板</p><blockquote><p>Thanks for your question! 感谢您的问题</p><p><code>X</code> is my favorite <code>___</code>, because:X是我最喜欢的<code>___</code>，因为</p><p>From <code>___</code>, I can benefit a lot, such as A, B and C.通过<code>___</code>，我受益颇多，比如…</p><p>All of these would be helpful to my future life and study.这些对我未来的生活和学习都很有帮助</p></blockquote><h5 id="书籍book">书籍（book）</h5><blockquote><p>Thanks for your question!</p><p>《Three Days to See》is one of my favorite books, because:</p><p>From reading this book, I benefit a lot, such as acquiring moremotivation, becoming a more positive person and enriching my spirituallife.</p><p>All of these would be helpful to my future life and study.</p></blockquote><h5 id="专业书籍professional-book">专业书籍（professional book）</h5><blockquote><p>Thanks for your question!</p><p>《The Crowd》is one of my favorite books, because:</p><p>From reading this book, I benefit a lot, such as gaining deeperinsights into human behavior, understanding the dynamics of grouppsychology, and learning how collective thought can influence individualactions. Broadening my horizons in this way has helped me appreciate thecomplexity of social phenomena. Additionally, it has improved mycompetence in analyzing crowd behavior and its implications onsociety.</p><p>All of these would be helpful to my future life and study</p></blockquote><h5 id="老师teacher">老师（teacher）</h5><blockquote><p>Thanks for your question! The teacher I like the most is the one whoteaches my Java course, because: From his class, I can always benefit alot, such as acquiring more motivation, becoming a more positive personand learning more things. All of these would be helpful to my futurelife and study.</p></blockquote><h5 id="音乐music">音乐（music）</h5><blockquote><p>Thanks for your question! Chasing Dreams with a Young Heart’ is oneof my favorite songs because: From listening to ‘Chasing Dreams with aYoung Heart’, I can always benefit a lot, such as acquiring moremotivation, becoming a more positive person and improving my socialresponsibility. All of these would be helpful to my future life andstudy</p></blockquote><h5 id="爱好hobby">爱好（hobby）</h5><blockquote><p>Thanks for your question! Playing badminton is one of my favoritehobbies, because: From playing badminton, I can always benefit a lot,such as relieving my pressure, enriching my life and relaxing myself.All of these would be helpful to my future life and study.</p></blockquote><h5 id="颜色color">颜色（color）</h5><blockquote><p>Thanks for your question! Blue is one of my favorite colors, because:From looking at the blue sky when I feel sad, I can always benefit alot, such as relieving my pressure, acquiring more motivation andrelaxing myself.</p></blockquote><h5 id="课程class">课程（class）</h5><blockquote><p>Thanks for your question! Java Programming is one of my favoriteclasses/courses because: From Java, I can always benefit a lot, such asbroadening my horizons, improving my competence and learning morethings. All of these would be helpful to my future life and study.</p></blockquote><h5 id="景点scenic-spots">景点（scenic spots）</h5><blockquote><p>Thanks for your question! ‘Xinglong Pagoda’ is one of my favoritescenic spots because: It is located in my hometown and was originallybuilt during the Tang Dynasty, possessing a long and profound history.From visiting the ‘Xinglong Pagoda’, I can always benefit a lot, such asbroadening my horizons, relieving my pressure and relaxing myself. Allof these would be helpful to my future life and study.</p></blockquote><h5 id="季节season">季节（season）</h5><blockquote><p>Thanks for your question! The spring is one of my favorite seasonsbecause: From traveling in Spring, I can always benefit a lot, such asbroadening my horizons, relieving my pressure and relaxing myself. Allof these would be helpful to my future life and study.</p></blockquote><h5 id="歌手singer">歌手（singer）</h5><blockquote><p>Thanks for your question! Deng Ziqi is one of my favorite singerbecause: From listening to her songs, I can always benefit a lot, suchas relieving my pressure and relaxing. Additionally, her melodies andlyrics often resonate with my emotions, providing comfort andinspiration. All of these would be helpful to my future life andstudy.</p></blockquote><h5 id="运动员athlete">运动员（athlete）</h5><blockquote><p>Thanks for your question! Lin Dan is one of my favorite athletebecause: From watching his matches, I can always benefit a lot, such asrelieving my pressure, relaxing myself and learning badminton skills.All of these would be helpful to my future life and study.</p></blockquote><h4 id="大学参加">大学参加？</h4><h5 id="实习intern-experienceinternship">实习（internexperience、internship）</h5><h5 id="活动activity">活动（activity）</h5><h5 id="社团club">社团（club）</h5><blockquote><p>Thanks for your question!</p><p>During my undergraduate studies, I took part in X X1=志愿活动volunteer activities for the our city library X2=竞赛 many competitionsabout my major, such as Lan qiao Cup, China Undergraduate MathematicalContest in Modeling X3=证书 many certificate examinations, such as CET4,CET6 and Software Examination X4=实习 an internship in a Internetcampany</p><p>From this experience, I benefit a lot, such as learning more things,making more excellent friends and improving my competence.</p><p>All of these would be helpful to my future life and study.</p></blockquote><h4 id="你为什么选择">你为什么选择 ？</h4><p>模板</p><blockquote><p>Thanks for your question! 感谢您的问题！</p><p>I decided to <code>xxx</code>, because:我选择<code>xxx</code>，因为：</p><p>From 考研/学校/换专业/城市/毕业论⽂/本科/读研计划, I can benefit alot, such as A, B and C.</p><p>All of these would be helpful to my future life and study.</p></blockquote><h5 id="考研pursue-a-master-degree">考研（pursue a master degree）</h5><blockquote><p>Thanks for your question! I decided to continue my study, because:From pursuing a master degree, I can benefit a lot, such as acquiring ahigher platform, making more excellent friends, learning more things andbroadening my horizons. All of these would be helpful to my future lifeand study.</p></blockquote><h5 id="我们学校our-university">我们学校（our university）</h5><blockquote><p>Thanks for your question! I decided to choose your university,because: From pursuing a master degree in your university, I can benefita lot, such as studying in a great academic atmosphere, living in abeautiful campus and enjoying the great teaching faculty. All of thesewould be helpful to my future life and study.</p></blockquote><h5 id="读研计划postgraduate-study">读研计划（postgraduate study）</h5><blockquote><p>Thanks for your question! I decide to focus on my study in the nextseveral years, because: From doing this, I can benefit a lot, such aslearning more things, broadening my horizons, improving my competence.All of these would be helpful to my future life and study.</p></blockquote><h4 id="介绍一下你的">介绍一下你的？</h4><p>模板</p><blockquote><p>Thanks for your question!</p><p>I come from <code>xxx</code>.</p><p>From <code>xxx</code>, I/people can benefit a lot, such as A, B andC.</p><p>All of these would be helpful to my future life and study.</p></blockquote><h5 id="家庭family">家庭（family）</h5><blockquote><p>Thanks for your question! I come from a family with unconditionallove and respect. From talking with my parents, I can always benefit alot, such as acquiring more motivation, learning more things andrelieving my pressure. All of these would be helpful to my future lifeand study.</p></blockquote><h5 id="本科学校undergraduate-school">本科学校（undergraduateschool）</h5><blockquote><p>Thanks for your question! I come from Linyi University, a verybeautiful school. It is called the largest single university in Asia.From studying in my university, I benefit a lot, such as learning morethings, making more excellent friends and improving my competence. Allof these would be helpful to my future life and study</p></blockquote><h5 id="家乡hometown">家乡（hometown）</h5><blockquote><p>Thanks for your question! I come from Jining, Shandong province: ithas a lot of scenic spots, such as the birthplace of Confucius(Confucius Mansion, Confucius Temple, Confucius forest) , and TaibaiTower, where Li Bai once drank wine and wrote poems. From visiting myhometown, people can benefit a lot, such as relieving their pressure,acquiring unique experience and broadening their horizons.</p></blockquote><h4 id="评价人">评价人？</h4><p>模板</p><blockquote><p>Thanks for your question!</p><p>你是个什么样的人/你最突出的优点</p><p>In my view, I am a girl/boy who is willing to A, B and C.</p><p>你的缺点是什么</p><p>In my view, I am a girl/boy who is not good at A, B and C</p><p>研究⽣具备什么能⼒</p><p>In my view, a qualified postgraduate should be a girl/boy who is ableto A, B and C.</p><p>合格的导师是什么样的</p><p>In my view, a qualified supervisor should be a teacher who is able toA, B and C.</p></blockquote><h5 id="你是个什么样的人">你是个什么样的人</h5><p>In my view, I am a girl/boy who is willing to explore new things,make great efforts for my goals and adapt to the new environmentquickly.</p><h5 id="你最突出的优点">你最突出的优点</h5><p>In my view, I am a girl/boy who is willing to explore new things,make great efforts for my goals and adapt to the new environmentquickly.</p><h5 id="你的缺点是什么">你的缺点是什么</h5><p>In my view, I am a girl/boy who is not good at making newfriends,</p><p>explore new things and adapt to the new environment.</p><h5 id="研究生具备什么能力">研究生具备什么能力</h5><p>In my view, a qualified postgraduate should be a girl/boy who is ableto explore new things, make great efforts for my goals and searchliterature quickly and accurately.</p><h5 id="合格的导师是什么样的">合格的导师是什么样的</h5><p>In my view, a qualified supervisor should be a teacher who is able toexplore new things and maintain his continuous passion for study.</p><h2 id="专业能力面试">专业能力（面试）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">数据结构</span><br><span class="line">1.什么是数据结构？</span><br><span class="line">2.O是什么意思：</span><br><span class="line">3.循环和递归的区别：</span><br><span class="line">4.顺序表和链表的区别</span><br><span class="line">5.头指针和头结点的区别：</span><br><span class="line">6.栈和队列的区别：</span><br><span class="line">7.请简要说明一下共享栈：</span><br><span class="line">8.简述一下循环队列：</span><br><span class="line">9.几种表达式的算法思想：</span><br><span class="line">10.简述KMP算法：</span><br><span class="line">11.树的几种存储方式：</span><br><span class="line">12.简述广度优先遍历和深度优先遍历：</span><br><span class="line">13.区别邻接矩阵法和邻接表法：</span><br><span class="line">14.区别十字链表法和邻接多重表：</span><br><span class="line">15.最小生成树的算法</span><br><span class="line">16.简述dijkstra算法：</span><br><span class="line">17.区别b树和b+树：</span><br><span class="line">18.哈希冲突的解决方法：</span><br><span class="line">19.各种排序方法：</span><br><span class="line">20.队列应用：</span><br><span class="line"></span><br><span class="line">计算机网络</span><br><span class="line">1.计算机网络的功能：</span><br><span class="line">2.计算机网络的分类：</span><br><span class="line">3.主机间的通信方式：</span><br><span class="line">4.电报交换、报文交换、分组交换的区别：</span><br><span class="line">5.计算机网络的性能指标：</span><br><span class="line">6.OSI模型和TCP/IP模型：</span><br><span class="line">7.通信信通的方式：</span><br><span class="line">8.端到端的通信与点到点通信的区别：</span><br><span class="line">9.同步通信和异步通信：</span><br><span class="line">10.频分复用、时分复用、波分复用和码分复用</span><br><span class="line">11.数据链路层主要功能：</span><br><span class="line">12.为什么进行流量控制以及常见方式：</span><br><span class="line">13.如何保证可靠传输？</span><br><span class="line">14.随机访问介质控制：</span><br><span class="line">15.中继器、集线器、网桥、交换机、路由器的 区别</span><br><span class="line">16.网络协议的三要素：</span><br><span class="line">17.动态路由算法（内部网关协议）：</span><br><span class="line">18.区别IP地址和MAC地址：</span><br><span class="line">19.ARP地址解析协议</span><br><span class="line">20.DHCP协议（动态主机配置协议）</span><br><span class="line">21.传输层功能</span><br><span class="line">22.三次握手和四次握手：</span><br><span class="line">23.拥塞控制与流量控制的区别：</span><br><span class="line">24.DNS域名解析</span><br><span class="line">25.FTP文件传输</span><br><span class="line">26.SMTP</span><br><span class="line">27.HTTP协议</span><br><span class="line">28.物理层接口的四大特性</span><br><span class="line"></span><br><span class="line">数据库</span><br><span class="line">1.事务的特性：</span><br><span class="line">2.并发操作带来的数据不一致：</span><br><span class="line">3.什么是封锁，有哪些封锁？</span><br><span class="line">4.区别几种范式：</span><br><span class="line">5.数据、数据库、数据库管理系统、数据库系统</span><br><span class="line">6.关系、关系模式和关系数据库的区别：</span><br><span class="line">7.关系数据库的特点：</span><br><span class="line">8.数据模型包括什么：</span><br><span class="line">9.逻辑独立性、物理独立性：</span><br><span class="line">10.人工管理阶段和数据库系统和文件系统的区别：</span><br><span class="line">11.等值连接和自然连接的区别与联系：</span><br><span class="line">12.视图优点：</span><br><span class="line">13.哪些视图不能更新：</span><br><span class="line">14.SQL语句：</span><br><span class="line">15.关系的基本操作：</span><br><span class="line">16.什么是数据库的安全性18.触发器</span><br><span class="line">17.数据库的完整性</span><br><span class="line">18.触发器</span><br><span class="line">19.封锁协议：</span><br><span class="line">20.数据库设计过程</span><br><span class="line">21.数据库的几种故障</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">计算机组成原理</span><br><span class="line">1.冯诺依曼机的特点：</span><br><span class="line">2.计算机的工作过程（存储程序思想）：</span><br><span class="line">3.高级语言、汇编语言和机器语言</span><br><span class="line">4.区别编译和解释</span><br><span class="line">5.机器字长、指令字长和存储字长：</span><br><span class="line">6.为什么用二进制编码</span><br><span class="line">7.计算机常见的存储结构层次结构：</span><br><span class="line">8.半导体随机存储器：</span><br><span class="line">9.DROM的刷新方式：</span><br><span class="line">10.页面的替换算法：</span><br><span class="line">11.Cache与主存的映射方式：</span><br><span class="line">12.cache的“写策略”：</span><br><span class="line">13.虚拟存储器（解决内存不足的问题）：</span><br><span class="line">14.RISC（精简指令集）和CISC（复杂指令集）区别：</span><br><span class="line">15.数据寻址方式：</span><br><span class="line">16.指令的执行过程（指令周期）</span><br><span class="line">17.指令周期、机器周期、时钟周期：</span><br><span class="line">18.指令流水线</span><br><span class="line">19.影响流水线的因素：</span><br><span class="line">20.CPU的组成</span><br><span class="line">21.CPU的功能：</span><br><span class="line">22.引入总线的好处：</span><br><span class="line">23.总线的仲裁方式：</span><br><span class="line">24.总线分类</span><br><span class="line">25.总线基本特征：</span><br><span class="line">26.I/O设备的编址方式：</span><br><span class="line">27.IO方式：</span><br><span class="line">28.中断响应优先级和中断处理优先级：</span><br><span class="line">29.区别中断向量、向量中断和向量地址：</span><br><span class="line">30.中断方式和DMA方式的区别：</span><br><span class="line">31.计算机的主要性能指标：</span><br><span class="line">32.什么是波特率？什么是比特率？</span><br><span class="line">33.什么是存储单元、存储字、存储字长、存储体？</span><br><span class="line">34.IEEE754标准规定的浮点数由哪几部分组成？</span><br><span class="line">35.什么是存取时间？什么是存取周期？哪个大？</span><br><span class="line"></span><br><span class="line">操作系统</span><br><span class="line">1. 什么是操作系统？</span><br><span class="line">2. 操作系统的主要功能？</span><br><span class="line">3. 操作系统的两种状态？</span><br><span class="line">4. 区别中断和异常？</span><br><span class="line">5. 什么是系统调用？</span><br><span class="line">6. 什么是临界区？解决临界区问题需要什么条件？</span><br><span class="line">7. 程序、进程和线程？</span><br><span class="line">8. 进程的状态？</span><br><span class="line">9. 进程调度算法？</span><br><span class="line">10. 同步的四个准则？</span><br><span class="line">11. 死锁产生的必要条件？</span><br><span class="line">12. 地址翻译过程？</span><br></pre></td></tr></table></figure><h3 id="数据结构">数据结构</h3><ol type="1"><li><p>什么是数据结构？</p><p>数据结构是具有某些关系的数据元素的集合。</p><p>数据元素三要素：逻辑结构、物理结构、运算</p><p>逻辑结构：线性结构、非线性结构（树、图）</p><p>物理结构：顺序结构、链式结构、索引结构</p></li><li><p>O是什么意思？</p><p>它是算法的一个量级，在时间复杂度中表示所有语句的频次，在空间复杂度中表示辅助空间大小</p></li><li><p>循环和递归的区别？</p><p>循环：速度快，结构简单，但不适用于解决所有问题</p><p>递归：代码简单，但效率低，可能导致堆栈溢出</p></li><li><p>顺序表和链表的区别？</p><p>顺序表：支持随机存取，因此查询操作时间复杂度为O(1)，增删操作时间复杂度为O(n)，物理地址空间连续。</p><p>链表：不支持随机存取，只支持顺序存取，因此查询操作时间复杂度为O(n)，增删操作时间复杂度为O(1)，物理地址空间不一定连续。</p></li><li><p>头指针和头结点的区别？</p><p>头指针指向头结点，头结点是第一个元素前的节点，通常不存储实际数据，仅用于简化链表操作，首元结点才是第一个数据节点。</p></li><li><p>栈和队列的区别？</p><p>栈是先进后出，只能在栈顶进行插入和删除操作，主要应用于函数调用、递归、括号匹配</p><p>队列是先进先出，在队尾进行插入，在队头进行删除，主要应用于广度优先搜索、消息队列、任务调度，还可以用于树的层次遍历</p></li><li><p>简单说明共享栈？</p><p>共享栈就是让两个顺序栈存储在一个一维数组中，两个栈的栈底分别位于共享栈的两端，插入数据时向共享栈的中间进行延伸，当top[0]+1=top[1]时，栈满</p></li><li><p>简单说明循环队列？</p><p>循环队列就是用一个定长的数组作为队列，当队列为空时，<code>Q.rear=Q.front</code>，当队列满时，<code>(Q.rear+1)%maxsize=Q.front</code></p></li><li><p>几种表达式的算法思想？</p><p>前缀表达式：从右向左扫描表达式。遇到操作数，直接压入栈中；遇到运算符，弹出栈顶的两个操作数，进行运算，然后将结果压入栈中。扫描结束后，栈中剩余的即为表达式的值。</p><p>后缀表达式：从左到右扫描表达式。遇到操作数，直接输出；遇到运算符，弹出栈中优先级较高的运算符，直到栈顶运算符优先级较低或栈为空，然后将当前运算符压入栈中。扫描结束后，将栈中剩余运算符依次输出。</p><p>中缀转后缀：</p><ul><li>使用栈来临时存放运算符。</li><li>遇到左括号，压入栈中。</li><li>遇到右括号，弹出栈中运算符直到遇到左括号。</li><li>遇到运算符，比较当前运算符与栈顶运算符的优先级，优先级高的运算符先弹出。</li><li>所有字符处理完毕后，将栈中剩余运算符依次弹出。</li></ul></li><li><p>简述KMP算法？</p><p>KMP算法是对朴素算法的一种改进</p><p><strong>预处理阶段</strong>：构建前缀函数数组（next数组），记录模式字符串中每个位置的最长前后缀。O(m)</p><p><strong>匹配阶段</strong>：利用前缀函数数组，在遇到不匹配时跳转到前缀函数记录的位置，继续比较，避免从头开始。O(n)</p></li><li><p>树的几种存储方式？</p><p>双亲表示法：用一组连续的空间进行存储，有data和parent两个数据域，parent存放的是双亲在数组中的位置。</p><p>孩子表示法：将结点的每一个孩子用一个单链接连接起来。</p><p>孩子兄弟表示法：采用了二叉树的存储方法，左孩子右兄弟，可以实现树转化为二叉树的操作</p></li><li><p>简述广度优先搜索和深度优先搜索？</p><p>广度优先遍历：类似树的层次遍历，将v进入队列，访问顶点v并出队，让他的左右孩子进入队列，将队列中元素依次出队并在每次出队时让其左右孩子入队，直到队列为空，完成遍历。</p><p>深度优先遍历：类似于树的先序遍历，先访问结点v，然后访问v相邻并且没有被访问的顶点，依次访问刚刚被访问的相邻的并且没有被访问过得顶点</p></li><li><p>区别邻接矩阵和邻接表？</p><p>邻接矩阵适用于稠密图中，用一个二维数组表示各个结点间是否有关系，空间复杂度为O（v²）</p><p>邻接表适用于稀疏图中，对每个结点建立一个单链表，存放依附于该结点的边，但是寻找入度比较困难，时间复杂度为有向图O（v+e）、无向图：O(v+2e)</p><table><colgroup><col style="width: 24%" /><col style="width: 35%" /><col style="width: 40%" /></colgroup><thead><tr><th style="text-align: left;"><strong>特性</strong></th><th style="text-align: left;"><strong>邻接矩阵</strong></th><th style="text-align: left;"><strong>邻接表</strong></th></tr></thead><tbody><tr><td style="text-align: left;"><strong>存储结构</strong></td><td style="text-align: left;">二维数组</td><td style="text-align: left;">链表数组</td></tr><tr><td style="text-align: left;"><strong>空间效率</strong></td><td style="text-align: left;">浪费空间（稀疏图）</td><td style="text-align: left;">节省空间（稀疏图）</td></tr><tr><td style="text-align: left;"><strong>查边速度</strong></td><td style="text-align: left;">O(1)</td><td style="text-align: left;">O(k)（k为邻接顶点数）</td></tr><tr><td style="text-align: left;"><strong>遍历邻接点速度</strong></td><td style="text-align: left;">O(V)</td><td style="text-align: left;">O(k)</td></tr><tr><td style="text-align: left;"><strong>适用场景</strong></td><td style="text-align: left;">稠密图、频繁查边、矩阵运算</td><td style="text-align: left;">稀疏图、频繁遍历邻接点、动态图</td></tr></tbody></table></li><li><p>区别十字链表和邻接多重表？</p><p>两个都是适用于稀疏表的存储。</p><p>邻接多重表用于无向图中，分为边表结点和顶点结点，每个顶点结点有2部分组成：data，与该顶点相连的第一条表；边结点包括边的两个顶点i，j，权值info，依附于顶点i的下一条边，依附于顶点j的下一条边；</p><p>十字链表表用于有向图，分为边表结点和顶点结点，顶点结点有3部分组成：data，以该顶点为弧头的第一条弧，以该顶点为弧尾的第一条弧；弧结点：权值info，弧头顶点，弧尾顶点，弧头相同的下一条弧，弧尾相同的下一条弧。</p><table><thead><tr><th style="text-align: left;"><strong>特性</strong></th><th style="text-align: left;"><strong>十字链表</strong></th><th style="text-align: left;"><strong>邻接多重表</strong></th></tr></thead><tbody><tr><td style="text-align: left;"><strong>适用图类型</strong></td><td style="text-align: left;">有向图</td><td style="text-align: left;">无向图</td></tr><tr><td style="text-align: left;"><strong>边存储次数</strong></td><td style="text-align: left;">每条边存储一次</td><td style="text-align: left;">每条边存储一次</td></tr><tr><td style="text-align: left;"><strong>查询优化方向</strong></td><td style="text-align: left;">同时支持出边和入边查询</td><td style="text-align: left;">消除边的冗余存储</td></tr><tr><td style="text-align: left;"><strong>边结点复杂度</strong></td><td style="text-align: left;">较高（维护两个链）</td><td style="text-align: left;">较低（维护两个链指针）</td></tr></tbody></table></li><li><p>最小生成树的算法？</p><p><strong>Prim算法：</strong></p><ul><li><strong>核心思想</strong>：贪心策略，从顶点出发逐步扩展，选择当前最小边。</li><li><strong>步骤</strong><ol type="1"><li>随机选择一个顶点作为起点，加入已选集合。</li><li>将连接已选集合和未选集合的边加入最小堆（优先队列）。</li><li>取出堆顶最小边，将新顶点加入已选集合，记录该边。</li><li>重复直到所有顶点被选中。</li></ol></li><li><strong>时间复杂度</strong><ul><li>邻接矩阵+普通队列：O(V²)（适合稠密图）。</li><li>邻接表+二叉堆优化：O(ElogV)。</li></ul></li><li><strong>适用场景</strong>：稠密图（顶点较少或边数较多时更优）。</li></ul><p><strong>Kruskal算法：</strong></p><ul><li><strong>核心思想</strong>：贪心策略，按边权重从小到大选择边，避免形成环。</li><li><strong>步骤</strong><ol type="1"><li>将所有边按权重升序排序。</li><li>初始化并查集，每个顶点独立成集合。</li><li>遍历排序后的边，若边的两个顶点属于不同集合，则选择该边并合并集合。</li><li>重复直到选出 V-1条边（V为顶点数）。</li></ol></li><li><strong>时间复杂度</strong>：O(ElogE)，主要由排序决定。</li><li><strong>适用场景</strong>：稀疏图（边数较少时更高效）。</li></ul></li><li><p>简述迪杰斯特拉算法？</p><ol type="1"><li><strong>初始化</strong>：所有节点距离设为无穷大，起点距离为0。</li><li><strong>优先队列</strong>：将所有节点加入优先队列。</li><li><strong>处理节点</strong>：循环取出队列中距离最小的节点。</li><li><strong>更新距离</strong>：检查该节点的邻接节点，计算新路径距离，若更短则更新并加入队列。</li></ol><p>不适用于含负权边的图，此时需使用Floyd算法。</p></li><li><p>区别B树和B+树？</p></li><li><p>哈希冲突的解决方法？</p><p>开放寻址法：冲突发生时，按照某种规则寻找下一个空闲位置。</p><ul><li><strong>常见策略</strong>：<ol type="1"><li><strong>线性探测（Linear Probing）</strong><ul><li>冲突后依次检查下一个位置（如<code>hash(key) + 1, +2, ...</code>）。</li><li><strong>缺点</strong>：容易导致“聚集”（连续占用的位置形成区块），降低查询效率。</li></ul></li><li><strong>平方探测（Quadratic Probing）</strong><ul><li>冲突后按平方步长跳跃检查（如<code>hash(key) + 1², +2², ...</code>）。</li><li><strong>优点</strong>：缓解聚集问题，但可能无法遍历所有槽位。</li></ul></li><li><strong>双重哈希（Double Hashing）</strong><ul><li>使用第二个哈希函数计算步长（如<code>hash2(key)</code>），冲突后按步长跳跃。</li><li><strong>优点</strong>：分散更均匀，需设计良好的第二个哈希函数。</li></ul></li></ol></li></ul><p>链地址法：每个哈希桶（bucket）维护一个链表（或其他结构），冲突元素直接添加到同一位置的链表中。</p><ul><li><p>适合频繁插入删除的场景（如数据库索引）。</p></li><li><p><strong>缺点</strong>：链表过长时查询效率下降（可优化为红黑树，如Java 8+ 的 <code>HashMap</code>）。</p></li></ul><hr /><p>再哈希法：冲突时使用另一个哈希函数重新计算位置，直到找到空槽。</p><ul><li><strong>优点</strong>：减少聚集问题。</li><li><strong>缺点</strong>：需预定义多个哈希函数，计算开销较大。</li></ul></li><li><p>各种排序方法？</p><p>（1）直接插入排序：序列分为有序部分和无序部分，依次将无序部分的数插入到有序部分合适的位置</p><p>（2）折半插入排序：设置三个指针，low，high，mid，low指向第一个元素，high指向最后一个元素，mid指向其中间位置，待排序元素与mid比较，</p><p>（3）希尔排序：设置一个步伐d，将序列分成若干子序列，进行直接插入排序；每次缩小步伐，直到序列基本有序时，进行直接插入排序</p><p>（4）简单选择排序：分为有序部分和无序部分，在无序部分选出最小（大）的元素，将元素与无序部分第一个元素交换位置，重复执行。每次可以确定一个元素的位置。</p><p>（5）堆排序：有大根堆和小根堆两种，大根堆为例：根大于左孩子，大于右孩子。适用于大文件中</p><p>（6）冒泡排序：每一趟将元素进行两两比较，将小的元素交换到前面，实现递增排序，每次可以确定一个元素的位置</p><p>（7）快速排序：选取一个中轴元素p，还需要用到两个指针，记为low和high，从high进行比较，如出现high&lt;p的情况，则将high的元素放到low上，low指针开始移动，直到遇到low&gt;p的情况，将low中元素放到high的位置，high再次进行上述操作，最后直到low&gt;high时，将p放到low的位置。每一趟可以确定一个元素的位置</p><p>（8）归并排序：把两个或者两个以上的有序表合并成一个新的有序表</p></li><li><p>内部排序与外部排序？</p><table><colgroup><col style="width: 15%" /><col style="width: 45%" /><col style="width: 39%" /></colgroup><thead><tr><th style="text-align: left;"><strong>特性</strong></th><th style="text-align: left;"><strong>内部排序</strong></th><th style="text-align: left;"><strong>外部排序</strong></th></tr></thead><tbody><tr><td style="text-align: left;"><strong>数据规模</strong></td><td style="text-align: left;">数据量小，可全部加载到内存</td><td style="text-align: left;">数据量极大，无法一次性装入内存</td></tr><tr><td style="text-align: left;"><strong>存储依赖</strong></td><td style="text-align: left;">仅依赖内存操作</td><td style="text-align: left;">依赖内存 + 磁盘/外部存储（分块读写）</td></tr><tr><td style="text-align: left;"><strong>时间复杂度</strong></td><td style="text-align: left;">关注比较和交换次数（如O(n²)、O(n logn)）</td><td style="text-align: left;">关注磁盘I/O次数（主要性能瓶颈）</td></tr><tr><td style="text-align: left;"><strong>适用场景</strong></td><td style="text-align: left;">内存中的数组、链表等</td><td style="text-align: left;">数据库大表、日志文件等海量数据排序</td></tr></tbody></table></li><li><p>拓扑排序？</p><ol type="1"><li>选择一个没有被访问过的节点，进行深度优先搜索（DFS）。</li><li>在DFS过程中，记录节点的访问状态（未访问、正在访问、已访问）。</li><li>当一个节点的所有后继节点都被访问完毕后，将其添加到拓扑排序结果的最前面。</li><li>重复步骤1至3，直到所有节点都被访问。</li></ol></li></ol><h3 id="算法">算法</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr><th>问题</th></tr></thead><tbody><tr><td>中序遍历递归与非递归算法</td></tr><tr><td>括号匹配算法</td></tr><tr><td>图的出入度算法</td></tr><tr><td>图的遍历</td></tr><tr><td>计算有向图的入度出度</td></tr><tr><td>构建二叉树</td></tr><tr><td>非递归中序遍历二叉树</td></tr><tr><td>二叉树先序遍历</td></tr><tr><td>二叉树的前序遍历</td></tr><tr><td>已知是几月几号，问是今年的第几天</td></tr><tr><td>有序链表排序</td></tr><tr><td>无头结点的链表的插入</td></tr><tr><td>尾插法</td></tr><tr><td>双向链表插入</td></tr><tr><td>判断链表升序还是降序</td></tr><tr><td>两个有序链表合并成一个有序链表</td></tr><tr><td>单链表删除一个节点</td></tr><tr><td>单链表逆序</td></tr><tr><td>带头结点的单链表插入</td></tr><tr><td>在一组数中找出素数并求和</td></tr><tr><td>在数组里找一个指定的数，返回它的位置</td></tr><tr><td>用递归把一个数的每一位输出</td></tr><tr><td>一张100元人民币换成1元,2元,5元,10元的纸币，每种纸币至少一张，问有几种换法</td></tr><tr><td>一串数字一个一个输出</td></tr><tr><td>统计字符串里大写数字小写个数</td></tr><tr><td>孙子定理</td></tr><tr><td>水仙花数</td></tr><tr><td>输入一个二维矩阵求每列的和并输出</td></tr><tr><td>闰年判断</td></tr><tr><td>如何判断是否是回文？<br />定义两个整型变量i和j分别指向数组头和尾，比较数组内的字符是否相等，若相等i++j–继续遍历，若i大于等于j 说明是回文</td></tr><tr><td>求一个矩阵里的所有奇数和</td></tr><tr><td>求一个矩阵当中所有偶数的和</td></tr><tr><td>计算<code>1!×2!×3!×...×100!</code>，这串东西后有多少零</td></tr><tr><td>给定一个整数n，求1到n之间的所有素数</td></tr><tr><td>给定一个n，输出从1到n的所有质数</td></tr><tr><td>递归算法 1+2+……+50</td></tr><tr><td>大数乘法https://blog.csdn.net/u010983881/article/details/77503519</td></tr><tr><td>查找第二大的数</td></tr><tr><td>编程：歌唱大赛，十个专家打分，去掉一个最高分，去掉一个最低分，输出剩余专家打分的平均分</td></tr><tr><td>把二维数组的每行数相加</td></tr><tr><td>3的33次方，说算法，不用说结果</td></tr><tr><td>3的33次方</td></tr><tr><td>13的13次幂取后三位（个十百）</td></tr></tbody></table><h3 id="计算机网络">计算机网络</h3><ol type="1"><li><p>计算机网络的功能？</p><p>（1）资源共享：包括硬件、软件和数据</p><p>（2）提高可靠性</p><p>（3）信息通信</p><p>（4）分布式处理</p></li><li><p>计算机网络的分类？</p><p>（1）按拓扑结构分类：总线型、星型、环形</p><p>（2）按分布范围分类：广域网、城域网、局域网、个人区域网</p></li><li><p>主机间的通信方式？</p><p>（1）c/s方式：客户是请求方，服务器是服务提供方</p><p>（2）p2p方式：点对点的方式</p></li><li><p>电路交换、报文交换、分组交换的区别？</p><p>电路交换：传输单位是比特流，像建立一条物理通道。包括建立连接、传输数据和断开连接三部分组成</p><p>报文交换：传输单位是报文，将报文发给相邻结点，查找转发表，转发给下一个结点。是一种存储-转发类型的网络</p><p>分组交换：传输单位是报文段，将报文分组转发到相邻结点，查找转发表，转发给下一个结点。是一种存储-转发类型的网络</p></li><li><p>计算机网络的性能指标？</p><p>（1）带宽：网络通信线路所能传送数据的能力，单位是bit/s</p><p>（2）时延：总时延=发送时延+处理时延+传播时延+排队时延</p><p>发送时延：结点将所有bit发往链路所需要的时间</p><p>传播时延：一个bit从从链路一端传输到另一端的时间</p><p>处理时延和排队时延一般忽略不计</p><p>（3）时延带宽积：传播时延×信道带宽</p></li><li><p>OSI模型和TCP/IP模型</p><p>OSI模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><p>TCP/IP模型：物理层（透明的传输比特流）、数据链路层（封装成帧、透明传输、差错检测）、网络层（路由选择、分组转发）、传输层（进程通信、可靠和不可靠的两种协议、差错检测、分用和复用）、应用层</p><p>两者都采用分层结构，都能实现网络异构</p><p>OSI模型的网络层支持无连接和面向连接两种通信，传输层只提供面向连接的通信服务；TCP模型网络层只提供无连接的服务，运输层提供无连接和面向连接的服务；</p></li><li><p>通信信道的方式？</p><p>（1）单工：只能有一个方向的信道</p><p>（2）半双工：双向都能通信，但不能同时进行</p><p>（3）全双工：双方可以同时通信，即通信双方可以同时发送和接收信息</p></li><li><p>端到端的通信和点到点的通信？</p><p>点到点的通信是两个主机之间的通信，不涉及进程和程序，不能保证传输的可靠性；端到端的通信是建立在点到点的通信之上的，是运输层提供的，涉及两个进程之间的通信。</p></li><li><p>同步通信和异步通信？</p><p>同步通信是接受端和发送端的时钟在用一个频率进行通信，同步通信的数据率较高但是代价也比较高；异步通信发送端发送的字符间的时间间隔是任意的，并且可以在任意时刻发送数据，但是必须在开始和结束的地方加上开始位和结束位作为标记，接受端时刻再好接收数据的准备。异步通信的传输效率比较低，标志位开销大。</p></li><li><p>频分复用、时分复用、码分复用、波分复用？</p><p>（1）频分复用：给信号分配唯一的载波频率通过单一媒体传输多个独立的信号；</p><p>（2）时分复用：每个信号在一个很短时间内占用信道，接着让下一个信号使用</p><p>（3）波分复用：就是光的频分复用，用光纤传递频率接近的光载波信号</p><p>（4）码分复用：用一组包含正交的码携带多路信号，可以实现同一时间用相同频带进行通信；</p></li><li><p>数据链路层主要功能？</p><p>（1）封装成帧：在一端数据前后增加首部和尾部，进行帧定界</p><p>（2）透明传输：可以防止信息符号和帧定界符混淆</p><p>（3）差错控制：通常采用循环冗余码、奇偶校验码进行检错，海明码用于纠错</p></li><li><p>为什么进行流量控制？主要方式有哪些？</p><p>可能出现发送方发送数据能力大于接收方接收数据能力，导致后者来不及接收所有数据而造成数据丢失，所以要进行流量控制，限制发送方的数据流量，使其发送速率不超过接收方的能力。</p><p>（1）停止等待协议：发送窗口=接收窗口=1，发送方每发送一帧等到接收方应答后才能发送下一帧</p><p>（2）后退n帧协议：发送窗口&gt;1，接收窗口=1，发送方可以连续发送帧，当接收方发现失序时，发送给发送方最后一个接收到的数据，发送方需要发送这个数据之后的所有数据</p><p>（3）选择重传协议：发送窗口&gt;1,接收窗口&gt;1,在发生失帧时，只需要重传出现差错的数据帧。</p></li><li><p>如何保证可靠传输？</p><p>通过确认和超时重传两种机制。确认是一种无数据的数据帧，一般采用捎带确认的方式，将确认捎带在一个回复中；超时重传是发送方在发送时开始计时，一定时间内没有收到确认帧会重新发送该数据。</p></li><li><p>随机访问介质控制？</p><p>（1）Aloha协议：只要用户有数据就会发送</p><p>（2）CSMA协议（载波监听多路访问）：在发送前，先监听信道，</p><p>1坚持：空闲则发送；信道忙，持续监听直到空闲发送</p><p>p坚持：空闲以概率p发送数据，信道忙则以p概率延迟一个时间再来监听</p><p>（3）CSMA/CD协议（载波监听多路访问碰撞检测）：先听后发，边听边发，冲突停发，随机重发，适用于有线局域网中0</p><p>（4）CSMA/CA协议（载波监听多路访问碰撞避免）：适用于无线局域网，发送包的同时不能检测到信道上是否有冲突，只能尽量“避免”</p></li><li><p>中继器、集线器、网桥、交换机、路由器的区别？</p><p>中继器也称放大器，将数字信号加强，原理是信号再生，是一种工作在物理层的设备；集线器是多接口中继器；</p><p>网桥是工作在数据链路层的机器，他可以隔离冲突域，不能隔离广播域；交换机是多接口网桥；</p><p>路由器是工作在网络层的设备，隔离了广播域和冲突域、可以进行路由选择（根据网络的变化，动态选择路由）和分组转发（根据转发表将用户IP数据从合适的端口转发出去）；</p></li><li><p>网络协议三要素？</p><p>语法：规定了传输数据的格式</p><p>语义：规定了所要完成的功能</p><p>时序：规定了各种操作的执行顺序</p></li><li><p>动态路由算法？</p><p>（1）RIP距离-向量路由算法：所有结点定期将他们的整个路由表传发给直接相邻的节点，若该路由在原来的路由中不存在，则加入这条新的路由到路由表中；若存在，则比较是否激励更短，若更短或者相等则进行更新；跳数是决定最佳路径的唯一指标；适用于小型网络；它只与自己相邻的路由器交换信息；</p><p>（2）OSPF链路状态路由算法：OSPF仅在网络拓扑发生变化时才交换路由信息。它其中的每个路由器都与其他所有路由器交换信息适用于大型网络；</p></li><li><p>区别IP地址和MAC地址？</p><p>MAC地址是数据链路层的地址，IP地址是网络层的地址，mac地址位于IP地址的首部</p></li><li><p>ARP地址解析协议？</p><p>完成IP地址到mac地址的映射。ARP工作在网络层，ARP请求分组是广播发送的，ARP响应分组是单播</p></li><li><p>DHCP协议？</p><p>用于给主机动态分配IP地址，提供了即插即用的机制，是位于应用层的协议；</p><ol type="1"><li><strong>发现阶段（DHCP Discover）</strong>：<ul><li>当设备（客户端）连接到网络时，它会发送一个<strong>DHCPDiscover</strong>广播消息，寻找可用的DHCP服务器。</li></ul></li><li><strong>提供阶段（DHCP Offer）</strong>：<ul><li>DHCP服务器收到Discover消息后，会从地址池中选择一个可用的IP地址，并通过<strong>DHCPOffer</strong>消息发送给客户端。</li></ul></li><li><strong>请求阶段（DHCP Request）</strong>：<ul><li>客户端收到Offer消息后，会发送一个<strong>DHCPRequest</strong>广播消息，确认接受该IP地址。</li></ul></li><li><strong>确认阶段（DHCP Acknowledge）</strong>：<ul><li>DHCP服务器收到Request消息后，会发送<strong>DHCPAcknowledge</strong>消息，确认IP地址的分配，并附带其他网络配置参数。</li></ul></li></ol></li><li><p>传输层功能？</p><p>（1）提供应用进程间的逻辑通信</p><p>（2）对收到的报文和数据进行差错检测</p><p>（3）提供面向连接和无连接的服务</p><p>（4）复用和分用；</p></li><li><p>三次握手和四次挥手？</p><p><strong>三次握手是建立连接</strong>：</p><p>1.客户机向服务器发送一个连接请求报文，SYN=1，seq=x；</p><p>2.服务器收到连接请求后接收并发送确认报文，SYN=1，ACK=1，ack=x+1；seq=y；</p><p>3.发送方收到确认报文ACK=1，seq=x+1，ack=y+1；</p><p><strong>四次握手是释放连接</strong>：</p><p>1.客户机向服务器发送一个释放报文FIN=1，seq=u；</p><p>2.服务器收到后发送一个确认报文，ACK=1，ack=u+1，seq=v；</p><p>3.服务器向客户机发送释放连接的请求，将服务器到客户机方向的连接释放。FIN=1，ACK=1，seq=w，ack=u+1；4.客户机收到释放连接的报文，发送确认，ACK=1，seq=u+1，ack=w+1</p></li><li><p>拥塞控制与流量控制的区别？</p><p>拥塞控制是一个让网络能够承受现有的网络负荷，是一个全局的过程，</p><p>流量控制是接受端控制发送端的速率，让接受端来得及接收</p><p><strong>拥塞控制算法</strong>（接收窗口rwnd，拥塞窗口cwnd）：</p><p>（1）慢开始算法：拥塞窗口从1开始指数增加</p><p>（2）拥塞避免：达到拥塞窗口门限值后，拥塞窗口不再指数增加，而是每次+1，并且出现一次网络拥塞时，慢开始门限值变为当前拥塞窗口的一半；</p><p>（3）快重传：当发送方连续收到三个重复的ack，直接重传对方尚未收到的报文段</p><p>（4）快恢复：收到三个连续的ack时，cwnd变为新的慢开始门限值，然后cwnd再加法增大；</p></li><li><p>DNS域名解析？</p><p>把域名与IP进行映射。</p><ul><li><strong>A记录</strong>：IPv4地址（如 <code>192.0.2.1</code>）。</li><li><strong>AAAA记录</strong>：IPv6地址（如<code>2001:db8::1</code>）。</li><li><strong>CNAME记录</strong>：域名别名（如将<code>www.example.com</code> 指向 <code>example.com</code>）。</li><li><strong>MX记录</strong>：邮件服务器地址（用于电子邮件路由）。</li><li><strong>TXT记录</strong>：文本信息（如验证域名所有权或SPF防垃圾邮件）。</li></ul></li><li><p>FTP文件传输？</p><p>在服务器与客户机之间进行文件传输</p></li><li><p>SMTP？</p><p>工作在应用层，主要用于将邮件从发送方的邮件服务器传送到接收方的邮件服务器，或从用户端（如邮箱客户端）发送到邮件服务器</p></li><li><p>HTTP？</p><p>超文本传输协议，基于TCP，用于从万维网服务器传输超文本到本地浏览器。</p></li><li><p>物理层接口的四大特性？</p><p>（1）机械特性：指明接口的尺寸、引脚数目等</p><p>（2）电气特性：指明电压的高低、电压范围</p><p>（3）功能特性：规定接口各信号线的功能</p><p>（4）规程特性：指明信号线的工作顺序和时序</p></li></ol><h3 id="数据库">数据库</h3><ol type="1"><li><p>事务的特性？</p><p>事务是用户定义的一个数据库操作序列，要么全做，要么全不做</p><p>事务具有ACID的特性：</p><ul><li>A：原子性，要么都做，要么都不做</li><li>C：一致性</li><li>I：隔离性</li><li>D：持续性：事务对数据的影响是持续的</li></ul></li><li><p>并发操作带来的数据不一致？</p><p>（1）丢失修改：T1和T2对同一数据进行修改，T2结果的提交破坏了T1提交的结果，导致T1的修改丢失</p><p>（2）不可重复读：T1读取数据后，T2对数据进行更新，T1无法再现前一次的读取结果</p><p>（3）读“脏”数据：T1修改数据后T2进行读取，但是T1又因为某种原因撤销修改，导致T2的数据域数据库中数据不一致</p></li><li><p>什么是封锁？有哪些封锁？</p><p>封锁就是在数据操作前对其加锁，只有释放锁后，其他事务才能对其操作</p><p>排它锁（X锁）：只有有X锁的事务可以进行读写；（不能加任和锁）</p><p>共享锁（S锁）：所有事务只能读，不能写（可以加S锁）</p></li><li><p>区别几种范式？</p><p>第一范式：每个属性不可分割，具有原子性</p><p>第二范式：非主属性完全依赖主属性</p><p>第三范式：非主属性对主属性不存在传递函数依赖</p><p>BC范式：在第三范式的基础上，消除主属性间的传递函数依赖</p></li><li><p>数据、数据库、数据库管理系统、数据库系统？</p><p>数据：是数据库存储的基本对象</p><p>数据库：长期存储在计算机中的有组织、可共享的数据集合</p><p>数据库管理系统：是用户与操作系统之间的一层数据管理软件（功能：数据定义、数据组织、存储和管理、数据操纵、数据库事务的管理和运行、数据库的建立和维护）</p><p>数据库系统：由数据库、数据库管理系统、数据库管理员、应用程序组成；</p></li><li><p>关系、关系模式和关系数据库的区别？</p><p>关系：一个关系对应着一个二维表，是关系模式在某一时刻的状态，关系是动态的</p><p>关系模式：二维表中的行定义，即对关系的描述，关系模式是静态的，稳定的</p><p>关系数据库是以关系模型为基础的数据库，利用关系来描述现实世界，一个关系既可以描述一个实体及其属性，也可以描述实体间的联系；</p></li><li><p>关系数据库的特点？</p><p>关系数据库就是依照关系模型建立的数据库</p><p>优点：</p><p>（1）关系数据库：在数学模型的基础上建立</p><p>（2）关系模型的概念单一，结构简单，容易理解</p><p>（3）存取路径对用户透明，安全性和独立性好，也简化了程序员的工作</p><p>缺点：由于路径透明，查询效率不如非关系数据库</p></li><li><p>数据模型包括什么？</p><p>（1）数据结构（描述数据库的组成对象以及他们之间的联系）</p><p>（2）数据操作</p><p>（3）数据的完整性约束（用户定义完整性、实体完整性、参照完整性）</p></li><li><p>逻辑独立性、物理独立性？</p><p>（1）逻辑独立性：模式改变、应用程序和外模式不改变</p><p>（2）物理独立性：数据存储结构改变，不会改变模式和应用程序</p><p>（3）数据独立性：不会因为数据的物理结构和逻辑结构的改变影响应用程序</p></li><li><p>人工管理阶段和数据库系统和文件管理系统的区别？</p><p>（1）人工管理阶段：数据不能保存，由应用程序管理数据</p><p>（2）文件阶段：数据库长期保存，由文件系统管理数据，数据共享性差、冗余度大、数据独立性差</p><p>（3）数据库阶段：由数据库管理系统管理数据，数据共享性好，冗余度底，独立性高</p></li><li><p>等值连接和自然连接的区别和联系？</p><p>自然连接是一种特殊的等值连接，要求连接属性必须是相同的属性组，并且自然连接会去掉重复的属性</p></li><li><p>视图优点？</p><p>（1）简化用户操作</p><p>（2）可以在多种角度看待同一数据</p><p>（3）可以对机密数据提供安全保护</p></li><li><p>哪些视图不能更新？</p><p>（1）有聚合函数或者表达式的</p><p>（2）出现distinct/unique的</p><p>（3）出现group by的语句</p><p>（4）不包含主键的</p></li><li><p>SQL语句？</p><p>数据库查询：select</p><p>数据库定义：create、drop、alter</p><p>数据库操纵：insert、update、delete</p><p>数据库控制：grant、revoke</p></li><li><p>关系的基本操作？</p><p>选择、投影、并、差、笛卡尔积</p></li><li><p>什么是数据库的安全性？</p><p>保护数据库防止不合法使用造成数据泄露、更改或破坏；</p></li><li><p>数据库的完整性？</p><p>数据的正确性和相容性；防止数据库中存在不合法语义的数据，防止错误信息的输入和输出；</p></li><li><p>触发器？</p><p>是一种特殊的存储过程，是由事件触发的，自动激活并执行</p></li><li><p>封锁协议？</p><p>（1）一级封锁协议：避免丢失修改</p><p>（2）二级封锁协议：避免丢失修改和读脏数据</p><p>（3）三级封锁协议：避免丢失修改、读脏数据和不可重复读</p><p>（4）两段锁协议：事务分为两个阶段，获得封锁和释放封锁；</p></li><li><p>数据库设计阶段？</p><p>（1）需求分析（数据流图）</p><p>（2）概要设计（E-R图）：解决结构冲突、属性冲突、命名冲突</p><p>（3）逻辑设计（数据模型）：解决冗余问题，插入、删除、更新问题</p><p>（4）物理设计：实现存取方式</p><p>（5）数据库实施</p><p>（6）数据库运行和维护</p></li><li><p>数据库的几种故障？</p><p>（1）事务故障：只影响事务，通过撤销或者重做恢复</p><p>（2）系统故障：由于断电、非正常关机引起；通过设置检查点（最近一次日志记录的地址）和运行日志恢复</p><p>（3）介质故障：硬件损坏引起的；通过设置存储点，副本恢复</p></li></ol><h3 id="计算机组成原理">计算机组成原理</h3><ol type="1"><li><p>冯诺依曼机的特点？</p><p>（1）计算机由运算器、存储器、控制器、输入设备和输出设备组成</p><p>（2）指令和数据都存储在存储器中，并可以按地址访问</p><p>（3）指令和数据都用二进制表示</p><p>（4）指令由操作码和地址码组成</p><p>早期的冯诺依曼机以运算器为中心，现代的以存储器为中心</p></li><li><p>计算机的工作过程？</p><p>（1）将程序和数据装入主存储器中</p><p>（2）将源程序转化为可执行程序</p><p>（3）从可执行文件的首地址开始执行指令</p></li><li><p>高级语言、汇编语言和机器语言？</p><p>高级语言：我们平时编写程序所使用的语言</p><p>汇编语言：符号语言，用指令助记符来编写程序</p><p>机器语言：二进制语言，用二进制代码表示，计算机可以直接识别</p></li><li><p>区别编译和解释？</p><p>编译和解释是翻译的两种方式；</p><p>编译需要一个专门的编译过程，会产生一个目标程序（C、C++、Java）</p><p>翻译是翻译一句执行依据，不产生目标程序，效率比较低（python、JavaScript）</p><p>编译过程：预处理—-编译—–汇编—-链接</p></li><li><p>机器字长、指令字长和存储字长？</p><p>机器字长：计算机可以直接处理二进制的位数，等于CPU内部寄存器的大小</p><p>指令字长：一个指令包含的二进制的位数，一般为存储字长的整数倍</p><p>存储字长：一个存储单元存储的二进制代码的长度，等于MDR的位数</p></li><li><p>为什么用二进制编码？</p><p>（1）二进制只有0,1两种状态，很多电子元件都可以表示这两种状态</p><p>（2）二进制的运算简单，有利于简化计算机的硬件结构</p><p>（3）0,1可以表示逻辑代数的假和真</p></li><li><p>计算机常见的存储层次结构？</p><p>（1）cache-主存：解决CPU与主存速度不匹配问题，由硬件完成，对程序员透明</p><p>（2）主存-辅存：解决主存容量不够的问题，由操作系统和硬件共同完成，对应用程序设计者透明，对系统程序设计者不透明</p></li><li><p>半导体随机存储器？</p><p>（1）静态随机存储器SRAM：存储单元是双稳态触发器，速度快，集成度低，价格贵，一般用作高速缓冲存储器，是一种易失型存储器；</p><p>（2）动态随机存储器DRAM：存储单元是晶体管，集成度高，价格低，但是每隔一段时间需要进行刷新，适用于大容量的主存，是一种易失型存储器；</p><p>（3）只读存储器ROM：支持随机存取的存储器，结构简单，位密度比大，具有非易失性，可靠性高；</p></li><li><p>DRAM的刷新方式？</p><p>（1）集中刷新：一个固定时间对存储器所有行进行刷新</p><p>（2）分散刷新：对每一行的刷新分散到各个工作周期</p><p>（3）异步刷新：对每行的刷新分散到整个刷新周期</p></li><li><p>Cache页面置换算法？</p><p>（1）最佳置换算法：淘汰将来一段时间不会使用的页面（但是一般无法预知未来情况）</p><p>（2）先进先出：选择最早调入的进行替换</p><p>（3）最近最少使用（LRU）：选择最近长久未访问过得存储行作为替换的行</p><p>（4）时钟算法：使用环形链表将页面连接，使用一个指针指向最老的页面，标记1则进行替换，遇到0就将0变为1；依次进行循环</p></li><li><p>Cache与主存的映射方式？</p><p>（1）直接映射：主存只能存入cache中的唯一位置</p><p>（2）全相联映射：主存的数据块可以存入cache的任意位置</p><p>（3）组相联映射：cache分成若干组，各组之间采用直接映射，而组内各块之间采用全相连映射。</p></li><li><p>Cache的写策略？</p><p>（1）写回法+写分配策略：cache命中时，只修改cache内容，不直接写入主存；cache未命中时，加载主存到cache中，在cache中更新，最后同步到主存；</p><p>（2）全写法+非写分配策略：cache命中时，同时写回cache和主存；cache未命中时，只写入主存，不调块</p></li><li><p>虚拟存储器？</p><p>（1）页式虚拟存储器：把虚拟空间和实际空间分成固定大小的页，各虚拟页可装入内存中的不同实际位置；逻辑地址=虚页号+页内地址；实际地址=页号+页内地址；</p><p>（2）段式虚拟存储器：将主存按段分配；段的长度却不固定，决定于用户编写的程序。</p><p>（3）段页式虚拟存储器</p></li><li><p>RISC和CISC区别？</p><p>（1）RISC：指令数目少，通用寄存器数量少，指令字长是定长的；大多数指令在一个周期内完成；只能用load/store访问指令，控制方式为组合逻辑控制；使用指令流水线；</p><p>（2）CISC：指令数目多，通用寄存器数量多，指令字长不固定，指令的执行时间相差较大；访存指令不加以限制，控制方式为微程序控制，只能通过一定的方式实现指令流水线</p></li><li><p>数据据寻址方式？</p><p>（1）隐含寻址：操作数地址不直接给出，隐含在指令中</p><p>（2）立即寻址：直接给出操作数本身</p><p>（3）直接寻址：直接给出操作数的地址</p><p>（4）间接寻址：给出操作数地址所在的存储空间的地址</p><p>（5）寄存器寻址：给出操作数所在的寄存器的编号</p><p>（6）寄存器间接寻址：给出操作数所在主存单元地址的寄存器编号</p><p>（7）相对寻址：将PC计数器的内容加上指令格式中的形式地址</p><p>（8）基址寻址：将基址寄存器中的内容加上指令格式中的形式地址</p><p>（9）变址寻址：将变址寄存器中的内容加上指令格式中的形式地址</p><p>（10）堆栈寻址：在规定的堆栈中取出操作数</p></li><li><p>指令的执行过程？</p><p>（1）取值周期：将指令地址送入到地址寄存器中（MAR）；控制器（CU）发出读（R）控制信号；主存根据地址线上的地址和读信号，从指定的存储单元得到数据，将数据放回数据寄存器（MDR）中，并送到IR中；PC+1，形成下一条指令</p><p>（2）间指周期：将（IR）指令的地址码送入地址寄存器（MAR）中，控制器发出读控制信号；将地址寄存器（MAR）所指主存中的内容经数据线送到数据寄存器（MDR）中；</p><p>（3）执行周期：不同指令的指令周期不同</p><p>（4）中断周期：中断请求、中断判优、中断响应（关中断、保存断点、引入中断服务程序）、中断处理（保护现场、开中断、执行中断服务程序、关中断、恢复现场、开中断、中断返回）和中断返回</p></li><li><p>指令周期、机器周期、时钟周期？</p><p>指令周期是取出并执行一条指令所需要的全部时间；一个指令周期包括若干个机器周期，一个机器周期包括若干个时钟周期；</p><p>机器周期：指令周期中一步相对完整的操作所需要的时间</p><p>时钟周期：计算机主频的倒数，是计算机运行的基本时序单位</p><p>总线周期：两个设备进行一次信息传输需要的时间</p></li><li><p>指令流水线？</p><p>指令流水线技术是一种显著提高指令执行速度和效率的技术，指令取址完成后，不等该指令执行完毕就可以进行下一条指令的取址；</p><p>特点：</p><p>（1）将一个任务分成许多子任务，依靠多个部件并发工作缩短指令的执行时间；</p><p>（2）流水线每个功能段部件后都有一个缓冲寄存器，也叫锁存器，用于保存本流水段的执行结果，供给下一个流水段使用；</p><p>（3）流水线的各功能段时间应当尽量相等；</p><p>（4）要连续的进行任务；</p></li><li><p>影响流水线的因素？</p><p>（1）结构相关：多条指令同一时刻征用同一资源形成的冲突；（暂停一个时钟周期/设置单独的数据存储器和指令存储器）</p><p>（2）数据相关：后面的指令要用到前面指令的执行结果；（暂停一个周期/数据旁路：将计算结果直接输入到下一条指令）</p><p>（3）控制相关：流水线遇到分支指令或其他改变PC值的指令引起的（延迟转移：将转移指令与和转移指令无关的一条或几条指令对换转移）</p></li><li><p>CPU的组成？</p><p>控制器（程序计数器PC、指令寄存器IR、指令译码器ID、MAR、MDR）、运算器（算术逻辑单元ALU、累加寄存器ACC、程序状态寄存器PSW、通用寄存器）</p></li><li><p>CPU的性能？</p><p>（1）指令控制：完成取指令、分析指令和执行指令的过程</p><p>（2）操作控制：对操作信号进行处理</p><p>（3）数据加工：对数据进行算数和逻辑运算</p><p>（4）时间控制：对各种操作加以时间上的控制</p><p>（5）中断处理</p></li><li><p>引入总线的好处？</p><p>（1）简化了系统结构、便于系统扩充，易于实现系统的模块化</p><p>（2）减少了连线数目、体积减小、提高系统的可靠性</p><p>（3）便于接口设计</p></li><li><p>总线的仲裁方式？</p><p>（1）链式查询：所有部件用一根总线请求线，设备的先后顺序决定其优先级（总线请求：1，总线允许：1，总线控制：1）</p><p>（2）定时器定时查询：采用计数器控制总线的使用权（总线请求：1，总线允许：logn，总线忙：1）</p><p>（3）独立请求：每一个设备均有总线请求信号和总线同一信号（总线请求：n，总线允许：n，总线忙：1）</p></li><li><p>总线分类？</p><p>数据总线MDR（反应存储字长）（双向）、地址总线MAR（反应存储单元的个数）（单向）、控制总线（用来传输控制信号和时序信号）</p></li><li><p>总线基本特征？</p><p>1）共享：多个部件连接在同一组总线上，各个部件之间都通过该总线进行数据交换。</p><p>2）分时：同一时刻，总线上只能传输一个部件发送的信息；</p></li><li><p>IO设备的编址方式？</p><p>（1）统一编制方式：存储器和IO地址统一编制，不需要专门的IO指令</p><p>（2）独立编址方式：IO地址和存储器地址分开编址，需要专门的IO指令</p></li><li><p>IO方式？</p><p>（1）程序查询方式：不断查询IO设备是否就绪</p><p>（2）程序中断方式：在一个指令结束后检查是否有中断发生</p><p>（3）DMA方式：外部设备不经过CPU直接与主存进行数据交换</p><p>（4）通道方式：建立一个通道，主存与外部设备通过通道完成数据交换</p></li><li><p>中断响应优先级和中断处理优先级？</p><p>中断响应优先级是硬件排队路线或者中断查询程序的查询顺序决定的，不可动态更改；</p><p>中断处理优先级是由中断屏蔽字决定，可以进行更改，可以动态反应正在处理的中断是否比新发生的中断优先级低；</p></li><li><p>区别中断向量、向量中断和向量地址？</p><p>（1）中断向量：中断服务程序的入口地址</p><p>（2）向量地址：中断向量表中每个表项所在的内存地址</p><p>（3）向量中断：一种识别中断源的技术；</p></li><li><p>中断方式和DMA方式的区别？</p><p>（1）中断响应只能在中断周期时响应，DMA响应可以在每个机器周期结束响应</p><p>（2）中断方式需要CPU干预，DMA不需要CPU干预</p><p>（3）DMA请求的优先级高于中断请求</p></li><li><p>计算机的主要性能指标？</p><p>(1)机器字长</p><p>机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数，</p><p>(2)数据通路带宽</p><p>数据通路带宽是指数据总线一次所能并行传送信息的位数。</p><p>(3)主存容量</p><p>主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量。</p></li><li><p>波特率和比特率？</p><p>波特率表示<strong>单位时间内传输的符号数</strong>（Symbols persecond），单位为<strong>波特（Baud）</strong>。符号是调制技术中的基本单位，可以表示一个或多个比特的组合。</p><p>比特率表示<strong>单位时间内传输的比特数</strong>（Bits persecond），单位为<strong>bps</strong>（bits persecond）。它直接反映了实际有效数据的传输速率。</p></li><li><p>存储单元、存储字、存储字长、存储体？</p><p>存储单元：存储一个存储字并具有特定存储地址的存储；</p><p>存储字：一个存储单元中存放的所有的二进制数据；</p><p>存储字长：存储字中二进制数据的位数；</p><p>存储体：由多个存储单元构成的存储器件；</p></li><li><p>IEEE754浮点数的组成？</p><p>由数符、阶码、阶符以及尾数组成。阶码用移码表示，尾数用原码表示。</p><p>float为短实数，占32位，其中阶码8位，尾数23位。</p><p>double为长实数，占64位，其中阶码占11位，尾数为52位。</p></li><li><p>存取时间、存取周期？</p><p>1）存取时间：启动一次存储器完成本次操作（读或写）所需的时间；</p><p>2）存取周期：连续两次启动存储器所需要的最小间隔时间；</p><p>3）存取周期包含存取时间；</p></li></ol><h3 id="操作系统">操作系统</h3><ol type="1"><li><p>什么是操作系统？</p><p>操作系统是管理计算机硬件和软件的应用程序。</p><p>具有并发性、共享性、虚拟性和异步性</p></li><li><p>操作系统的主要功能？</p><p>（1）管理计算机资源：处理机管理/进程管理、存储管理（管理内存的分配和回收）、文件管理（计算机中的信息是以文件形式存在）、设备管理（完成io请求）</p><p>（2）为用户提供软硬件的接口：命令结构、系统调用、GUI图像处理</p><p>（3）作为扩充机器，在裸机的基础上加上一层软件，方便用户使用，成为虚拟机器或扩充机器</p></li><li><p>操作系统的两种状态？</p><p>核心态（管态）：可以执行特权指令，比如I/O指令和中断指令</p><p>用户态（目态）：只能执行非特权指令，只能控制用户自编程序和系统外核应用程序，不能控制系统内核程序</p></li><li><p>区别中断和异常？</p><p>广义的中断：内中断和外中断</p><p>内中断也叫异常，是来源于CPU执行指令内部的中断信号，比如地址越界、缺页异常；</p><p>外中断也就是平时所说的中断，中断信号来自CPU的外部，比如，I/O中断，时钟中断</p></li><li><p>什么是系统调用？</p><p>系统调用是操作系统给用户提供的使用计算机硬件资源的接口，通过中断指令从用户态转化为核心态</p></li><li><p>什么是临界区？解决临界区问题需要什么条件？</p><p>临界区是访问临界资源的那段代码，临界资源是一次仅允许一个进程使用的共享资源。</p><p>进程进入临界区的调度规则：空闲让进、忙则等待、有限等待、让权等待</p></li><li><p>程序、进程和线程？</p><p>进程：资源分配的基本单位，进程拥有独立的系统资源；进程间通信要以进程间通信进行；多进程中，一个进程崩溃对其他无影响；进程是暂时的、动态的、可并发的</p><p>线程：资源调度的基本单位，线程依赖进程，线程没有独立的系统资源；同一进程下的线程通信共享数据；多线程中，一个线程崩溃，其他也崩溃</p><p>程序：程序是永久的、静态的、不可并发的；</p></li><li><p>进程的状态？</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202503221106667.png" /></p></li><li><p>进程调度算法？</p><p>（1）先来先服务</p><p>（2）短作业优先</p><p>（3）时间片轮转</p><p>（4）高响应比优先：响应比=等待时间/处理时间</p><p>（5）多级队列：优先级递减、时间片递增</p></li><li><p>同步的四个准则？</p><p>（1）空闲让进：当没有进程处于临界区时，其他请求进入的进程应能立即进入，避免资源闲置。</p><p>（2）忙则等待：同一时间只能有一个进程/线程访问共享资源或临界区，防止数据竞争和不一致。</p><p>（3）有限等待：任何进程在请求进入临界区后，必须在有限时间内获得机会，避免无限期等待（饥饿）。</p><p>（4）让权等待：若进程无法进入临界区，应主动释放CPU（如通过阻塞或挂起），而非持续占用CPU资源进行忙等。</p></li><li><p>死锁产生的必要条件？</p><p>（1）互斥条件：至少有一个资源必须是互斥使用的，即同一时间只能被一个进程占用。例如，打印机或扫描仪等设备一次只能被一个进程使用。</p><p>（2）请求和保持：一个进程在持有至少一个资源的同时，还在请求其他资源。例如，进程A已经占用了打印机，同时还在等待扫描仪的使用。</p><p>（3）不可剥夺：资源不能被强行剥夺，只能由持有资源的进程自行释放。这意味着如果进程A占用了资源，其他进程必须等待，直到进程A释放该资源。</p><p>（4）循环等待：存在一个进程链，每个进程都在等待下一个进程释放资源，而最后一个进程又在等待第一个进程释放资源，形成一个环状的等待链。例如，进程A等待进程B的资源，进程B等待进程C的资源，而进程C又等待进程A的资源。</p></li><li><p>地址翻译过程？（虚实地址转换）</p><p>TLB快表–＞页表–＞Cache–＞内存–＞外存）</p><p><strong>步骤 1：进程访问虚拟地址</strong></p><ul><li>进程访问虚拟地址（例如 <code>0x12345678</code>）。</li></ul><p><strong>步骤 2：虚拟地址分解</strong></p><ul><li>虚拟地址被分解为页号和页内偏移量。</li></ul><p><strong>步骤 3：查找TLB</strong></p><ul><li>CPU首先查找TLB（快表）：<ul><li>如果TLB命中，则直接获取物理页框号，跳转到步骤5。</li><li>如果TLB未命中，则继续查找页表。</li></ul></li></ul><p><strong>步骤 4：查找页表</strong></p><ul><li>如果TLB未命中，CPU通过多级页表查找虚拟页号对应的物理页框号。</li><li>如果页表项无效，则触发缺页异常，操作系统加载页到物理内存并更新页表。</li></ul><p><strong>步骤 5：生成物理地址</strong></p><ul><li>将物理页框号与页内偏移量组合，生成物理地址（例如<code>0xABCDE678</code>）。</li></ul><p><strong>步骤 6：访问缓存（Cache）</strong></p><ul><li>CPU使用物理地址访问缓存（Cache）：<ul><li><strong>缓存命中</strong>：如果数据在缓存中，则直接从缓存中读取或写入数据，无需访问物理内存。</li><li><strong>缓存未命中</strong>：如果数据不在缓存中，则从物理内存中加载数据到缓存，然后从缓存中访问数据。</li></ul></li></ul><p><strong>步骤 7：访问物理内存（缓存未命中时）</strong></p><ul><li>如果缓存未命中，则访问物理内存，加载数据到缓存，并完成操作。</li></ul><p><strong>步骤 8：更新TLB和缓存</strong></p><ul><li>如果TLB未命中，则将虚拟页号到物理页框号的映射存入TLB。</li><li>如果缓存未命中，则将数据从物理内存加载到缓存。</li></ul></li></ol><h3 id="前沿知识">前沿知识</h3><p><strong>你对人工智能有什么了解？强人工智能可能实现吗？</strong>人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。强人工智能观点认为有可能制造出真正能推理和解决问题的智能机器，并且，这样的机器能将被认为是有知觉的，有自我意识的。强人工智能有两类：</p><ul><li>类人的人工智能，即机器的思考和推理就像人的思维一样。</li><li>非类人的人工智能，即机器产生了和人完全不一样的知觉和意识，使用和人完全不一样的推理方式。</li></ul><p><strong>什么是机器学习？讲讲具体的算法。</strong>机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构从而不断改善自身的性能。相对于传统机器学习利用经验改善系统自身的性能，现在的机器学习更多是利用数据改善系统自身的性能。基于数据的机器学习是现代智能技术中的重要方法之一，它从观测数据（样本）出发寻找规律，利用这些规律对未来数据或无法观测的数据进行预测。</p><p>​ 机器学习算法：决策树、神经网络、向量机、贝叶斯、Boosting…决策树：决策树（decisiontree）是一类常见的机器学习方法。类似于流程图，一颗决策树包含一个根节点、若干个内部节点和叶子节点，每一个树节点表示对一个特征或属性的测试，每一个分支代表一个属性的输出，每一个叶子节点对应一种决策结果。从根节点到每个叶节点的路径对应了一个判定测试序列。其学习的基本流程遵循分治（divide-and-conquer）策略。</p><p><strong>什么是大数据？你接触到的最大的数据有多大？</strong>一种规模大到在获取、存储、管理、分析方面大大超出了传统数据库软件工具能力范围的数据集合，具有海量的数据规模、快速的数据流转、多样的数据类型和价值密度低四大特征。</p><p>​大数据与云计算的关系就像一枚硬币的正反面一样密不可分。大数据必然无法用单台的计算机进行处理，必须采用分布式架构。它的特色在于对海量数据进行分布式数据挖掘。但它必须依托云计算的分布式处理、分布式数据库和云存储、虚拟化技术。</p><p><strong>什么是数据挖掘？</strong>数据挖掘是指从大量的数据中通过算法搜索隐藏于其中信息的过程。</p><p><strong>大数据和机器学习之间有什么联系？</strong>物联网是“交互方式”，云计算是“基础设施”，人工智能是“场景应用”，大数据是“交互内容”。大数据使用物联网交互方式、存储在云计算基础设施、支持人工智能场景应用，生成完整的价值链。大数据的存储、处理需要云计算基础设施的支撑，云计算需要海量数据的处理能力证明自身的价值；人工智能技术的进步离不开云计算能力的不断增长，云计算让人工智能服务无处不在、触手可及；大数据的价值发现需要高效的人工智能方法，人工智能的自我学习需要海量数据的输入。</p><p><strong>什么是云计算？</strong>云计算是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。可以在很短的时间内完成对数以万计的数据的处理，从而达到强大的网络服务。</p><p><strong>什么是深度学习？</strong>深度学习是机器学习领域中一个新的研究方向，它被引入机器学习使其更接近于最初的目标——人工智能深度学习是学习样本数据的内在规律和表示层次，这些学习过程中获得的信息对诸如文字，图像和声音等数据的解释有很大的帮助。它的最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。深度学习是一个复杂的机器学习算法，在语音和图像识别方面取得的效果，远远超过先前相关技术。</p><h3 id="总结-1">总结</h3><h4 id="第一部分毕设">第一部分：毕设</h4><ol type="1"><li>毕设关于什么？（2018）</li><li>前端、后台用的什么技术？（2018）</li><li>介绍一下用到的框架技术。（2018）</li></ol><h4 id="第二部分项目">第二部分：项目</h4><ol type="1"><li>项目是关于什么的？（2018，2019）</li><li>你主要负责哪部分，做了什么？（2018，2019）</li><li>如果中间用到某技术或框架，可能会让介绍。（2018，2019）</li><li>硬件用什么系统，软件用什么系统。2019）</li></ol><h4id="第三部分专业课去年问的最多的就是数据结构的问题">第三部分：专业课（去年问的最多的就是数据结构的问题）</h4><ol type="1"><li><p>数据结构由哪个老师教的？（内大本校学生需准备，忘记就尴尬喽！）（2018）</p></li><li><p>数据结构排序有哪些？（2018）</p></li><li><p>OSI的七层协议模型。</p></li><li><p>TCP/IP四层模式。（2019）</p><p>答：TCP/IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层。从实质上讲，只有上边三层，网络接口层没有什么具体的内容。</p></li></ol><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202503212301949.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="5" type="1"><li>栈和队列的区别？（2019)</li><li>介绍一下最大堆排序？（可能也会是其他排序，要记住算法思想）（2018，2019）</li><li>介绍一下快速排序？（2019）</li><li>初试专业考的什么？（接下来肯定会接着问考的课程内容，需要准备一下）（2018）</li><li>数据库有哪些操作，特点是什么？（2018）</li><li>什么是平衡二叉树？（2018）</li><li>进程调度。（2019）</li></ol><h4 id="第四部分跨专业">第四部分：跨专业</h4><p>为什么跨专业？（必备）（2018）</p><h4 id="第五部分成绩">第五部分：成绩</h4><ol type="1"><li>本科成绩排名。（看一下成绩单上有没有排名，如果没有，你说了算）（2018）</li><li>专业有多少人。（老师不知道你专业有多少人，你说了算）（2018）</li></ol><h4 id="第六部分其他">第六部分：其他</h4><ol type="1"><li>为什么选择内大？（2019）</li><li>为什么考研？（2019）</li><li>编程能力怎么样？（2019）</li><li>人工智能、大数据了解多少？（2019）</li><li>你报考的老师的研究方向，你了解多少？（2019）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 复试 </tag>
            
            <tag> 口语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件分享】Internet Download Manager(IDM)破解版</title>
      <link href="/posts/22410.html"/>
      <url>/posts/22410.html</url>
      
        <content type="html"><![CDATA[<h3 id="去官网下载idm">去官网下载IDM</h3><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202502242111644.png"alt="image-20250224211117355" /><figcaption aria-hidden="true">image-20250224211117355</figcaption></figure><p>点击<strong>TRY IDM 30-DAYS FREE TRIAL</strong>下载最新版IDM</p><h3 id="下载">下载</h3><p><a class="wp-block-button__link has-text-color has-background" href="https://pan.baidu.com/s/1omxKWQhJOI4QLRDhhtpyIA?pwd=6666" style="border-radius:2px;background-color:#ba0c49;color:#fffffa" target="_blank" rel="noreferrer noopener">百度网盘下载【提取码6666】</a></p><h3 id="激活">激活</h3><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202502242113409.png"alt="image-20250224211323370" /><figcaption aria-hidden="true">image-20250224211323370</figcaption></figure><p>如图所示，取消勾选第一个复选框（IDM自动更新检查）避免以后idm时常提醒更新，再点击<strong><u>C</u>rack</strong>执行破解</p>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 下载软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【debug】win10桌面图标变空白但正常运行</title>
      <link href="/posts/51332.html"/>
      <url>/posts/51332.html</url>
      
        <content type="html"><![CDATA[<p>在使用电脑过程中，我们偶尔会碰到，<strong>软件桌面图标变成白色</strong>的情况。这问题来得莫名其妙，也不知道咋回事，一大片快捷方式突然全白了。当然，你依旧可以正常打开软件，好像坏的，仅仅只是图标表面。</p><p>但这足以让强迫症难受，好好的图标变成这样，<strong>怎么看怎么不顺眼</strong>。所以这次，系统迷打算专门写篇文章，<strong>分享个桌面图标变白恢复技巧</strong>。其实，只要你的电脑正常，这问题通常都是由于<strong>图标缓存损坏</strong>造成的。</p><p>Windows为了实现快速显示，会把桌面和文件夹中的图标缓存起来。当这些缓存文件出现损坏时，图标就可能无法正常显示，从而变成白色。<strong>如果你要把白色图标，一次性全恢复正常</strong>，可以按照以下方法操作。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202502152239296.png"alt="电脑图标变空白" /><figcaption aria-hidden="true">电脑图标变空白</figcaption></figure><h2 id="具体步骤如下">具体步骤如下：</h2><p>1、右键开始菜单，选择“运行”，输入<strong>%localappdata%</strong>，点确定。</p><p>2、在弹出的文件夹里，找到<strong>IconCache.db</strong>这个文件。</p><p>3、如果找不到这个文件，说明你的系统没有打开隐藏文件显示。</p><p>4、资源管理器顶部菜单栏，<strong>依次展开“查看-显示”，勾选“隐藏的项目”</strong>。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202502152242135.png"alt="删除IconCache.db文件" /><figcaption aria-hidden="true">删除IconCache.db文件</figcaption></figure><p>5、你就可以找到<strong>IconCache.db</strong>这个文件了，<strong>右键删除它</strong>。</p><p>6、Ctrl+Alt+Delete启动<strong>任务管理器</strong>，右键Windows资源管理器<strong>重新启动</strong>，图标就恢复正常啦！</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202502152246827.png" alt="image-20250215224615769" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】MySQL安装配置命令</title>
      <link href="/posts/42645.html"/>
      <url>/posts/42645.html</url>
      
        <content type="html"><![CDATA[<h3 id="mysql安装">MySQL安装</h3><p>①安装服务：<code>mysqld --install</code></p><p>②初始化：　<code>mysqld --initialize --console</code></p><p>③开启服务：<code>net start mysql</code></p><p>④关闭服务：<code>net stop mysql</code></p><p>⑤登录mysql：<code>mysql -u root -p</code></p><p>⑥修改密码：<code>alter user root@localhost identified by '密码';</code></p><p>⑦标记删除mysql服务：<code>sc delete mysql</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件分享】福昕pdf编辑器</title>
      <link href="/posts/54291.html"/>
      <url>/posts/54291.html</url>
      
        <content type="html"><![CDATA[<p><a class="wp-block-button__link has-text-color has-background" href="https://pan.baidu.com/s/1XcpZspzVqhajCNaiHrbYMQ?pwd=fu8h" style="border-radius:2px;background-color:#ba0c49;color:#fffffa" target="_blank" rel="noreferrer noopener">百度网盘下载【提取码fu8h】</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pdf编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件分享】Navicat15</title>
      <link href="/posts/7138.html"/>
      <url>/posts/7138.html</url>
      
        <content type="html"><![CDATA[<h3 id="卸载已安装的版本">卸载已安装的版本</h3><p>若不完全卸载历史安装版本，在执行破解程序时，可能会出现“No All PatternFound!File AlreadyPatched?”的情况，所以需要完全卸载旧版本，因为卸载程序卸载不完全，所以在卸载程序执行完毕后需要<font color="red">删除对应文件夹</font>。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308170926962.png"alt="image-20230817092617796" /><figcaption aria-hidden="true">image-20230817092617796</figcaption></figure><h3 id="安装navicat">安装Navicat</h3><p>使用安装程序<code>navicat150_premium_cs_x64.exe</code>安装navicat15</p><p><font color="red">（安装过程中需要记住安装路径，破解时会用到）</font></p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308161959053.png"alt="image-20230816195914990" /><figcaption aria-hidden="true">image-20230816195914990</figcaption></figure><h3 id="破解navicat">破解navicat</h3><ol type="1"><li><p>首先<strong><font color=red>断网</font></strong>，确保navicat连接不到服务器。</p></li><li><p>打开破解程序<code>Navicat Keygen Patch v5.6.0 DFoX.exe</code>，执行Patch操作<imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308170925985.png"alt="image-20230817092519772" /></p></li><li><p>若Patch成功，会出现“Cracked”提示，否则请重装navicat15</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308171024246.png"alt="image-20230817102428072" /><figcaption aria-hidden="true">image-20230817102428072</figcaption></figure></li><li><p>点击如图所示的Generate生成序列码</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308171026545.png"alt="image-20230817102659390" /><figcaption aria-hidden="true">image-20230817102659390</figcaption></figure></li><li><p>打开navicat，在弹出的窗口中点击注册</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308171029794.png"alt="image-20230817102942612" /><figcaption aria-hidden="true">image-20230817102942612</figcaption></figure></li><li><p>将第4步生成的序列码输入，点击“激活”按钮</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308171030403.png"alt="image-20230817103056217" /><figcaption aria-hidden="true">image-20230817103056217</figcaption></figure></li><li><p>因为我们已经断网，navicat是连接不到服务器的，因此会出现如图所示情况，我们选择“手动激活”</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308171031488.png"alt="image-20230817103133369" /><figcaption aria-hidden="true">image-20230817103133369</figcaption></figure></li><li><p>将弹出窗口中的请求码复制</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308171033285.png"alt="image-20230817103359110" /><figcaption aria-hidden="true">image-20230817103359110</figcaption></figure></li><li><p>粘贴到破解程序中，点击激活，即可成功激活</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308171034919.png"alt="image-20230817103457765" /><figcaption aria-hidden="true">image-20230817103457765</figcaption></figure></li></ol><h3 id="简述破解过程">简述破解过程</h3><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308171035421.png"alt="image-20230817103542239" /><figcaption aria-hidden="true">image-20230817103542239</figcaption></figure><h3 id="下载">下载</h3><p><a class="wp-block-button__link has-text-color has-background" href="https://pan.baidu.com/s/1VX7e0nuuRW0pkYcgGok7vw?pwd=hyhk" style="border-radius:2px;background-color:#ba0c49;color:#fffffa" target="_blank" rel="noreferrer noopener">百度网盘下载【提取码hyhk】</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库管理软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】微分方程的求解</title>
      <link href="/posts/21851.html"/>
      <url>/posts/21851.html</url>
      
        <content type="html"><![CDATA[<h3 id="微分方程的基本概念">微分方程的基本概念</h3><p>来看一个最简单的微分方程： <spanclass="math display"><em>y</em><sup>′</sup> = <em>x</em></span>则可以得到：</p><p><span class="math display">$$y=\frac{x^2}{2}+C$$</span> 这就是微分方程的解。需要注意到三个方面：</p><ol type="1"><li>微分方程最大的特点就是方程中含有导数项；</li><li>求解微分方程，并非是要给𝑦𝑦, 𝑥𝑥以确定的数值，而是解出𝑦𝑦,𝑥𝑥之间的关系式；</li><li>微分方程的解并非是唯一的，需要加入一个未定参数𝐶𝐶.</li></ol><p>如果微分方程改变条件：</p><p><spanclass="math display"><em>y</em><sup>′</sup> = <em>x</em>  (<em>x</em> = 0, <em>y</em> = 1)</span>得到对应的解就变成唯一的：</p><p><span class="math display">$$y=\frac{x^2}{2}+1$$</span> 由此，我们管“<spanclass="math inline"><em>x</em> = 0, <em>y</em> = 1</span>”叫做这个微分方程的<strong>定解条件</strong>，对应的解分为“<strong>通解</strong>”和“<strong>特解</strong>”，顾名思义，就是针对微分方程本身的通用的解，以及针对特定条件所确定的唯一的解：</p><p><span class="math display">$$通解：y=\frac{x^2}{2}+C\\特解：y=\frac{x^2}{2}+1$$</span></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】修改jupyter默认工作目录</title>
      <link href="/posts/35819.html"/>
      <url>/posts/35819.html</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>进入conda环境</li><li>运行<code>jupyter notebook --generate-config</code>命令</li><li>找到配置文件</li><li>修改c.NotebookApp.notebook_dir为工作目录</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】conda的使用</title>
      <link href="/posts/23557.html"/>
      <url>/posts/23557.html</url>
      
        <content type="html"><![CDATA[<h2 id="指令集合">指令集合</h2><h3 id="设置镜像">设置镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置清华镜像</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line"><span class="comment">#设置搜索时显示通道地址</span></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h3 id="管理conda">管理conda</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda update conda  <span class="comment"># 更新conda</span></span><br><span class="line">conda update Anaconda  <span class="comment"># 更新整个Anaconda</span></span><br><span class="line">conda clean -p  <span class="comment"># 删除没有用的包</span></span><br><span class="line">conda clean -t  <span class="comment"># 删除tar打包</span></span><br><span class="line">conda clean -a <span class="comment"># 删除所有的安装包及cache(索引缓存、锁定文件、未使用过的包和tar包)</span></span><br></pre></td></tr></table></figure><h3 id="管理环境">管理环境</h3><h4 id="设置环境默认安装路径">设置环境默认安装路径</h4><h5 id="方法一使用-conda-config-命令">方法一：使用 conda config命令</h5><p>可以使用 conda config 命令来直接更新 .condarc文件，设置新的环境和包目录路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> envs_dirs D:/new_envs</span><br><span class="line">conda config --<span class="built_in">set</span> pkgs_dirs D:/new_pkgs</span><br></pre></td></tr></table></figure><p>执行这些命令会自动更新 .condarc 文件中的相关设置。</p><h5 id="方法二手动编辑-.condarc-文件">方法二：手动编辑 .condarc文件</h5><p>找到用户主目录下的 .condarc 文件，通常路径为C:.condarc。如果文件不存在，可以手动创建一个。使用文本编辑器打开.condarc 文件，添加以下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">envs_dirs:</span><br><span class="line">- D:/new_envs</span><br><span class="line">pkgs_dirs:</span><br><span class="line">- D:/new_pkgs</span><br></pre></td></tr></table></figure><p>这会将环境和包缓存目录更改为指定的新路径。</p><h5 id="方法三在创建环境时指定路径">方法三：在创建环境时指定路径</h5><p>在创建新的 Conda 环境时，可以使用 –prefix 参数指定环境的安装路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --prefix=D:/IDE/Anaconda/prefix_envs python=3.8</span><br></pre></td></tr></table></figure></p><p>该地址不需要提前新建好，如果提前新建了地址，则会提示你已存在一个文件，可以直接继续。</p><h4 id="查看环境">查看环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line">conda info -e</span><br><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p>以上三条命令都可以。注意最后一个是”–”，而不是“-”</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307261052650.png"alt="image-20230726105204603" /><figcaption aria-hidden="true">image-20230726105204603</figcaption></figure><blockquote><p>所显示的列表中，前面带星号“*“的表示当前活动环境。</p></blockquote><h4 id="创建环境">创建环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n xxx  <span class="comment"># 创建环境名为xxx的环境</span></span><br></pre></td></tr></table></figure><p>例如创建环境名为py39的环境并安装python3.9</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py39 python==3.9</span><br></pre></td></tr></table></figure><p>这表示创建python版本为3.9、名字为py39的虚拟环境</p><blockquote><p>创建后，py39文件可以在Anaconda安装目录envs文件下找到。在不指定python版本时，自动创建基于最新python版本的虚拟环境。</p></blockquote><p>在创建新的 Conda 环境时，可以使用 –prefix 参数指定环境的安装路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --prefix=D:/IDE/Anaconda/prefix_envs python=3.8</span><br></pre></td></tr></table></figure></p><p>该地址不需要提前新建好，如果提前新建了地址，则会提示你已存在一个文件，可以直接继续。</p><h4 id="激活环境">激活环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate xxx  <span class="comment"># 激活环境名为xxx的环境</span></span><br></pre></td></tr></table></figure><p>此时使用python–version可以检查当前python版本是否为所想要的（即虚拟环境的python版本）</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307261055499.png"alt="image-20230726105525458" /><figcaption aria-hidden="true">image-20230726105525458</figcaption></figure><h4 id="退出环境">退出环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate</span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>以上两条命令只中任一条都会让你回到baseenvironment，它们从不同的角度出发到达了同一个目的地。可以这样理解，activate的缺省值是base，deactivate的缺省值是当前环境，因此它们最终的结果都是回到base</p><h4 id="删除环境">删除环境</h4><p>执行以下命令可以将该指定虚拟环境及其中所安装的包都删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name env_name --all</span><br></pre></td></tr></table></figure><h4 id="导出环境">导出环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获得环境名为env_name中的所有配置并保存配置信息到my_env.yml文件中</span></span><br><span class="line">conda <span class="built_in">env</span> <span class="built_in">export</span> --name env_name &gt; my_env.yml</span><br><span class="line"><span class="comment">#重新还原环境</span></span><br><span class="line">conda <span class="built_in">env</span> create -f my_env.yml</span><br></pre></td></tr></table></figure><h3 id="管理包">管理包</h3><h4 id="查询包">查询包</h4><p>查看当前环境安装了哪些包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><p>查看Anaconda repository中是否有xxx包（联网查询）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search xxx</span><br></pre></td></tr></table></figure><h4 id="安装包">安装包</h4><p>在当前环境中安装package_name包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure><p>也可以指定安装的包的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install package_name==1.0.0</span><br></pre></td></tr></table></figure><p>例如，安装numpy版本为0.20.3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy==0.20.3</span><br></pre></td></tr></table></figure><h4 id="更新包">更新包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update package_name</span><br></pre></td></tr></table></figure><p>将package_name包更新到最新版本</p><h4 id="卸载包">卸载包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda uninstall package_name</span><br></pre></td></tr></table></figure><p>卸载包名为package_name的包</p><h2 id="conda与pip">conda与pip</h2><h3 id="有什么区别">有什么区别？</h3><ol type="1"><li>conda可以管理非python包，pip只能管理python包。</li><li>conda自己可以用来创建环境，pip不能，需要依赖virtualenv之类的。</li><li>conda安装的包是编译好的二进制文件，安装包文件过程中会自动安装依赖包；pip安装的包是wheel或源码，装过程中不会去支持python语言之外的依赖项。</li><li>conda安装的包会统一下载到一个目录文件中，当环境B需要下载的包，之前其他环境安装过，就只需要把之间下载的文件复制到环境B中，下载一次多次安装。pip是直接下载到对应环境中。</li><li>conda只能在conda管理的环境中使用，例如比如conda所创建的虚环境中使用。pip可以在任何环境中使用，在conda创建的环境中使用pip命令，需要先安装pip（conda install pip ），然后可以 环境A中使用pip 。conda安装的包，pip可以卸载，但不能卸载依赖包，pip安装的包，只能用pip卸载。</li></ol><h3 id="安装在哪里">安装在哪里？</h3><ul><li><code>conda install xxx</code>：这种方式安装的库都会放在<code>anaconda3/pkgs</code>目录下，这样的好处就是，当在某个环境下已经下载好了某个库，再在另一个环境中还需要这个库时，就可以直接从<code>pkgs</code>目录下将该库复制至新环境而不用重复下载。</li><li><code>pip install xxx</code>：分两种情况，一种情况就是当前conda环境的python是conda安装的，和系统的不一样，那么<code>xxx</code>会被安装到<code>anaconda3/envs/current_env/lib/python3.x/site-packages</code>文件夹中，如果当前conda环境用的是系统的python，那么<code>xxx</code>会通常会被安装到<code>~/.local/lib/python3.x/site-packages</code>文件夹中</li></ul><h3id="如何判断conda中某个包是通过conda还是pip安装的">如何判断conda中某个包是通过conda还是pip安装的？</h3><p>执行 <code>conda list</code>，用pip安装的包显示的build项目为pypi。如下图所示</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307261133811.png"alt="image-20230726113303750" /><figcaption aria-hidden="true">image-20230726113303750</figcaption></figure><h2 id="conda的配置">conda的配置</h2><h3 id="condarc文件在哪儿">.condarc文件在哪儿？</h3><p>执行<code>conda info</code>，如下图所示</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307261145690.png"alt="image-20230726114544635" /><figcaption aria-hidden="true">image-20230726114544635</figcaption></figure><h3 id="channel管理">channel管理</h3><p>追加conda-forge channel:</p><blockquote><p>conda config –add channels conda-forge</p></blockquote><p>移除conda-forge channel:</p><blockquote><p>conda config –remove channels conda-forge</p></blockquote><p>查询当前配置中包含哪些channels</p><blockquote><p>conda config –get channels</p></blockquote><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307261147482.png"alt="image-20230726114725437" /><figcaption aria-hidden="true">image-20230726114725437</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】配置深度学习环境</title>
      <link href="/posts/10831.html"/>
      <url>/posts/10831.html</url>
      
        <content type="html"><![CDATA[<h3 id="查看cuda版本">查看CUDA版本</h3><p>执行<code>nvidia-smi</code>命令，如下图所示</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307261156654.png"alt="image-20230726115622592" /><figcaption aria-hidden="true">image-20230726115622592</figcaption></figure><p>可以发现我的CUDA Version为12.0，因此可以安装cuda12.0以下的pytorch</p><h3 id="创建虚拟环境">创建虚拟环境</h3><p>这里我取虚拟环境名为DL（DeepLearning），可以自定义</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n DL python=<span class="number">3</span>.<span class="number">9</span>  # 创建虚拟环境并指定python版本</span><br></pre></td></tr></table></figure><h3 id="激活虚拟环境">激活虚拟环境</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate DL</span><br></pre></td></tr></table></figure><h3 id="查看anaconda库中的pytorch">查看Anaconda库中的pytorch</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search pytorch</span><br></pre></td></tr></table></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307261212345.png"alt="image-20230726121236260" /><figcaption aria-hidden="true">image-20230726121236260</figcaption></figure><h3 id="conda安装pytorch">conda安装pytorch</h3><p>找到对应的pytorch（主要看python版本、CUDA版本），使用conda进行安装这里我指定pytorch版本为<code>1.12.0</code>，build号为<code>py3.9_cuda11.6_cudnn8_0</code>，没有指定channel</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch=<span class="number">1</span>.<span class="number">12</span>.<span class="number">0</span>=py3.<span class="number">9</span>_cuda11.<span class="number">6</span>_cudnn8_0</span><br></pre></td></tr></table></figure><p>如果使用conda安装不上可以使用pip安装</p><p><a class="wp-block-button__link has-text-color has-background" href="https://pan.baidu.com/s/1X1K14nHzZRh0GaruGggdYA?pwd=8mtp" style="border-radius:2px;background-color:#ba0c49;color:#fffffa" target="_blank" rel="noreferrer noopener">百度网盘下载【提取码8mtp】</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Java设计模式</title>
      <link href="/posts/18992.html"/>
      <url>/posts/18992.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式概述">1，设计模式概述</h1><h2 id="软件设计模式的产生背景">1.1 软件设计模式的产生背景</h2><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p><p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任<code>克里斯托夫·亚历山大（Christopher Alexander）</code>在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p><p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（RichardHelm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（JohnVlissides）等 4位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了23个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。</p><h2 id="软件设计模式的概念">1.2 软件设计模式的概念</h2><p>软件设计模式（Software DesignPattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h2 id="学习设计模式的必要性">1.3 学习设计模式的必要性</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><p>正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h2 id="设计模式分类">1.4 设计模式分类</h2><ul><li><p><strong>创建型模式</strong></p><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等5 种创建型模式。</p></li><li><p><strong>结构型模式</strong></p><p>用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等7 种结构型模式。</p></li><li><p><strong>行为型模式</strong></p><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11 种行为型模式。</p></li></ul><h1 id="uml图">2，UML图</h1><p>统一建模语言（Unified ModelingLanguage，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p>UML从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等9 种图。</p><h2 id="类图概述">2.1 类图概述</h2><p>类图(Classdiagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p><h2 id="类图的作用">2.2 类图的作用</h2><ul><li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li><li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li></ul><h2 id="类图表示法">2.3 类图表示法</h2><h3 id="类的表示方式">2.3.1 类的表示方式</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method)且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240744.jpg" /></p><p>属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p><ul><li><p>+：表示public</p></li><li><p>-：表示private</p></li><li><p>#：表示protected</p></li></ul><p>属性的完整表示方式是： <strong>可见性 名称 ：类型 [ =缺省值]</strong></p><p>方法的完整表示方式是： <strong>可见性 名称(参数列表) [ ：返回类型]</strong></p><blockquote><p>注意：</p><p>​ 1，中括号中的内容表示是可选的</p><p>​ 2，也有将类型放在变量名前面，返回值类型放在方法名前面</p></blockquote><p><strong>举个栗子：</strong></p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240746.png" /></p><p>上图Demo类定义了三个方法：</p><ul><li>method()方法：修饰符为public，没有参数，没有返回值。</li><li>method1()方法：修饰符为private，没有参数，返回值类型为String。</li><li>method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。</li></ul><h3 id="类与类之间关系的表示方式">2.3.2 类与类之间关系的表示方式</h3><h4 id="关联关系">2.3.2.1 关联关系</h4><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p><p>关联又可以分为单向关联，双向关联，自关联。</p><p><strong>1，单向关联</strong></p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240746.png" /></p><p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p><p><strong>2，双向关联</strong></p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240749.png" /></p><p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p><p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p><p><strong>3，自关联</strong></p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240747.png" /></p><p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p><h4 id="聚合关系">2.3.2.2 聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240758.png" /></p><h4 id="组合关系">2.3.2.3 组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240179.png" /></p><h4 id="依赖关系">2.3.2.4 依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240206.png" /></p><h4 id="继承关系">2.3.2.5 继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p><p>在 UML类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240245.png" /></p><h4 id="实现关系">2.3.2.6 实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图9 所示。</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240274.png" /></p><h1 id="软件设计原则">3，软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="开闭原则">3.1 开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用接口和抽象类。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>下面以 <code>搜狗输入法</code> 的皮肤为例介绍开闭原则的应用。</p><p>【例】<code>搜狗输入法</code> 的皮肤设计。</p><p>分析：<code>搜狗输入法</code>的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240317.png" /></p><h2 id="里氏代换原则">3.2 里氏代换原则</h2><p>里氏代换原则是面向对象设计的基本原则之一。</p><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>下面看一个里氏替换原则中经典的一个例子</p><p>【例】正方形不是长方形。</p><p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240342.png" /></p><p>代码如下：</p><p><strong>长方形类（Rectangle）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正方形（Square）：</strong></p><p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setLength(width);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setLength(length);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;</span><br><span class="line">            rectangle.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印长方形的长和宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLengthAndWidth</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        System.out.println(rectangle.getLength());</span><br><span class="line">        System.out.println(rectangle.getWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        rectangle.setLength(<span class="number">20</span>);</span><br><span class="line">        rectangle.setWidth(<span class="number">10</span>);</span><br><span class="line">        resize(rectangle);</span><br><span class="line">        printLengthAndWidth(rectangle);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        rectangle1.setLength(<span class="number">10</span>);</span><br><span class="line">        resize(rectangle1);</span><br><span class="line">        printLengthAndWidth(rectangle1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p><p>如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240546.png" style="zoom:80%;" /></p><h2 id="依赖倒转原则">3.3 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>下面看一个例子来理解依赖倒转原则</p><p>【例】组装电脑</p><p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p><p><strong>类图如下：</strong></p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240573.png" style="zoom:80%;" /></p><p>代码如下：</p><p><strong>希捷硬盘类（XiJieHardDisk）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiJieHardDisk</span> <span class="keyword">implements</span> <span class="title class_">HardDisk</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用希捷硬盘存储数据&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用希捷希捷硬盘取数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Intel处理器（IntelCpu）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelCpu</span> <span class="keyword">implements</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Intel处理器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>金士顿内存条（KingstonMemory）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KingstonMemory</span> <span class="keyword">implements</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用金士顿作为内存条&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>电脑（Computer）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> XiJieHardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> IntelCpu cpu;</span><br><span class="line">    <span class="keyword">private</span> KingstonMemory memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IntelCpu <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(IntelCpu cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> KingstonMemory <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(KingstonMemory memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> XiJieHardDisk <span class="title function_">getHardDisk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHardDisk</span><span class="params">(XiJieHardDisk hardDisk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机工作&quot;</span>);</span><br><span class="line">        cpu.run();</span><br><span class="line">        memory.save();</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> hardDisk.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;从硬盘中获取的数据为：&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类（TestComputer）：</strong></p><p>测试类用来组装电脑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComputer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        computer.setHardDisk(<span class="keyword">new</span> <span class="title class_">XiJieHardDisk</span>());</span><br><span class="line">        computer.setCpu(<span class="keyword">new</span> <span class="title class_">IntelCpu</span>());</span><br><span class="line">        computer.setMemory(<span class="keyword">new</span> <span class="title class_">KingstonMemory</span>());</span><br><span class="line"></span><br><span class="line">        computer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。</p><p>根据依赖倒转原则进行改进：</p><p>代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。</p><p><strong>类图如下：</strong></p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240817.png" alt="image-20191229173554296" style="zoom:70%;" /></p><p><strong>电脑（Computer）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> Cpu cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HardDisk <span class="title function_">getHardDisk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHardDisk</span><span class="params">(HardDisk hardDisk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Cpu <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(Cpu cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memory <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Memory memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><h2 id="接口隔离原则">3.4 接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><p>下面看一个例子来理解接口隔离原则</p><p>【例】安全门案例</p><p>我们需要创建一个<code>黑马</code>品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240847.png" /></p><p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240886.png" /></p><p>代码如下：</p><p><strong>AntiTheft（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AntiTheft</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Fireproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fireproof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Waterproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Waterproof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HeiMaSafetyDoor（类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeiMaSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof,Waterproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ItcastSafetyDoor（类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItcastSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则">3.5 迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p><p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediatefriends and not to strangers）。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>下面看一个例子来理解迪米特法则</p><p>【例】明星与经纪人的关系实例</p><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240912.png" alt="image-20191229173554296" style="zoom:80%;" /></p><p>代码如下：</p><p><strong>明星类（Star）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Star</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>粉丝类（Fans）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fans</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fans</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>媒体公司类（Company）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>经纪人类（Agent）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Star star;</span><br><span class="line">    <span class="keyword">private</span> Fans fans;</span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStar</span><span class="params">(Star star)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFans</span><span class="params">(Fans fans)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fans = fans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompany</span><span class="params">(Company company)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.company = company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(fans.getName() + <span class="string">&quot;与明星&quot;</span> + star.getName() + <span class="string">&quot;见面了。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(company.getName() + <span class="string">&quot;与明星&quot;</span> + star.getName() + <span class="string">&quot;洽淡业务。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合成复用原则">3.6 合成复用原则</h2><p>合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol type="1"><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol type="1"><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>下面看一个例子来理解合成复用原则</p><p>【例】汽车分类管理程序</p><p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240146.png" alt="image-20191229173554296" style="zoom:80%;" /></p><p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111240187.png" alt="image-20191229173554296" style="zoom:80%;" /></p><h1 id="创建者模式">4，创建者模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p><p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建型模式分为：</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="单例设计模式">4.1 单例设计模式</h2><p>单例模式（Singleton Pattern）是 Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="单例模式的结构">4.1.1 单例模式的结构</h3><p>单例模式的主要有以下角色：</p><ul><li>单例类。只能创建一个实例的类</li><li>访问类。使用单例类</li></ul><h3 id="单例模式的实现">4.1.2 单例模式的实现</h3><blockquote><p>单例设计模式分类两种：</p><p>​ 饿汉式：类加载就会导致该单实例对象被创建</p><p>​懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><ol type="1"><li><p>饿汉式-方式1（静态变量方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> *      静态变量创建类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p></li><li><p>饿汉式-方式2（静态代码块方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恶汉式</span></span><br><span class="line"><span class="comment"> *      在静态代码块中创建该类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p></li><li><p>懒汉式-方式1（线程不安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> *  线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p></li><li><p>懒汉式-方式2（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> *  线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p></li><li><p>懒汉式-方式3（双重检查锁）</p><p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code>方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用<code>volatile</code> 关键字, <code>volatile</code>关键字可以保证可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">小结：</font></p><p>添加 <code>volatile</code>关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p></li><li><p>懒汉式-方式4（静态内部类方式）</p><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中,是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载,并初始化其静态属性。静态属性由于被 <code>static</code>修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton类的唯一性。</p><p><font color="red">小结：</font></p><p>​静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p></li><li><p>枚举方式</p><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​ 枚举方式属于恶汉式方式。</p></li></ol><h3 id="存在的问题">4.1.3 存在的问题</h3><h4 id="问题演示">4.1.3.1 问题演示</h4><p>破坏单例模式：</p><p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><ul><li><p>序列化反序列化</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p></blockquote></li><li><p>反射</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p></blockquote></li></ul><blockquote><p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p></blockquote><h4 id="问题的解决">4.1.3.2 问题的解决</h4><ul><li><p>序列化、反序列方式破坏单例模式的解决方法</p><p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面是为了解决序列化反序列化破解单例模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码解析：</strong></p><p>ObjectInputStream类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">outerHandle</span> <span class="operator">=</span> passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>);<span class="comment">//重点查看readObject0方法</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line"><span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="comment">//重点查看readOrdinaryObject方法</span></span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">        bin.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    <span class="comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span></span><br><span class="line">    <span class="comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           反射破解单例模式需要添加的代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">说明:</font></p><p>​这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。</p></li></ul><h3 id="jdk源码解析-runtime类">4.1.4 JDK源码解析-Runtime类</h3><p>Runtime类就是使用的单例设计模式。</p><ol type="1"><li><p>通过源代码查看使用的是哪儿种单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the runtime object associated with the current Java application.</span></span><br><span class="line"><span class="comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span></span><br><span class="line"><span class="comment">     * methods and must be invoked with respect to the current runtime object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span></span><br><span class="line"><span class="comment">     *          Java application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Don&#x27;t let anyone else instantiate this class */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。</p></li><li><p>使用Runtime类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回 Java 虚拟机中的内存总量。</span></span><br><span class="line">        System.out.println(runtime.totalMemory());</span><br><span class="line">        <span class="comment">//返回 Java 虚拟机试图使用的最大内存量。</span></span><br><span class="line">        System.out.println(runtime.maxMemory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> runtime.exec(<span class="string">&quot;ipconfig&quot;</span>);</span><br><span class="line">        <span class="comment">//获取命令执行后的结果，通过输入流获取</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>* <span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> inputStream.read(arr);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr,<span class="number">0</span>,b,<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="创建型模式">4，创建型模式</h1><h2 id="工厂模式">4.2 工厂模式</h2><h3 id="概述">4.2.1 概述</h3><p>需求：设计一个咖啡店点餐系统。</p><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p><p>具体类的设计如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241792.png" style="zoom:80%;" /></p><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p><p>在本教程中会介绍三种工厂的使用</p><ul><li>简单工厂模式（不属于GOF的23种经典设计模式）</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h3 id="简单工厂模式">4.2.2 简单工厂模式</h3><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><h4 id="结构">4.2.2.1 结构</h4><p>简单工厂包含如下角色：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h4 id="实现">4.2.2.2 实现</h4><p>现在使用简单工厂对上面案例进行改进，类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241794.png" style="zoom:70%;" /></p><p>工厂类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p><h4 id="优缺点">4.2.2.4 优缺点</h4><p><strong>优点：</strong></p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p><p><strong>缺点：</strong></p><p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p><h4 id="扩展">4.2.2.3 扩展</h4><p><strong>静态工厂</strong></p><p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式">4.2.3 工厂方法模式</h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h4 id="概念">4.2.3.1 概念</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><h4 id="结构-1">4.2.3.2 结构</h4><p>工厂方法模式的主要角色：</p><ul><li>抽象工厂（AbstractFactory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h4 id="实现-1">4.2.3.3 实现</h4><p>使用工厂方法模式对上例进行改进，类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241797.png" style="zoom:70%;" /></p><p>代码如下：</p><p>抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咖啡店类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CoffeeFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addsugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p><p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p><h4 id="优缺点-1">4.2.3.4 优缺点</h4><p><strong>优点：</strong></p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p><strong>缺点：</strong></p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><h3 id="抽象工厂模式">4.2.4 抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p><p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类）的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241795.png" style="zoom:67%;" /></p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241810.png" style="zoom:67%;" /></p><h4 id="概念-1">4.2.4.1 概念</h4><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><h4 id="结构-2">4.2.4.2 结构</h4><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（AbstractFactory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ul><h4 id="实现-2">4.2.4.2 实现</h4><p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241805.png" style="zoom:67%;" /></p><p>代码如下：</p><p>抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DessertFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Dessert <span class="title function_">createDessert</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//美式甜点工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanDessertFactory</span> <span class="keyword">implements</span> <span class="title class_">DessertFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchaMousse</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//意大利风味甜点工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItalyDessertFactory</span> <span class="keyword">implements</span> <span class="title class_">DessertFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tiramisu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p><h4 id="优缺点-2">4.2.4.3 优缺点</h4><p><strong>优点：</strong></p><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong></p><p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h4 id="使用场景">4.2.4.4 使用场景</h4><ul><li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p></li><li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p></li><li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p></li></ul><p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p><h3 id="模式扩展">4.2.5 模式扩展</h3><p><strong>简单工厂+配置文件解除耦合</strong></p><p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p><p>第一步：定义配置文件</p><p>为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">american</span>=<span class="string">com.itheima.pattern.factory.config_factory.AmericanCoffee</span></span><br><span class="line"><span class="attr">latte</span>=<span class="string">com.itheima.pattern.factory.config_factory.LatteCoffee</span></span><br></pre></td></tr></table></figure><p>第二步：改进工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Coffee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.load(is);</span><br><span class="line">            <span class="comment">//遍历Properties集合对象</span></span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">                <span class="comment">//根据键获取值（全类名）</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> p.getProperty((String) key);</span><br><span class="line">                <span class="comment">//获取字节码对象</span></span><br><span class="line">                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                <span class="type">Coffee</span> <span class="variable">obj</span> <span class="operator">=</span> (Coffee) clazz.newInstance();</span><br><span class="line">                map.put((String)key,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p><h3 id="jdk源码解析-collection.iterator方法">4.2.6JDK源码解析-Collection.iterator方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;令狐冲&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;风清扬&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;任我行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取迭代器对象</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//使用迭代器遍历</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241120.png" style="zoom:75%;" /></p><p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。</p><blockquote><p>另：</p><p>​ 1,DateForamt类中的getInstance()方法使用的是工厂模式；</p><p>​ 2,Calendar类中的getInstance()方法使用的是工厂模式；</p></blockquote><h2 id="原型模式">4.3 原型模式</h2><h3 id="概述-1">4.3.1 概述</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><h3 id="结构-3">4.3.2 结构</h3><p>原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>接口类图如下：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241295.png" /></p><h3 id="实现-3">4.3.3 实现</h3><p>原型模式的克隆分为浅克隆和深克隆。</p><blockquote><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p></blockquote><p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。Cloneable接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：</p><p><strong>Realizetype（具体的原型类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Realizetype</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体的原型对象创建完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Realizetype <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PrototypeTest（测试访问类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Realizetype</span>();</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">r2</span> <span class="operator">=</span> r1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;对象r1和r2是同一个对象？&quot;</span> + (r1 == r2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例">4.3.4 案例</h3><p><strong>用原型模式生成“三好学生”奖状</strong></p><p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241333.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        c1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//将奖状的名字修改李四</span></span><br><span class="line">        c2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景-1">4.3.5 使用场景</h3><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul><h3 id="扩展深克隆">4.3.6 扩展（深克隆）</h3><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStu</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241428.png" style="zoom:80%;" /></p><p><font color="red">说明：</font></p><p>​stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象输出流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将c1对象写出到文件中</span></span><br><span class="line">        oos.writeObject(c1);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象出入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取对象</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> (Citation) ois.readObject();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241451.png" style="zoom:80%;" /></p><blockquote><p>注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。</p></blockquote><h2 id="建造者模式">4.5 建造者模式</h2><h3 id="概述-2">4.4.1 概述</h3><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241574.png" style="zoom:60%;" /></p><ul><li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li><li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li><li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li></ul><h3 id="结构-4">4.4.2 结构</h3><p>建造者（Builder）模式包含如下角色：</p><ul><li><p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</p></li><li><p>具体建造者类（ConcreteBuilder）：实现 Builder接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p></li><li><p>产品类（Product）：要创建的复杂对象。</p></li><li><p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p></li></ul><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241624.png" style="zoom:80%;" /></p><h3 id="实例">4.4.3 实例</h3><p><strong>创建共享单车</strong></p><p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p><p>这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241129.png" style="zoom:80%;" /></p><p>具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自行车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String frame;</span><br><span class="line">    <span class="keyword">private</span> String seat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFrame</span><span class="params">(String frame)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSeat</span><span class="params">(String seat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seat = seat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象 builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Bike</span> <span class="variable">mBike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title function_">createBike</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摩拜单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobikeBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;铝合金车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;真皮车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ofo单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OfoBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;碳纤维车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;橡胶车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder mBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        mBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        mBuilder.buildFrame();</span><br><span class="line">        mBuilder.buildSeat();</span><br><span class="line">        <span class="keyword">return</span> mBuilder.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        showBike(<span class="keyword">new</span> <span class="title class_">OfoBuilder</span>());</span><br><span class="line">        showBike(<span class="keyword">new</span> <span class="title class_">MobikeBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBike</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">        <span class="type">Bike</span> <span class="variable">bike</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        System.out.println(bike.getFrame());</span><br><span class="line">        System.out.println(bike.getSeat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>上面示例是 Builder模式的常规用法，指挥者类 Director在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象 builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Bike</span> <span class="variable">mBike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title function_">createBike</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buildFrame();</span><br><span class="line">        <span class="built_in">this</span>.BuildSeat();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct()过于复杂，建议还是封装到 Director 中。</p><h3 id="优缺点-3">4.4.4 优缺点</h3><p><strong>优点：</strong></p><ul><li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li></ul><p><strong>缺点：</strong></p><p>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><h3 id="使用场景-2">4.4.5 使用场景</h3><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul><h3 id="模式扩展-1">4.4.6 模式扩展</h3><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p><p>重构前代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(String cpu, String screen, String memory, String mainboard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getScreen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScreen</span><span class="params">(String screen)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(String memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMainboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMainboard</span><span class="params">(String mainboard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构建Phone对象</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;intel&quot;</span>,<span class="string">&quot;三星屏幕&quot;</span>,<span class="string">&quot;金士顿&quot;</span>,<span class="string">&quot;华硕&quot;</span>);</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。</p><p>重构后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Phone</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        cpu = builder.cpu;</span><br><span class="line">        screen = builder.screen;</span><br><span class="line">        memory = builder.memory;</span><br><span class="line">        mainboard = builder.mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cpu</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            cpu = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">screen</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            screen = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">memory</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            memory = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">mainboard</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            mainboard = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Phone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="built_in">this</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>.Builder()</span><br><span class="line">                .cpu(<span class="string">&quot;intel&quot;</span>)</span><br><span class="line">                .mainboard(<span class="string">&quot;华硕&quot;</span>)</span><br><span class="line">                .memory(<span class="string">&quot;金士顿&quot;</span>)</span><br><span class="line">                .screen(<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。</p><h2 id="创建者模式对比">4.6 创建者模式对比</h2><h3 id="工厂方法模式vs建造者模式">4.6.1 工厂方法模式VS建造者模式</h3><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。</p><p>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p><h3 id="抽象工厂模式vs建造者模式">4.6.2 抽象工厂模式VS建造者模式</h3><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p><h1 id="结构型模式">5，结构型模式</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>桥接模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="代理模式">5.1 代理模式</h2><h3 id="概述-3">5.1.1 概述</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p><h3 id="结构-5">5.1.2 结构</h3><p>代理（Proxy）模式分为三种角色：</p><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类 ：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ul><h3 id="静态代理">5.1.3 静态代理</h3><p>我们通过案例来感受一下静态代理。</p><p>【例】火车站卖票</p><p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241189.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p><h3 id="jdk动态代理">5.1.4 JDK动态代理</h3><p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Proxy获取代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            newProxyInstance()方法参数说明：</span></span><br><span class="line"><span class="comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span></span><br><span class="line"><span class="comment">                InvocationHandler h ： 代理对象的调用处理程序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        InvocationHandler中invoke方法参数说明：</span></span><br><span class="line"><span class="comment">                            proxy ： 代理对象</span></span><br><span class="line"><span class="comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">使用了动态代理，我们思考下面问题：</font></p><ul><li><p>ProxyFactory是代理类吗？</p><p>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.proxy.dynamic.jdk.SellTickets;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的类中，我们可以看到以下几个信息：</p><ul><li>代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li><li>代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。</li></ul></li><li><p>动态代理的执行流程是什么样？</p><p>下面是摘取的重点代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行流程如下：</p><pre><code>1. 在测试类中通过代理对象调用sell()方法2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</code></pre><h3 id="cglib动态代理">5.1.5 CGLIB动态代理</h3><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p><p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p><p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args ： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy ：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种代理的对比">5.1.6 三种代理的对比</h3><ul><li><p>jdk代理和CGLIB代理</p><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p><p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p></li><li><p>动态代理和静态代理</p><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p><p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p></li></ul><h3 id="优缺点-4">5.1.7 优缺点</h3><p><strong>优点：</strong></p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂度；</li></ul><h3 id="使用场景-3">5.1.8 使用场景</h3><ul><li><p>远程（Remote）代理</p><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p></li><li><p>防火墙（Firewall）代理</p><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p></li><li><p>保护（Protect or Access）代理</p><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p></li></ul><h2 id="适配器模式">5.2 适配器模式</h2><h3 id="概述-4">5.2.1 概述</h3><p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241195.png" /></p><p><strong>定义：</strong></p><p>​将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>​适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h3 id="结构-6">5.2.2 结构</h3><p>适配器模式（Adapter）包含以下主要角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h3 id="类适配器模式">5.2.3 类适配器模式</h3><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>【例】读卡器</p><p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241193.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p><h3 id="对象适配器模式">5.2.4 对象适配器模式</h3><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p><p>【例】读卡器</p><p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241190.png" style="zoom:80%;" /></p><p>代码如下：</p><p>类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span>  <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter，实现所有方法。而此时我们只需要继承该抽象类即可。</p></blockquote><h3 id="应用场景">5.2.5 应用场景</h3><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h3 id="jdk源码解析">5.2.6 JDK源码解析</h3><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。</p><p>InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241198.png" /></p><p>从上图可以看出：</p><ul><li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装。</li><li>StreamDecoder不是Java SE API中的内容，是SunJDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li></ul><p><font color="red">结论：</font></p><p>​从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上SunJDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。</p><h2 id="装饰者模式">5.3 装饰者模式</h2><h3 id="概述-5">5.3.1 概述</h3><p>我们先来看一个快餐店的例子。</p><p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p><img src="D:\传智播客\专题\设计模式\成品\笔记\assets\装饰者模式-使用前.png" style="zoom:80%;" /></p><p>使用继承的方式存在的问题：</p><ul><li><p>扩展性不好</p><p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p></li><li><p>产生过多的子类</p></li></ul><p><strong>定义：</strong></p><p>​指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p><h3 id="结构-7">5.3.2 结构</h3><p>装饰（Decorator）模式中的角色：</p><ul><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色 ：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ul><h3 id="案例-1">5.3.3 案例</h3><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241212.png" style="zoom:75%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快餐接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">(<span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;  <span class="comment">//获取价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FastFood <span class="title function_">getFastFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFastFood</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(price,desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">1</span>,<span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">2</span>,<span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line"></span><br><span class="line">        food1 = <span class="keyword">new</span> <span class="title class_">Egg</span>(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedNoodles</span>();</span><br><span class="line">        food2 = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><ul><li><p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p></li><li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li></ul><h3 id="使用场景-4">5.3.4 使用场景</h3><ul><li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p></li><li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p></li></ul><h3 id="jdk源码解析-1">5.3.5 JDK源码解析</h3><p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p><p>我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建BufferedWriter对象</span></span><br><span class="line">        <span class="comment">//创建FileWriter对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;hello Buffered&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来感觉确实像是装饰者模式，接下来看它们的结构：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241661.png" style="zoom:80%;" /></p><blockquote><p><font color="red">小结：</font></p><p>​BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。</p></blockquote><h3 id="代理和装饰者的区别">5.3.6 代理和装饰者的区别</h3><p>静态代理和装饰者模式的区别：</p><ul><li>相同点：<ul><li>都要实现与目标类相同的业务接口</li><li>在两个类中都要声明目标对象</li><li>都可以在不修改目标类的前提下增强目标方法</li></ul></li><li>不同点：<ul><li>目的不同 装饰者是为了增强目标对象静态代理是为了保护和隐藏目标对象</li><li>获取目标对象构建的地方不同装饰者是由外界传递进来，可以通过构造方法传递静态代理是在代理类内部创建，以此来隐藏目标对象</li></ul></li></ul><h2 id="桥接模式">5.4 桥接模式</h2><h3 id="概述-6">5.4.1 概述</h3><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241810.png" /></p><p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p><p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p><p><strong>定义：</strong></p><p>​将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><h3 id="结构-8">5.4.2 结构</h3><p>桥接（Bridge）模式包含以下主要角色：</p><ul><li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li></ul><h3 id="案例-2">5.4.3 案例</h3><p>【例】视频播放器</p><p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241897.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视频文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avi文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVIFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件：&quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmvb文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">REVBBFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作系统版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Windows</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mac版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mac</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>(<span class="keyword">new</span> <span class="title class_">AVIFile</span>());</span><br><span class="line">        os.play(<span class="string">&quot;战狼3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><ul><li><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p><p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p></li><li><p>实现细节对客户透明</p></li></ul><h3 id="使用场景-5">5.4.4 使用场景</h3><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li></ul><h2 id="外观模式">5.5 外观模式</h2><h3 id="概述-7">5.5.1 概述</h3><p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。</p><p><strong>定义：</strong></p><p>​又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>​ 外观（Facade）模式是“迪米特法则”的典型应用</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241938.jpg" /></p><h3 id="结构-9">5.5.2 结构</h3><p>外观（Facade）模式包含以下主要角色：</p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（SubSystem）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li></ul><h3 id="案例-3">5.5.3 案例</h3><p>【例】智能家电控制</p><p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241260.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//灯类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能音箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAppliancesFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartAppliancesFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        airCondition = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(message.contains(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(message.contains(<span class="string">&quot;关闭&quot;</span>)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我还听不懂你说的！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起床后一键开电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床了&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//睡觉一键关电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建外观对象</span></span><br><span class="line">        <span class="type">SmartAppliancesFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartAppliancesFacade</span>();</span><br><span class="line">        <span class="comment">//客户端直接与外观对象进行交互</span></span><br><span class="line">        facade.say(<span class="string">&quot;打开家电&quot;</span>);</span><br><span class="line">        facade.say(<span class="string">&quot;关闭家电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li></ul><p><strong>缺点：</strong></p><ul><li>不符合开闭原则，修改很麻烦</li></ul><h3 id="使用场景-6">5.5.4 使用场景</h3><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ul><h3 id="源码解析">5.5.5 源码解析</h3><p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241299.png" style="zoom:60%;" /></p><p>RequestFacade类就使用了外观模式。先看结构图：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111241502.png" style="zoom:70%;" /></p><p><strong>为什么在此处使用外观模式呢？</strong></p><p>​ 定义 RequestFacade 类，分别实现 ServletRequest，同时定义私有成员变量 Request ，并且方法的实现调用 Request的实现。然后，将 RequestFacade上转为 ServletRequest 传给 servlet 的service 方法，这样即使在 servlet 中被下转为 RequestFacade，也不能访问私有成员变量对象中的方法。既用了 Request，又能防止其中方法被不合理的访问。</p><h1 id="结构型模式-1">5，结构型模式</h1><h2 id="组合模式">5.6 组合模式</h2><h3 id="概述-8">5.6.1 概述</h3><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242872.png" style="zoom:60%;" /></p><p>​对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。</p><p><strong>定义：</strong></p><p>​又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><h3 id="结构-10">5.6.2 结构</h3><p>组合模式主要包含三种角色：</p><ul><li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li><li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li><li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li></ul><h3 id="案例实现">5.6.3 案例实现</h3><p>【例】软件菜单</p><p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242869.png" style="zoom:80%;" /></p><p>要实现该案例，我们先画出类图：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242871.png" style="zoom:80%;" /></p><p><strong>代码实现：</strong></p><p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的子菜单</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取菜单名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MenuComponent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name,<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p><h3 id="组合模式的分类">5.6.4 组合模式的分类</h3><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p><ul><li><p>透明组合模式</p><p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中<code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code>、<code>getChild</code>方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p><p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供add()、remove()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p></li><li><p>安全组合模式</p><p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点<code>Menu</code>类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242867.png" style="zoom:80%;" /></p></li></ul><h3 id="优点">5.6.5 优点</h3><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul><h3 id="使用场景-7">5.6.6 使用场景</h3><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p><h2 id="享元模式">5.7 享元模式</h2><h3 id="概述-9">5.7.1 概述</h3><p><strong>定义：</strong></p><p>​运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><h3 id="结构-11">5.7.2 结构</h3><p>享元（Flyweight ）模式中存在以下两种状态：</p><ol type="1"><li>内部状态，即不会随着环境的改变而改变的可共享部分。</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li></ol><p>享元模式的主要有以下角色：</p><ul><li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>具体享元（Concrete Flyweight）角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li>非享元（Unsharable Flyweight)角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul><h3 id="案例实现-1">5.7.3 案例实现</h3><p>【例】俄罗斯方块</p><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242866.jpeg" style="zoom:60%;" /></p><p><strong>先来看类图：</strong></p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242885.png" style="zoom:80%;" /></p><p><strong>代码如下：</strong></p><p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="built_in">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, AbstractBox&gt;();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">iBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">lBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">oBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OBox</span>();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BoxFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点和使用场景">5.7.5 优缺点和使用场景</h3><p><strong>1，优点</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li><li>享元模式中的外部状态相对独立，且不影响内部状态</li></ul><p><strong>2，缺点：</strong></p><p>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p><p><strong>3，使用场景：</strong></p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h3 id="jdk源码解析-2">5.7.6 JDK源码解析</h3><p>Integer类使用了享元模式。我们先看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i1和i2对象是否是同一个对象？&quot;</span> + (i1 == i2));</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i3和i4对象是否是同一个对象？&quot;</span> + (i3 == i4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面代码，结果如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242484.png" style="zoom:80%;" /></p><p>为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf((<span class="type">int</span>)<span class="number">127</span>);</span><br><span class="line">        Integer i2 Integer.valueOf((<span class="type">int</span>)<span class="number">127</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append((String)<span class="string">&quot;i1\u548ci2\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="type">boolean</span>)(i1 == i2)).toString());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> Integer.valueOf((<span class="type">int</span>)<span class="number">128</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> Integer.valueOf((<span class="type">int</span>)<span class="number">128</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append((String)<span class="string">&quot;i3\u548ci4\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="type">boolean</span>)(i3 == i4)).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是<code>valueOf()</code> ，所以只需要看该方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Integer</code> 默认先创建并缓存<code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用<code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code>之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code>对象。</p><h1 id="行为型模式">6，行为型模式</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式分为：</p><ul><li>模板方法模式</li><li>策略模式</li><li>命令模式</li><li>职责链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul><p>以上 11种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p><h2 id="模板方法模式">6.1 模板方法模式</h2><h3 id="概述-10">6.1.1 概述</h3><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><p><strong>定义：</strong></p><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><h3 id="结构-12">6.1.2 结构</h3><p>模板方法（Template Method）模式包含以下主要角色：</p><ul><li><p>抽象类（AbstractClass）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p><ul><li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p></li><li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p><ul><li><p>抽象方法(Abstract Method)：一个抽象方法由抽象类声明、由其具体子类实现。</p></li><li><p>具体方法(Concrete Method)：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p></li><li><p>钩子方法(Hook Method)：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p></li></ul></li></ul></li><li><p>具体子类（ConcreteClass）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p></li></ul><h3 id="案例实现-2">6.1.3 案例实现</h3><p>【例】炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242524.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="built_in">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="built_in">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="built_in">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="built_in">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="built_in">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        <span class="type">ConcreteClass_BaoCai</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_BaoCai</span>();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        <span class="type">ConcreteClass_CaiXin</span> <span class="variable">caiXin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_CaiXin</span>();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p></blockquote><h3 id="优缺点-5">6.1.3 优缺点</h3><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合“开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h3 id="适用场景">6.1.4 适用场景</h3><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul><h3 id="jdk源码解析-3">6.1.5 JDK源码解析</h3><p>InputStream类就使用了模板方法模式。在InputStream类中定义了多个<code>read()</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="comment">//抽象方法，要求子类必须重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> read(); <span class="comment">//调用了无参的read方法，该方法是每次读取一个字节数据</span></span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off] = (<span class="type">byte</span>)c;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">                c = read();</span><br><span class="line">                <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b[off + i] = (<span class="type">byte</span>)c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，无参的 <code>read()</code>方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code>方法调用了 <code>read(byte b[], int off, int len)</code>方法，所以在此处重点看的方法是带三个参数的方法。</p><p>在该方法中第18行、27行，可以看到调用了无参的抽象的<code>read()</code> 方法。</p><p>总结如下：在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p><h2 id="策略模式">6.2 策略模式</h2><h3 id="概述-11">6.2.1 概述</h3><p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242550.png" style="zoom:80%;" /></p><p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242590.png" style="zoom:70%;" /></p><p><strong>定义：</strong></p><p>​该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><h3 id="结构-13">6.2.2 结构</h3><p>策略模式的主要角色如下：</p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（ConcreteStrategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><h3 id="案例实现-3">6.2.3 案例实现</h3><p>【例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242617.png" style="zoom:80%;" /></p><p>代码如下：</p><p>定义百货公司所有促销活动的共同接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure><h3 id="优缺点-6">6.2.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p></li><li><p>避免使用多重条件选择语句（ifelse），充分体现面向对象设计思想。</p></li></ul><p><strong>2，缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="使用场景-8">6.2.5 使用场景</h3><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h3 id="jdk源码解析-4">6.2.6 JDK源码解析</h3><p><code>Comparator</code> 中的策略模式。在Arrays类中有一个<code>sort()</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Integer[] data = &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 实现降序排序</span></span><br><span class="line">        Arrays.sort(data, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(data)); <span class="comment">//[12, 5, 4, 3, 2, 2, 1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的<code>compare()</code> 方法吗？让我们继续查看TimSort类的<code>sort()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimSort</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, <span class="type">int</span> lo, <span class="type">int</span> hi, Comparator&lt;? <span class="built_in">super</span> T&gt; c,</span></span><br><span class="line"><span class="params">                         T[] work, <span class="type">int</span> workBase, <span class="type">int</span> workLen)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="literal">null</span> &amp;&amp; a != <span class="literal">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nRemaining</span>  <span class="operator">=</span> hi - lo;</span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If array is small, do a &quot;mini-TimSort&quot; with no merges</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">initRunLen</span> <span class="operator">=</span> countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="type">int</span> lo, <span class="type">int</span> hi,Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">        <span class="type">int</span> <span class="variable">runHi</span> <span class="operator">=</span> lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// Descending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">            reverseRange(a, lo, runHi);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// Ascending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> runHi - lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中最终会跑到 <code>countRunAndMakeAscending()</code>这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。</p><h2 id="命令模式">6.3 命令模式</h2><h3 id="概述-12">6.3.1 概述</h3><p>日常生活中，我们出去吃饭都会遇到下面的场景。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242659.png" style="zoom:60%;" /></p><p><strong>定义：</strong></p><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p><h3 id="结构-14">6.3.2 结构</h3><p>命令模式包含以下主要角色：</p><ul><li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li><li>具体命令（ConcreteCommand）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）角色：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li><li>调用者/请求者（Invoker）角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li></ul><h3 id="案例实现-4">6.3.3 案例实现</h3><p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p><p>服务员： 就是调用者角色，由她来发起命令。</p><p>资深大厨： 就是接收者角色，真正命令执行的对象。</p><p>订单： 命令中包含订单。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242067.png" style="zoom:75%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;<span class="comment">//只需要定义一个统一的执行方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有接受者对象</span></span><br><span class="line">    <span class="keyword">private</span> SeniorChef receiver;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCommand</span><span class="params">(SeniorChef receiver, Order order)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>  &#123;</span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的订单：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = order.getFoodDic().keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            receiver.makeFood(order.getFoodDic().get(key),key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);<span class="comment">//停顿一下 模拟做饭的过程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的饭弄好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// 餐桌号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> diningTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存储餐名并记录份数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDiningTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDiningTable</span><span class="params">(<span class="type">int</span> diningTable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.diningTable = diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getFoodDic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foodDic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoodDic</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        foodDic.put(name,num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资深大厨类 是命令的Receiver</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeniorChef</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">(<span class="type">int</span> num,String foodName)</span> &#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot;份&quot;</span> + foodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Command&gt; commands;<span class="comment">//可以持有很多的命令对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Waitor</span><span class="params">()</span> &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command cmd)</span>&#123;</span><br><span class="line">        commands.add(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发出命令 喊 订单来了，厨师开始执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderUp</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;美女服务员：叮咚，大厨，新订单来了.......&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            <span class="type">Command</span> <span class="variable">cmd</span> <span class="operator">=</span> commands.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">                cmd.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建2个order</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order1.setDiningTable(<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;西红柿鸡蛋面&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;小杯可乐&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order2.setDiningTable(<span class="number">3</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;尖椒肉丝盖饭&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;小杯雪碧&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建接收者</span></span><br><span class="line">        SeniorChef receiver=<span class="keyword">new</span> <span class="title class_">SeniorChef</span>();</span><br><span class="line">        <span class="comment">//将订单和接收者封装成命令对象</span></span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order1);</span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order2);</span><br><span class="line">        <span class="comment">//创建调用者 waitor</span></span><br><span class="line">        <span class="type">Waitor</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waitor</span>();</span><br><span class="line">        invoker.setCommand(cmd1);</span><br><span class="line">        invoker.setCommand(cmd2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将订单带到柜台 并向厨师喊 订单来了</span></span><br><span class="line">        invoker.orderUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-7">6.3.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li></ul><p><strong>2，缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。</li><li>系统结构更加复杂。</li></ul><h3 id="使用场景-9">6.3.5 使用场景</h3><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li></ul><h3 id="jdk源码解析-5">6.3.6 JDK源码解析</h3><p>Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令接口(抽象命令角色)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk Runnable 命令模式</span></span><br><span class="line"><span class="comment"> *TurnOffThread ： 属于具体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurnOffThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">TurnOffThread</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     receiver.turnOFF();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">         <span class="type">TurnOffThread</span> <span class="variable">turnOffThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurnOffThread</span>(receiver);</span><br><span class="line">         <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(turnOffThread);</span><br><span class="line">         thread.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="责任链模式">6.4 责任链模式</h2><h3 id="概述-13">6.4.1 概述</h3><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p><p><strong>定义：</strong></p><p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><h3 id="结构-15">6.4.2 结构</h3><p>职责链模式主要包含以下角色:</p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（ConcreteHandler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><h3 id="案例实现-5">6.4.3 案例实现</h3><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242171.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领导上面还有领导</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围 上不封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置上级领导</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交请假条</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果请假天数达到该领导者的处理要求</span></span><br><span class="line">        <span class="keyword">if</span>(leave.getNum() &gt;= <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;</span><br><span class="line">                <span class="built_in">this</span>.nextHandler.submit(leave);<span class="comment">//继续提交</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各级领导处理请假条方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//请假条来一张</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-8">6.4.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p><p>该模式降低了请求发送者和接收者的耦合度。</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则。</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的if 或者 if···else 语句。</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p></li></ul><p><strong>2，缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><h3 id="源码解析-1">6.4.5 源码解析</h3><p>在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析:</p><ul><li><p>模拟web请求Request以及web响应Response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Request</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Response</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟web过滤器Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Request req,Response res,FilterChain c)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟实现具体过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器1 前置处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先执行所有request再倒序执行所有response</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器1 后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondFilter</span>  <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器2 前置处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先执行所有request再倒序执行所有response</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器2 后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟实现过滤器链FilterChain</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Filter&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">public</span> FilterChain <span class="title function_">addFilter</span><span class="params">(Filter filter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Request request, Response response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == filters.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filters.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Request</span>  <span class="variable">req</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Response</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">FilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterChain</span>();</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">FirstFilter</span>()).addFilter(<span class="keyword">new</span> <span class="title class_">SecondFilter</span>());</span><br><span class="line">        filterChain.doFilter(req,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="行为型模式-1">6，行为型模式</h1><h2 id="状态模式">6.5 状态模式</h2><h3 id="概述-14">6.5.1 概述</h3><p>【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242157.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILift</span> &#123;</span><br><span class="line">    <span class="comment">//电梯的4个状态</span></span><br><span class="line">    <span class="comment">//开门状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">OPENING_STATE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//关门状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">CLOSING_STATE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//运行状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RUNNING_STATE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//停止状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STOPPING_STATE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置电梯的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯的动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lift</span> <span class="keyword">implements</span> <span class="title class_">ILift</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行关门动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯关门了。。。&quot;</span>);<span class="comment">//只有开门状态可以关闭电梯门，可以对应电梯状态表来看</span></span><br><span class="line">                <span class="built_in">this</span>.setState(CLOSING_STATE);<span class="comment">//关门之后电梯就是关闭状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                <span class="comment">//do nothing //已经是关门状态，不能关门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">//do nothing //运行时电梯门是关着的，不能关门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">//do nothing //停止时电梯也是关着的，不能关门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行开门动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:<span class="comment">//门已经开了，不能再开门了</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:<span class="comment">//关门状态，门打开:</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯门打开了。。。&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">//do nothing 运行时电梯不能开门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯门开了。。。&quot;</span>);<span class="comment">//电梯停了，可以开门了</span></span><br><span class="line">                <span class="built_in">this</span>.setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行运行动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:<span class="comment">//电梯不能开着门就走</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:<span class="comment">//门关了，可以运行了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯开始运行了。。。&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(RUNNING_STATE);<span class="comment">//现在是运行状态</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">//do nothing 已经是运行状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯开始运行了。。。&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(RUNNING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行停止动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//开门的电梯已经是是停止的了(正常情况下)</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:<span class="comment">//关门时才可以停止</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯停止了。。。&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:<span class="comment">//运行时当然可以停止了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯停止了。。。&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lift</span> <span class="variable">lift</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lift</span>();</span><br><span class="line">        lift.setState(ILift.STOPPING_STATE);<span class="comment">//电梯是停止的</span></span><br><span class="line">        lift.open();<span class="comment">//开门</span></span><br><span class="line">        lift.close();<span class="comment">//关门</span></span><br><span class="line">        lift.run();<span class="comment">//运行</span></span><br><span class="line">        lift.stop();<span class="comment">//停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题分析：</p><ul><li>使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。</li><li>扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑</li></ul><p><strong>定义：</strong></p><p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><h3 id="结构-16">6.5.2 结构</h3><p>状态模式包含以下主要角色。</p><ul><li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为。</li></ul><h3 id="案例实现-6">6.5.3 案例实现</h3><p>对上述电梯的案例使用状态模式进行改进。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242159.png" style="zoom:70%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个环境角色，也就是封装状态的变化引起的功能变化</span></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯开门动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯关门动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯运行动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯停止动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenningState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启当然可以关闭了，我就想测试一下电梯门开关功能</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门开启...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门不能开着就跑，这里什么也不做</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开门状态已经是停止的了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunningState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行的时候开电梯门？你疯了！电梯不会给你开的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关闭？这是肯定了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;<span class="comment">//虽然可以关门，但这个动作不归我执行</span></span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是在运行状态下要实现的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="built_in">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoppingState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态，开门，那是要的！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;<span class="comment">//虽然可以关门，但这个动作不归我执行</span></span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态再跑起来，正常的很</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态是怎么发生的呢？当然是停止方法执行了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯停止了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClosingState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//电梯门关闭，这是关闭状态要实现的动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门关闭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关了再打开，逗你玩呢，那这个允许呀</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="built_in">super</span>.context.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关了就跑，这是再正常不过了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="built_in">super</span>.context.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关着，我就不按楼层</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="built_in">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="comment">//定义出所有的电梯状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">OpenningState</span> <span class="variable">openningState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenningState</span>();<span class="comment">//开门状态，这时候电梯只能关闭</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ClosingState</span> <span class="variable">closeingState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClosingState</span>();<span class="comment">//关闭状态，这时候电梯可以运行、停止和开门</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">RunningState</span> <span class="variable">runningState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunningState</span>();<span class="comment">//运行状态，这时候电梯只能停止</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">StoppingState</span> <span class="variable">stoppingState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoppingState</span>();<span class="comment">//停止状态，这时候电梯可以开门、运行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个当前电梯状态</span></span><br><span class="line">    <span class="keyword">private</span> LiftState liftState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiftState <span class="title function_">getLiftState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.liftState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLiftState</span><span class="params">(LiftState liftState)</span> &#123;</span><br><span class="line">        <span class="comment">//当前环境改变</span></span><br><span class="line">        <span class="built_in">this</span>.liftState = liftState;</span><br><span class="line">        <span class="comment">//把当前的环境通知到各个实现类中</span></span><br><span class="line">        <span class="built_in">this</span>.liftState.setContext(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        context.setLiftState(<span class="keyword">new</span> <span class="title class_">ClosingState</span>());</span><br><span class="line"></span><br><span class="line">        context.open();</span><br><span class="line">        context.close();</span><br><span class="line">        context.run();</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-9">6.5.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li></ul><p><strong>2，缺点：</strong></p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对”开闭原则”的支持并不太好。</li></ul><h3 id="使用场景-10">6.5.5 使用场景</h3><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><h2 id="观察者模式">6.6 观察者模式</h2><h3 id="概述-15">6.6.1 概述</h3><p><strong>定义：</strong></p><p>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><h3 id="结构-17">6.6.2 结构</h3><p>在观察者模式中有如下角色：</p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><h3 id="案例实现-7">6.6.3 案例实现</h3><p>【例】微信公众号</p><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242161.png" style="zoom:80%;" /></p><p>代码如下：</p><p>定义抽象观察者类，里面定义一个更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeixinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象主题类，提供了attach、detach、notify三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;猪悟能&quot;</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;沙悟净&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;传智黑马的专栏更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优缺点-10">6.6.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p><strong>2，缺点：</strong></p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><h3 id="使用场景-11">6.6.5 使用场景</h3><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li></ul><h3 id="jdk中提供的实现">6.6.6 JDK中提供的实现</h3><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p><p><strong>1，Observable类</strong></p><p>Observable 类是抽象目标类（被观察者），它有一个 Vector集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3个方法。</p><ul><li><p>void addObserver(Observer o)方法：用于将新的观察者对象添加到集合中。</p></li><li><p>void notifyObservers(Object arg)方法：调用集合中的所有观察者对象的update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</p></li><li><p>void setChange() 方法：用来设置一个 boolean类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers()才会通知观察者。</p></li></ul><p><strong>2，Observer 接口</strong></p><p>Observer接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用update 方法，进行相应的工作。</p><p>【例】警察抓小偷</p><p>警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：</p><p>小偷是一个被观察者，所以需要继承Observable类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thief</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thief</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">steal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小偷：我偷东西了，有没有人来抓我！！！&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setChanged(); <span class="comment">//changed  = true</span></span><br><span class="line">        <span class="built_in">super</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>警察是一个观察者，所以需要让其实现Observer接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Policemen</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Policemen</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;警察：&quot;</span> + ((Thief) o).getName() + <span class="string">&quot;，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建小偷对象</span></span><br><span class="line">        <span class="type">Thief</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thief</span>(<span class="string">&quot;隔壁老王&quot;</span>);</span><br><span class="line">        <span class="comment">//创建警察对象</span></span><br><span class="line">        <span class="type">Policemen</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Policemen</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        <span class="comment">//让警察盯着小偷</span></span><br><span class="line">        t.addObserver(p);</span><br><span class="line">        <span class="comment">//小偷偷东西</span></span><br><span class="line">        t.steal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中介者模式">6.7 中介者模式</h2><h3 id="概述-16">6.7.1 概述</h3><p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p><p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242163.png" style="zoom:60%;" /></p><p><strong>定义：</strong></p><p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p><h3 id="结构-18">6.7.2 结构</h3><p>中介者模式包含以下主要角色：</p><ul><li><p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p></li><li><p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p></li><li><p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p></li><li><p>具体同事类（ConcreteColleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p></li></ul><h3 id="案例实现-8">6.7.3 案例实现</h3><p>【例】租房</p><p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p><p>类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242171.png" style="zoom:70%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">//申明一个联络方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message,Person person)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,Mediator mediator)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类 房屋拥有者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseOwner</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseOwner</span><span class="params">(String name, Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与中介者联系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        mediator.constact(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房主&quot;</span> + name +<span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类 承租人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tenant</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tenant</span><span class="params">(String name, Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与中介者联系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        mediator.constact(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;租房者&quot;</span> + name +<span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中介机构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediatorStructure</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">//首先中介结构必须知道所有房主和租房者的信息</span></span><br><span class="line">    <span class="keyword">private</span> HouseOwner houseOwner;</span><br><span class="line">    <span class="keyword">private</span> Tenant tenant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HouseOwner <span class="title function_">getHouseOwner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHouseOwner</span><span class="params">(HouseOwner houseOwner)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseOwner = houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Tenant <span class="title function_">getTenant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTenant</span><span class="params">(Tenant tenant)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tenant = tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message, Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (person == houseOwner) &#123;          <span class="comment">//如果是房主，则租房者获得信息</span></span><br><span class="line">            tenant.getMessage(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;       <span class="comment">//反正则是房主获得信息</span></span><br><span class="line">            houseOwner.getMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//一个房主、一个租房者、一个中介机构</span></span><br><span class="line">        <span class="type">MediatorStructure</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediatorStructure</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//房主和租房者只需要知道中介机构即可</span></span><br><span class="line">        <span class="type">HouseOwner</span> <span class="variable">houseOwner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseOwner</span>(<span class="string">&quot;张三&quot;</span>, mediator);</span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tenant</span>(<span class="string">&quot;李四&quot;</span>, mediator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中介结构要知道房主和租房者</span></span><br><span class="line">        mediator.setHouseOwner(houseOwner);</span><br><span class="line">        mediator.setTenant(tenant);</span><br><span class="line"></span><br><span class="line">        tenant.constact(<span class="string">&quot;需要租三室的房子&quot;</span>);</span><br><span class="line">        houseOwner.constact(<span class="string">&quot;我这有三室的房子，你需要租吗？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-11">6.7.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li><p>松散耦合</p><p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p></li><li><p>集中控制交互</p><p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p></li><li><p>一对多关联转变为一对一的关联</p><p>没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</p></li></ul><p><strong>2，缺点：</strong></p><p>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p><h3 id="使用场景-12">6.7.5 使用场景</h3><ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li></ul><h2 id="迭代器模式">6.8 迭代器模式</h2><h3 id="概述-17">6.8.1 概述</h3><p><strong>定义：</strong></p><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p><h3 id="结构-19">6.8.2 结构</h3><p>迭代器模式主要包含以下角色：</p><ul><li><p>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</p></li><li><p>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p></li><li><p>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含hasNext()、next() 等方法。</p></li><li><p>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p></li></ul><h3 id="案例实现-9">6.8.3 案例实现</h3><p>【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242181.png" style="zoom:90%;" /></p><p>代码如下：</p><p>定义迭代器接口，声明hasNext、next方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的迭代器类，重写所有的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">currentStudent</span> <span class="operator">=</span> list.get(position);</span><br><span class="line">        position ++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的容器类，重写所有的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();  <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentIteratorImpl</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-12">6.8.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则” 的要求。</li></ul><p><strong>2，缺点：</strong></p><p>增加了类的个数，这在一定程度上增加了系统的复杂性。</p><h3 id="使用场景-13">6.8.5 使用场景</h3><ul><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li></ul><h3 id="jdk源码解析-6">6.8.6 JDK源码解析</h3><p>迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator(); <span class="comment">//list.iterator()方法返回的肯定是Iterator接口的子实现类对象</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明</p><ul><li>List：抽象聚合类</li><li>ArrayList：具体的聚合类</li><li>Iterator：抽象迭代器</li><li>list.iterator()：返回的是实现了 <code>Iterator</code>接口的具体迭代器对象</li></ul><p>具体的来看看 ArrayList的代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor;       <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 上一个返回元素的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否还有元素</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取下一个元素</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码还是比较简单，大致就是在 <code>iterator</code>方法中返回了一个实例化的 <code>Iterator</code>对象。Itr是一个内部类，它实现了 <code>Iterator</code>接口并重写了其中的抽象方法。</p><blockquote><p>注意：</p><p>​当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现<code>java.util.Iterable</code>并实现其中的iterator()方法使其返回一个<code>java.util.Iterator</code> 的实现类就可以了。</p></blockquote><h2 id="访问者模式">6.9 访问者模式</h2><h3 id="概述-18">6.9.1 概述</h3><p><strong>定义：</strong></p><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p><h3 id="结构-20">6.9.2 结构</h3><p>访问者模式包含以下主要角色:</p><ul><li>抽象访问者（Visitor）角色：定义了对每一个元素<code>（Element）</code>访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。</li><li>具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。</li><li>抽象元素（Element）角色：定义了一个接受访问者的方法（<code>accept</code>），其意义是指，每一个元素都要可以被访问者访问。</li><li>具体元素（ConcreteElement）角色：提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li><li>对象结构（ObjectStructure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（<code>Element</code>），并且可以迭代这些元素，供访问者访问。</li></ul><h3 id="案例实现-10">6.9.3 案例实现</h3><p>【例】给宠物喂食</p><p>现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p><ul><li>访问者角色：给宠物喂食的人</li><li>具体访问者角色：主人、其他人</li><li>抽象元素角色：动物抽象类</li><li>具体元素角色：宠物狗、宠物猫</li><li>结构对象角色：主人家</li></ul><p>类图如下：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242577.png" /></p><p>代码如下：</p><p>创建抽象访问者接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建不同的具体访问者角色（主人和其他人），都需要实现<code>Person</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Someone</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象节点 – 宠物</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义实现<code>Animal</code>接口的 具体节点（元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;好好吃，汪汪汪！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;好好吃，喵喵喵！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义对象结构，此案例中就是主人的家</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal node : nodeList) &#123;</span><br><span class="line">            node.accept(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Home</span> <span class="variable">home</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Home</span>();</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>();</span><br><span class="line">        home.action(owner);</span><br><span class="line"></span><br><span class="line">        <span class="type">Someone</span> <span class="variable">someone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Someone</span>();</span><br><span class="line">        home.action(someone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-13">6.9.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li><p>扩展性好</p><p>在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p></li><li><p>复用性好</p><p>通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</p></li><li><p>分离无关行为</p><p>通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</p></li></ul><p><strong>2，缺点：</strong></p><ul><li><p>对象结构变化很困难</p><p>在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</p></li><li><p>违反了依赖倒置原则</p><p>访问者模式依赖了具体类，而没有依赖抽象类。</p></li></ul><h3 id="使用场景-14">6.9.5 使用场景</h3><ul><li><p>对象结构相对稳定，但其操作算法经常变化的程序。</p></li><li><p>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</p></li></ul><h3 id="扩展-1">6.9.6 扩展</h3><p>访问者模式用到了一种双分派的技术。</p><p><strong>1，分派：</strong></p><p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如<code>Map map = new HashMap()</code> ，map变量的静态类型是<code>Map</code> ，实际类型是 <code>HashMap</code>。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。</p><p><strong>静态分派(Static Dispatch)</strong>发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p><p><strong>动态分派(Dynamic Dispatch)</strong>发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。</p><p><strong>2，动态分派：</strong></p><p>通过方法的重写支持动态分派。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        a.execute();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。</p><p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p><p><strong>3，静态分派：</strong></p><p>通过方法重载支持静态分派。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Execute</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Cat c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Execute</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Execute</span>();</span><br><span class="line">        exe.execute(a);</span><br><span class="line">        exe.execute(a1);</span><br><span class="line">        exe.execute(a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242604.png" style="zoom:70%;" /></p><p>这个结果可能出乎一些人的意料了，为什么呢？</p><p><strong>重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</strong></p><p><strong>4，双分派：</strong></p><p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> &#123;</span><br><span class="line">        exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> &#123;</span><br><span class="line">        exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> &#123;</span><br><span class="line">        exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Execute</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Cat c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Execute</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Execute</span>();</span><br><span class="line">        a.accept(exe);</span><br><span class="line">        d.accept(exe);</span><br><span class="line">        c.accept(exe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也<code>将自己this作为参数传递进去，这里就完成了第二次分派</code>，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。</p><p>说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。</p><p>运行结果如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242679.png" style="zoom:67%;" /></p><p><strong>双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。</strong></p><h2 id="备忘录模式">6.10 备忘录模式</h2><h3 id="概述-19">6.10.1 概述</h3><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p><p><strong>定义：</strong></p><p>又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p><h3 id="结构-21">6.10.2 结构</h3><p>备忘录模式的主要角色如下：</p><ul><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><blockquote><p>备忘录有两个等效的接口：</p><ul><li><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narrorInterface)，这个窄接口只允许他把备忘录对象传给其他的对象。</li><li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wideInterface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li></ul></blockquote><h3 id="案例实现-11">6.10.3 案例实现</h3><p>【例】游戏挑战BOSS</p><p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p><p>要实现上述案例，有两种方式：</p><ul><li>“白箱”备忘录模式</li><li>“黑箱”备忘录模式</li></ul><h4 id="白箱备忘录模式">6.10.3.1 “白箱”备忘录模式</h4><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242713.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//游戏角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRole</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="keyword">public</span> RoleStateMemento <span class="title function_">saveState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleStateMemento</span>(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverState</span><span class="params">(RoleStateMemento roleStateMemento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="built_in">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="built_in">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏状态存储类(备忘录类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateMemento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">(<span class="type">int</span> vit, <span class="type">int</span> atk, <span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//角色状态管理者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateCaretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RoleStateMemento roleStateMemento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RoleStateMemento <span class="title function_">getRoleStateMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roleStateMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoleStateMemento</span><span class="params">(RoleStateMemento roleStateMemento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.roleStateMemento = roleStateMemento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss前------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss前</span></span><br><span class="line">        <span class="type">GameRole</span> <span class="variable">gameRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRole</span>();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存进度</span></span><br><span class="line">        <span class="type">RoleStateCaretaker</span> <span class="variable">roleStateCaretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleStateCaretaker</span>();</span><br><span class="line">        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss后------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss时，损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------恢复之前状态------------&quot;</span>);</span><br><span class="line">        <span class="comment">//恢复之前状态</span></span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。</p></blockquote><h4 id="黑箱备忘录模式">6.10.3.2 “黑箱”备忘录模式</h4><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将<strong>备忘录类</strong>设计成<strong>发起人类</strong>的内部成员类。</p><p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code>的内部类，从而将 <code>RoleStateMemento</code> 对象封装在<code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code>给 <code>RoleStateCaretaker</code> 及其他对象使用。这样<code>GameRole</code> 类看到的是 <code>RoleStateMemento</code>所有的接口，而<code>RoleStateCaretaker</code>及其他对象看到的仅仅是标识接口 <code>Memento</code>所暴露出来的接口，从而维护了封装型。类图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111242292.png" style="zoom:70%;" /></p><p>代码如下：</p><p>窄接口<code>Memento</code>，这是一个标识接口，因此没有定义出任何的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义发起人类 <code>GameRole</code>，并在内部定义备忘录内部类<code>RoleStateMemento</code>（该内部类设置为私有的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">/游戏角色类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRole</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">saveState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleStateMemento</span>(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverState</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="type">RoleStateMemento</span> <span class="variable">roleStateMemento</span> <span class="operator">=</span> (RoleStateMemento) memento;</span><br><span class="line">        <span class="built_in">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="built_in">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="built_in">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">RoleStateMemento</span> <span class="keyword">implements</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> vit;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> atk;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> def;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">(<span class="type">int</span> vit, <span class="type">int</span> atk, <span class="type">int</span> def)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.vit = vit;</span><br><span class="line">            <span class="built_in">this</span>.atk = atk;</span><br><span class="line">            <span class="built_in">this</span>.def = def;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> vit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.vit = vit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> atk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.atk = atk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> def;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.def = def;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负责人角色类 <code>RoleStateCaretaker</code> 能够得到的备忘录对象是以<code>Memento</code>为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//角色状态管理者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateCaretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss前------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss前</span></span><br><span class="line">        <span class="type">GameRole</span> <span class="variable">gameRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRole</span>();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存进度</span></span><br><span class="line">        <span class="type">RoleStateCaretaker</span> <span class="variable">roleStateCaretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleStateCaretaker</span>();</span><br><span class="line">        roleStateCaretaker.setMemento(gameRole.saveState());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss后------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss时，损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------恢复之前状态------------&quot;</span>);</span><br><span class="line">        <span class="comment">//恢复之前状态</span></span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优缺点-14">6.10.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><p><strong>2，缺点：</strong></p><ul><li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><h3 id="使用场景-15">6.10.5 使用场景</h3><ul><li><p>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p></li><li><p>需要提供一个可回滚操作的场景，如Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z组合键，还有数据库中事务操作。</p></li></ul><h1 id="行为型模式-2">6，行为型模式</h1><h2 id="解释器模式">6.11 解释器模式</h2><h3 id="概述-20">6.11.1 概述</h3><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243500.png" style="zoom:60%;" /></p><p>如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于两个整数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于两个整数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于n个整数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Integer ... arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如1+2+3+4+5、1+2+3-4等等。</p><p>显然，现在需要一种翻译识别机器，能够解析由数字以及 + -符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p><p><strong>定义：</strong></p><blockquote><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p></blockquote><p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2”就是这种语言的句子。</p><p>解释器就是要解析出来语句的含义。但是如何描述规则呢？</p><p><strong>文法（语法）规则：</strong></p><p>文法是用于描述语言的语法结构的形式规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expression ::= value | plus | minus</span><br><span class="line">plus ::= expression ‘+’ expression   </span><br><span class="line">minus ::= expression ‘-’ expression  </span><br><span class="line">value ::= integer</span><br></pre></td></tr></table></figure><blockquote><p>注意： 这里的符号“::=”表示“定义为”的意思，竖线 |表示或，左右的其中一个，引号内为字符本身，引号外为语法。</p></blockquote><p>上面规则描述为 ：</p><p>表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。</p><p><strong>抽象语法树：</strong></p><p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntaxtree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p><p>用树形来表示符合文法规则的句子。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243498.png" style="zoom:50%;" /></p><h3 id="结构-22">6.11.2 结构</h3><p>解释器模式包含以下主要角色。</p><ul><li><p>抽象表达式（AbstractExpression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法interpret()。</p></li><li><p>终结符表达式（TerminalExpression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</p></li><li><p>非终结符表达式（NonterminalExpression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</p></li><li><p>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p></li><li><p>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p></li></ul><h3 id="案例实现-12">6.11.3 案例实现</h3><p>【例】设计实现加减法的软件</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243505.png" style="zoom:80%;" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色AbstractExpression</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终结符表达式角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Value</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Value</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(value).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非终结符表达式角色  加法表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Plus</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Plus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) + right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; + &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///非终结符表达式角色 减法表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Minus</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Minus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) - right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; - &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终结符表达式角色 变量表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Variable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.getValue(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Variable, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Variable, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">(Variable <span class="keyword">var</span>, Integer value)</span> &#123;</span><br><span class="line">        map.put(<span class="keyword">var</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(Variable <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Variable</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="comment">//Value v = new Value(1);</span></span><br><span class="line"></span><br><span class="line">        context.assign(a, <span class="number">1</span>);</span><br><span class="line">        context.assign(b, <span class="number">2</span>);</span><br><span class="line">        context.assign(c, <span class="number">3</span>);</span><br><span class="line">        context.assign(d, <span class="number">4</span>);</span><br><span class="line">        context.assign(e, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractExpression</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Minus</span>(<span class="keyword">new</span> <span class="title class_">Plus</span>(<span class="keyword">new</span> <span class="title class_">Plus</span>(<span class="keyword">new</span> <span class="title class_">Plus</span>(a, b), c), d), e);</span><br><span class="line"></span><br><span class="line">        System.out.println(expression + <span class="string">&quot;= &quot;</span> + expression.interpret(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-15">6.11.4 优缺点</h3><p><strong>1，优点：</strong></p><ul><li><p>易于改变和扩展文法。</p><p>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p></li><li><p>实现文法较为容易。</p><p>在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。</p></li><li><p>增加新的解释表达式较为方便。</p><p>如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。</p></li></ul><p><strong>2，缺点：</strong></p><ul><li><p>对于复杂文法难以维护。</p><p>在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。</p></li><li><p>执行效率较低。</p><p>由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</p></li></ul><h3 id="使用场景-16">6.11.5 使用场景</h3><ul><li><p>当语言的文法较为简单，且执行效率不是关键问题时。</p></li><li><p>当问题重复出现，且可以用一种简单的语言来进行表达时。</p></li><li><p>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</p></li></ul><h1 id="自定义spring框架">7，自定义Spring框架</h1><h2 id="spring使用回顾">7.1 spring使用回顾</h2><p>自定义spring框架前，先回顾一下spring框架的使用，从而分析spring的核心，并对核心功能进行模拟。</p><ul><li><p>数据访问层。定义UserDao接口及其子实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userDaoImpl ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务逻辑层。定义UserService接口及其子实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userServiceImpl ...&quot;</span>);</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义UserController类，使用main方法模拟controller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建spring容器对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//从IOC容器中获取UserService对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        <span class="comment">//调用UserService对象的add方法</span></span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写配置文件。在类路径下编写一个名为ApplicationContext.xml的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>代码运行结果如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243497.png" style="zoom:60%;" /></p></li></ul><p>通过上面代码及结果可以看出：</p><ul><li>userService对象是从applicationContext容器对象获取到的，也就是userService对象交由spring进行管理。</li><li>上面结果可以看到调用了UserDao对象中的add方法，也就是说UserDao子实现类对象也交由spring管理了。</li><li>UserService中的userDao变量我们并没有进行赋值，但是可以正常使用，说明spring已经将UserDao对象赋值给了userDao变量。</li></ul><p>上面三点体现了Spring框架的IOC（Inversion of Control）和DI（DependencyInjection, DI）</p><h2 id="spring核心功能结构">7.2 spring核心功能结构</h2><p>Spring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为:</p><p>核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是Spring 框架的总体架构图：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243509.png" style="zoom:40%;" /></p><p>核心容器由 beans、core、context 和 expression（Spring ExpressionLanguage，SpEL）4个模块组成。</p><ul><li>spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（Inversionof Control，IOC）和依赖注入（DependencyInjection，DI）。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。BeanFactory属于延时加载，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该Bean 进行实例化与依赖关系的装配。</li><li>spring-context模块构架于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext是该模块的核心接口，它的超类是BeanFactory。与BeanFactory不同，ApplicationContext实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。</li><li>spring-context-support模块是对SpringIoC容器及IoC子容器的扩展支持。</li><li>spring-context-indexer模块是Spring的类管理组件和Classpath扫描组件。</li><li>spring-expression模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同SpringIoC进行交互。</li></ul><h3 id="bean概述">7.1.1 bean概述</h3><p>Spring 就是面向 <code>Bean</code> 的编程（BOP,Bean OrientedProgramming），Bean 在 Spring中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。SpringIoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。</p><p>spring中bean用于对一个类进行封装。如下面的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么Bean如此重要呢？</p><ul><li>spring 将bean对象交由一个叫IOC容器进行管理。</li><li>bean对象之间的依赖关系在配置文件中体现，并由spring完成。</li></ul><h2 id="spring-ioc相关接口分析">7.3 Spring IOC相关接口分析</h2><h3 id="beanfactory解析">7.3.1 BeanFactory解析</h3><p>Spring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243520.png" style="zoom:60%;" /></p><p>其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。</p><p>那么为何要定义这么多层次的接口呢？</p><p>每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如，</p><ul><li>ListableBeanFactory接口表示这些Bean可列表化。</li><li>HierarchicalBeanFactory表示这些Bean 是有继承关系的，也就是每个 Bean可能有父 Bean</li><li>AutowireCapableBeanFactory 接口定义Bean的自动装配规则。</li></ul><p>这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是BeanFactory，来看一下它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean的名称获取IOC容器中的的bean对象</span></span><br><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"><span class="comment">//根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; ObjectProvider&lt;T&gt; <span class="title function_">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span>;</span><br><span class="line">&lt;T&gt; ObjectProvider&lt;T&gt; <span class="title function_">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器中是否包含指定名称的bean对象</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsBean</span><span class="params">(String name)</span>;</span><br><span class="line"><span class="comment">//根据bean的名称判断是否是单例</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BeanFactory里只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。</p><p>BeanFactory有一个很重要的子接口，就是ApplicationContext接口，该接口主要来规范容器中的bean对象是非延时加载，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243888.png" style="zoom:60%;" /></p><p>要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如：</p><ul><li>ClasspathXmlApplicationContext :根据类路径加载xml配置文件，并创建IOC容器对象。</li><li>FileSystemXmlApplicationContext：根据系统路径加载xml配置文件，并创建IOC容器对象。</li><li>AnnotationConfigApplicationContext：加载注解类配置，并创建IOC容器。</li></ul><h3 id="beandefinition解析">7.3.2 BeanDefinition解析</h3><p>SpringIoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以BeanDefinition来描述的，如下面配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">bean标签还有很多属性：</span><br><span class="line">scope、init-method、destory-method等。</span><br></pre></td></tr></table></figure><p>其继承体系如下图所示。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243972.png" style="zoom:60%;" /></p><h3 id="beandefinitionreader解析">7.3.3 BeanDefinitionReader解析</h3><p>Bean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243389.png" style="zoom:60%;" /></p><p>看看BeanDefinitionReader接口定义的功能来理解它具体的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionReader</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取BeanDefinitionRegistry注册器对象</span></span><br><span class="line">BeanDefinitionRegistry <span class="title function_">getRegistry</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">ResourceLoader <span class="title function_">getResourceLoader</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">ClassLoader <span class="title function_">getBeanClassLoader</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">BeanNameGenerator <span class="title function_">getBeanNameGenerator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面的loadBeanDefinitions都是加载bean定义，从指定的资源中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException;</span><br><span class="line"><span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException;</span><br><span class="line"><span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException;</span><br><span class="line"><span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="beandefinitionregistry解析">7.3.4BeanDefinitionRegistry解析</h3><p>BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title class_">AliasRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往注册表中注册bean</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从注册表中删除指定名称的bean</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取注册表中指定名称的bean</span></span><br><span class="line">BeanDefinition <span class="title function_">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//判断注册表中是否已经注册了指定名称的bean</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsBeanDefinition</span><span class="params">(String beanName)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取注册表中所有的bean的名称</span></span><br><span class="line">String[] getBeanDefinitionNames();</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">getBeanDefinitionCount</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isBeanNameInUse</span><span class="params">(String beanName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承结构图如下：</p><p><img src="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202307111243427.png" style="zoom:60%;" /></p><p>从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个：</p><ul><li><p>DefaultListableBeanFactory</p><p>在该类中定义了如下代码，就是用来注册bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li><li><p>SimpleBeanDefinitionRegistry</p><p>在该类中定义了如下代码，就是用来注册bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建容器">7.3.5 创建容器</h3><p>ClassPathXmlApplicationContext对Bean配置资源的载入是从refresh（）方法开始的。refresh（）方法是一个模板方法，规定了IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean配置资源进行载入，ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh（）方法启动整个IoC容器对Bean定义的载入过程。</p><h2 id="自定义springioc">7.4 自定义SpringIOC</h2><p>现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定义bean相关的pojo类">7.4.1 定义bean相关的pojo类</h3><h4 id="propertyvalue类">7.4.1.1 PropertyValue类</h4><p>用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyValue</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String ref;</span><br><span class="line">  <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PropertyValue</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PropertyValue</span><span class="params">(String name, String ref,String value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.ref = ref;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getRef</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRef</span><span class="params">(String ref)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.ref = ref;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mutablepropertyvalues类">7.4.1.2 MutablePropertyValues类</h4><p>一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来存储并管理多个PropertyValue对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutablePropertyValues</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;PropertyValue&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValueList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MutablePropertyValues</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertyValueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;PropertyValue&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MutablePropertyValues</span><span class="params">(List&lt;PropertyValue&gt; propertyValueList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertyValueList = (propertyValueList != <span class="literal">null</span> ? propertyValueList : <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;PropertyValue&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyValue[] getPropertyValues() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.propertyValueList.toArray(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyValue <span class="title function_">getPropertyValue</span><span class="params">(String propertyName)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue pv : <span class="built_in">this</span>.propertyValueList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pv.getName().equals(propertyName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;PropertyValue&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValueList.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.propertyValueList.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MutablePropertyValues <span class="title function_">addPropertyValue</span><span class="params">(PropertyValue pv)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.propertyValueList.size(); i++) &#123;</span><br><span class="line">            <span class="type">PropertyValue</span> <span class="variable">currentPv</span> <span class="operator">=</span> <span class="built_in">this</span>.propertyValueList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (currentPv.getName().equals(pv.getName())) &#123;</span><br><span class="line">                <span class="built_in">this</span>.propertyValueList.set(i, <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(pv.getName(),pv.getRef(), pv.getValue()));</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.propertyValueList.add(pv);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String propertyName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPropertyValue(propertyName) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="beandefinition类">7.4.1.3 BeanDefinition类</h4><p>BeanDefinition类用来封装bean信息的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MutablePropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanDefinition</span><span class="params">()</span> &#123;</span><br><span class="line">        propertyValues = <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPropertyValues</span><span class="params">(MutablePropertyValues propertyValues)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertyValues = propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MutablePropertyValues <span class="title function_">getPropertyValues</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义注册表相关类">7.4.2 定义注册表相关类</h3><h4 id="beandefinitionregistry接口">7.4.2.1BeanDefinitionRegistry接口</h4><p>BeanDefinitionRegistry接口定义了注册表的相关操作，定义如下功能：</p><ul><li>注册BeanDefinition对象到注册表中</li><li>从注册表中删除指定名称的BeanDefinition对象</li><li>根据名称从注册表中获取BeanDefinition对象</li><li>判断注册表中是否包含指定名称的BeanDefinition对象</li><li>获取注册表中BeanDefinition对象的个数</li><li>获取注册表中所有的BeanDefinition的名称</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册BeanDefinition对象到注册表中</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从注册表中删除指定名称的BeanDefinition对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据名称从注册表中获取BeanDefinition对象</span></span><br><span class="line">    BeanDefinition <span class="title function_">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsBeanDefinition</span><span class="params">(String beanName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getBeanDefinitionCount</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="simplebeandefinitionregistry类">7.4.2.2SimpleBeanDefinitionRegistry类</h4><p>该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleBeanDefinitionRegistry</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, BeanDefinition&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        beanDefinitionMap.put(beanName,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        beanDefinitionMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinition <span class="title function_">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsBeanDefinition</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBeanDefinitionCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.keySet().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义解析器相关类">7.4.3 定义解析器相关类</h3><h4 id="beandefinitionreader接口">7.4.3.1 BeanDefinitionReader接口</h4><p>BeanDefinitionReader是用来解析配置文件并在注册表中注册bean的信息。定义了两个规范：</p><ul><li>获取注册表的功能，让外界可以通过该对象获取注册表对象。</li><li>加载配置文件，并注册bean数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionReader</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取注册表对象</span></span><br><span class="line">    BeanDefinitionRegistry <span class="title function_">getRegistry</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//加载配置文件并在注册表中进行注册</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="xmlbeandefinitionreader类">7.4.3.2XmlBeanDefinitionReader类</h4><p>XmlBeanDefinitionReader类是专门用来解析xml配置文件的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XmlBeanDefinitionReader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.registry = <span class="keyword">new</span> <span class="title class_">SimpleBeanDefinitionRegistry</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinitionRegistry <span class="title function_">getRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(configLocation);</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(is);</span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">//解析bean标签</span></span><br><span class="line">        parseBean(rootElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseBean</span><span class="params">(Element rootElement)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Element&gt; elements = rootElement.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> element.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> element.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>();</span><br><span class="line">            beanDefinition.setId(id);</span><br><span class="line">            beanDefinition.setClassName(className);</span><br><span class="line">            List&lt;Element&gt; list = element.elements(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">            <span class="type">MutablePropertyValues</span> <span class="variable">mutablePropertyValues</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">            <span class="keyword">for</span> (Element element1 : list) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> element1.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">ref</span> <span class="operator">=</span> element1.attributeValue(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> element1.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                <span class="type">PropertyValue</span> <span class="variable">propertyValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(name,ref,value);</span><br><span class="line">                mutablePropertyValues.addPropertyValue(propertyValue);</span><br><span class="line">            &#125;</span><br><span class="line">            beanDefinition.setPropertyValues(mutablePropertyValues);</span><br><span class="line"></span><br><span class="line">            registry.registerBeanDefinition(id,beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ioc容器相关类">7.4.4 IOC容器相关类</h3><h4 id="beanfactory接口">7.4.4.1 BeanFactory接口</h4><p>在该接口中定义IOC容器的统一规范即获取bean对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"><span class="comment">//根据bean对象的名称获取bean对象</span></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">//根据bean对象的名称获取bean对象，并进行类型转换</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="applicationcontext接口">7.4.4.2 ApplicationContext接口</h4><p>该接口的所以的子实现类对bean对象的创建都是非延时的，所以在该接口中定义<code>refresh()</code> 方法，该方法主要完成以下两个功能：</p><ul><li>加载配置文件。</li><li>根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"><span class="comment">//进行配置文件加载并进行对象创建</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException, Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="abstractapplicationcontext类">7.4.4.3AbstractApplicationContext类</h4><ul><li><p>作为ApplicationContext接口的子类，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。</p></li><li><p>声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。</p><p>BeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> BeanDefinitionReader beanDefinitionReader;</span><br><span class="line">    <span class="comment">//用来存储bean对象的容器   key存储的是bean的id值，value存储的是bean对象</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储配置文件的路径</span></span><br><span class="line">    <span class="keyword">protected</span> String configLocation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException, Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载BeanDefinition</span></span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(configLocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化bean</span></span><br><span class="line">        finishBeanInitialization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean的初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishBeanInitialization</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> beanDefinitionReader.getRegistry();</span><br><span class="line">        String[] beanNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">            getBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。</p></blockquote><h4 id="classpathxmlapplicationcontext类">7.4.4.4ClassPathXmlApplicationContext类</h4><p>该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能：</p><ul><li>在构造方法中，创建BeanDefinitionReader对象。</li><li>在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。</li><li>重写父接口中的getBean()方法，并实现依赖注入操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractApplicationContext</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configLocation = configLocation;</span><br><span class="line">        <span class="comment">//构建XmlBeanDefinitionReader对象</span></span><br><span class="line">        beanDefinitionReader = <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.refresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据bean的id属性值获取bean对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//return singletonObjects.get(name);</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> singletonObjects.get(name);</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> beanDefinitionReader.getRegistry();</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> registry.getBeanDefinition(name);</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanDefinition.getClassName();</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="type">MutablePropertyValues</span> <span class="variable">propertyValues</span> <span class="operator">=</span> beanDefinition.getPropertyValues();</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : propertyValues) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> propertyValue.getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> propertyValue.getValue();</span><br><span class="line">            <span class="type">String</span> <span class="variable">ref</span> <span class="operator">=</span> propertyValue.getRef();</span><br><span class="line">            <span class="keyword">if</span>(ref != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(ref)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(ref);</span><br><span class="line">                <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> StringUtils.getSetterMethodNameByFieldName(propertyName);</span><br><span class="line">                Method[] methods = clazz.getMethods();</span><br><span class="line">                <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(method.getName().equals(methodName)) &#123;</span><br><span class="line">                        method.invoke(beanObj,bean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(value != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(value)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> StringUtils.getSetterMethodNameByFieldName(propertyName);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(methodName, String.class);</span><br><span class="line">                method.invoke(beanObj,value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        singletonObjects.put(name,beanObj);</span><br><span class="line">        <span class="keyword">return</span> beanObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(name);</span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义spring-ioc总结">7.4.5 自定义Spring IOC总结</h3><h4 id="使用到的设计模式">7.4.5.1 使用到的设计模式</h4><ul><li>工厂模式。这个使用工厂模式 + 配置文件的方式。</li><li>单例模式。SpringIOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。</li><li>模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。</li><li>迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。</li></ul><p>spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。</p><h4 id="符合大部分设计原则">7.4.5.2 符合大部分设计原则</h4><h4 id="整个设计和spring的设计还是有一定的出入">7.4.5.3整个设计和Spring的设计还是有一定的出入</h4><p>spring框架底层是很复杂的，进行了很深入的封装，并对外提供了很好的扩展性。而我们自定义SpringIOC有以下几个目的：</p><ul><li>了解Spring底层对对象的大体管理机制。</li><li>了解设计模式在具体的开发中的使用。</li><li>以后学习spring源码，通过该案例的实现，可以降低spring学习的入门成本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】MarkDown数学公式基本语法</title>
      <link href="/posts/22632.html"/>
      <url>/posts/22632.html</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202306151033711.jpeg"alt="MarkDown" /><figcaption aria-hidden="true">MarkDown</figcaption></figure><p>行内公式<spanclass="math inline">∫<sub><em>a</em></sub><sup><em>b</em></sup>(<em>x</em><sup><em>a</em></sup> + <em>b</em>)<em>d</em>(<em>x</em>)</span></p><p>独立公式 <span class="math display">$$函数名=\begin{cases}  公式1 &amp; 条件1 \\公式2 &amp; 条件2 \\公式3 &amp; 条件3\end{cases}$$</span> {独立公式}</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】AJAX</title>
      <link href="/posts/16388.html"/>
      <url>/posts/16388.html</url>
      
        <content type="html"><![CDATA[<h1 id="ajaxasynchronous-javascript-and-xml">AJAX（AsynchronousJavascript And Xml）</h1><h2 id="传统请求及缺点">传统请求及缺点</h2><ul><li>传统的请求都有哪些？<ul><li>直接在浏览器地址栏上输入URL。</li><li>点击超链接</li><li>提交form表单</li><li>使用JS代码发送请求<ul><li>window.open(url)</li><li>document.location.href = url</li><li>window.location.href = url</li><li>….</li></ul></li></ul></li><li>传统请求存在的问题<ul><li>页面全部刷新导致了用户的体验较差。</li><li>传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）</li><li><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202305181929961.png"alt="AJAX同步请求" /><figcaption aria-hidden="true">AJAX同步请求</figcaption></figure></li></ul></li></ul><h2 id="ajax概述">AJAX概述</h2><ul><li>AJAX不能称为一种技术，它是多种技术的综合产物。</li><li>AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。</li><li>什么是异步，什么是同步？<ul><li>假设有t1和t2线程，t1和t2线程并发，就是异步。</li><li>假设有t1和t2线程，t2在执行的时候，必须等待t1线程执行到某个位置之后t2才能执行，那么t2在等t1，显然他们是排队的，排队的就是同步。</li><li>AJAX是可以发送异步请求的。也就是说，在同一个浏览器页面当中，可以发送多个ajax请求，这些ajax请求之间不需要等待，是并发的。</li></ul></li><li>AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。</li><li>AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON文本传输也同样常见。</li><li>AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）</li><li>AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。</li><li><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202305181929046.png"alt="AJAX异步请求" /><figcaption aria-hidden="true">AJAX异步请求</figcaption></figure></li><li><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202305181931316.png"alt="对AJAX异步请求的理解" /><figcaption aria-hidden="true">对AJAX异步请求的理解</figcaption></figure></li></ul><h2 id="xmlhttprequest对象">XMLHttpRequest对象</h2><ul><li><p>XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。</p></li><li><p>XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。</p></li><li><p>创建XMLHttpRequest对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure><ul><li>XMLHttpRequest对象的方法</li></ul><table><colgroup><col style="width: 42%" /><col style="width: 57%" /></colgroup><thead><tr><th style="text-align: left;">方法</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr><td style="text-align: left;">abort()</td><td style="text-align: left;">取消当前请求</td></tr><tr><td style="text-align: left;">getAllResponseHeaders()</td><td style="text-align: left;">返回头部信息</td></tr><tr><td style="text-align: left;">getResponseHeader()</td><td style="text-align: left;">返回特定的头部信息</td></tr><tr><td style="text-align: left;">open(<em>method</em>, <em>url</em>,<em>async</em>, <em>user</em>, <em>psw</em>)</td><td style="text-align: left;">规定请求method：请求类型 GET 或POSTurl：文件位置async：true（异步）或false（同步）user：可选的用户名称psw：可选的密码</td></tr><tr><td style="text-align: left;">send()</td><td style="text-align: left;">将请求发送到服务器，用于 GET 请求</td></tr><tr><td style="text-align: left;">send(<em>string</em>)</td><td style="text-align: left;">将请求发送到服务器，用于 POST 请求</td></tr><tr><td style="text-align: left;">setRequestHeader()</td><td style="text-align: left;">向要发送的报头添加标签/值对</td></tr></tbody></table><ul><li>XMLHttpRequest对象的属性</li></ul><table><colgroup><col style="width: 23%" /><col style="width: 76%" /></colgroup><thead><tr><th style="text-align: left;">属性</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr><td style="text-align: left;">onreadystatechange</td><td style="text-align: left;">定义当 readyState属性发生变化时被调用的函数</td></tr><tr><td style="text-align: left;">readyState</td><td style="text-align: left;">保存 XMLHttpRequest的状态。0：请求未初始化 1：服务器连接已建立 2：请求已收到3：正在处理请求 4：请求已完成且响应已就绪</td></tr><tr><td style="text-align: left;">responseText</td><td style="text-align: left;">以字符串返回响应数据</td></tr><tr><td style="text-align: left;">responseXML</td><td style="text-align: left;">以 XML 数据返回响应数据</td></tr><tr><td style="text-align: left;">status</td><td style="text-align: left;">返回请求的状态号200: “OK”403:“Forbidden”404: “Not Found”</td></tr><tr><td style="text-align: left;">statusText</td><td style="text-align: left;">返回状态文本（比如 “OK” 或 “NotFound”）</td></tr></tbody></table><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202305181937882.png"alt="XMLHttpRequest的readyState属性" /><figcaptionaria-hidden="true">XMLHttpRequest的readyState属性</figcaption></figure><h2 id="ajax-get请求">AJAX GET请求</h2><ul><li>发送AJAX get请求，前端代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>发送ajax get请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//1. 创建AJAX核心对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//2. 注册回调函数</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容。</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 并且不管服务器响应回来的是什么，都以普通文本的形势获取。（服务器可能响应回来：普通文本、XML、JSON、HTML...）</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// innerHTML属性是javascript中的语法，和ajax的XMLHttpRequest对象无关。</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// innerHTML可以设置元素内部的HTML代码。（innerHTML可以将后面的内容当做一段HTML代码解释并执行）</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//document.getElementById(&quot;myspan&quot;).innerHTML = this.responseText</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mydiv&quot;</span>).<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">responseText</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// innerText也不是AJAX中的，是javascript中的元素属性，和XMLHttpRequest无关。</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// innerText也是设置元素中的内容，但是即使后面是一段HTML代码，也是将其看做一个普通字符串设置进去。</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//document.getElementById(&quot;myspan&quot;).innerText = this.responseText</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">status</span>)</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//3. 开启通道</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/ajax/ajaxrequest2&quot;</span>, <span class="literal">true</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//4. 发送请求</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">send</span>()</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>发送ajax get请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;myspan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mydiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>发送AJAX get请求，后端代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.ajax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: 代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: AjaxRequest2Servlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: bjpowernode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-05-13 10:46</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ajaxrequest2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxRequest2Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置响应的内容类型以及字符集</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取响应流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        out.print(<span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已存在！！！&lt;/font&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>AJAX get请求如何提交数据呢？</p><ul><li>get请求提交数据是在“请求行”上提交，格式是：url?name=value&amp;name=value&amp;name=value….</li><li>其实这个get请求提交数据的格式是HTTP协议中规定的，遵循协议即可。</li></ul></li></ul><h2 id="ajax-get请求的缓存问题">AJAX GET请求的缓存问题</h2><ul><li>对于低版本的IE浏览器来说，AJAX的get请求可能会走缓存。存在缓存问题。对于现代的浏览器来说，大部分浏览器都已经不存在AJAXget缓存问题了。</li><li>什么是AJAX GET请求缓存问题呢？<ul><li>在HTTP协议中是这样规定get请求的：get请求会被缓存起来。</li><li>发送AJAXGET请求时，在同一个浏览器上，前后发送的AJAX请求路径一样的话，对于低版本的IE来说，第二次的AJAXGET请求会走缓存，不走服务器。</li></ul></li><li>POST请求在HTTP协议中规定的是：POST请求不会被浏览器缓存。</li><li>GET请求缓存的优缺点：<ul><li>优点：直接从浏览器缓存中获取资源，不需要从服务器上重新加载资源，速度较快，用户体验好。</li><li>缺点：无法实时获取最新的服务器资源。</li></ul></li><li>浏览器什么时候会走缓存？<ul><li>第一：是一个GET请求</li><li>第二：请求路径已经被浏览器缓存过了。第二次发送请求的时候，这个路径没有变化，会走浏览器缓存。</li></ul></li><li>如果是低版本的IE浏览器，怎么解决AJAX GET请求的缓存问题呢？<ul><li>可以在请求路径url后面添加一个时间戳，这个时间戳是随时变化的。所以每一次发送的请求路径都是不一样的，这样就不会走浏览器的缓存问题了。</li><li>可以采用时间戳：“url?t=” + new Date().getTime()</li><li>或者可以通过随机数：“url?t=” + Math.random()</li><li>也可以随机数+时间戳….</li></ul></li></ul><h2 id="ajax-post请求">AJAX POST请求</h2><ul><li>AJAXPOST请求和GET请求的代码区别在哪里？就是前端代码有区别。后端代码没有区别。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 发送AJAX POST请求</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) <span class="comment">// 设置请求头的内容类型。模拟form表单提交数据。</span></span><br><span class="line"><span class="comment">// 获取表单中的数据</span></span><br><span class="line"><span class="keyword">var</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line"><span class="keyword">var</span> password = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>).<span class="property">value</span>;</span><br><span class="line"><span class="comment">// send函数中的参数就是发送的数据，这个数据在“请求体”当中发送。</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&quot;username=&quot;</span>+username+<span class="string">&quot;&amp;password=&quot;</span>+password)</span><br></pre></td></tr></table></figure><ul><li><p>实现一个案例：使用AJAXPOST请求实现用户注册的时候，用户名是否可用。（验证用户名是否可以注册）实现步骤如下：</p><ul><li>在前端，用户输入用户名之后，失去焦点事件blur发生，然后发送AJAXPOST请求，提交用户名</li><li>在后端，接收到用户名，连接数据库，根据用户名去表中搜索</li><li>如果用户名已存在<ul><li>后端响应消息：对不起，用户名已存在（在前端页面以红色字体展示）</li></ul></li><li>如果用户名不存在<ul><li>后端响应消息：用户名可以使用（在前端页面以绿色字体展示）</li></ul></li></ul></li><li><p>实现一个案例：用户点击按钮之后，发送AJAX请求，显示学生列表。</p><ul><li>在后端java程序中拼接HTML代码，然后将HTML代码直接响应到浏览器客户端。这种方式不好，不应该在java代码中编写HTML代码，能否在java程序中直接向前端响应数据？可以，可以在后端拼接JSON格式的字符串，或者XML格式的字符串，将这个字符串发送给前端，前端解析即可。</li></ul></li></ul><h2 id="基于json的数据交换">基于JSON的数据交换</h2><ul><li>在WEB前端中，如何将一个json格式的字符串转换成json对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&quot;&#123;\&quot;username\&quot; : \&quot;zhangsan\&quot;, \&quot;password\&quot; : \&quot;1233344\&quot;&#125;&quot;</span></span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jsonObj.<span class="property">username</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jsonObj.<span class="property">password</span>)</span><br></pre></td></tr></table></figure><ul><li>在后端拼接JSON格式的字符串，响应给前端的浏览器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">json.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="comment">// 获取每个学生的信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">addr</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;addr&quot;</span>);</span><br><span class="line">    <span class="comment">// 拼接json格式的字符串</span></span><br><span class="line">    <span class="comment">// &#123;&quot;name&quot;:&quot;   王五    &quot;,&quot;age&quot;:    20      ,&quot;addr&quot;:&quot;      北京大兴区     &quot;&#125;,</span></span><br><span class="line">    json.append(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;&quot;</span>);</span><br><span class="line">    json.append(name);</span><br><span class="line">    json.append(<span class="string">&quot;\&quot;,\&quot;age\&quot;:&quot;</span>);</span><br><span class="line">    json.append(age);</span><br><span class="line">    json.append(<span class="string">&quot;,\&quot;addr\&quot;:\&quot;&quot;</span>);</span><br><span class="line">    json.append(addr);</span><br><span class="line">    json.append(<span class="string">&quot;\&quot;&#125;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">jsonStr = json.substring(<span class="number">0</span>, json.length() - <span class="number">1</span>) + <span class="string">&quot;]&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>拼接JSON格式的字符串太痛苦，可以使用阿里巴巴的fastjson组件，它可以将java对象转换成json格式的字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="comment">// 取出数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">addr</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;addr&quot;</span>);</span><br><span class="line">    <span class="comment">// 将以上数据封装成Student对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(name, age, addr);</span><br><span class="line">    <span class="comment">// 将Student对象放到List集合</span></span><br><span class="line">    studentList.add(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将List集合转换成json字符串</span></span><br><span class="line">jsonStr = JSON.toJSONString(studentList);</span><br></pre></td></tr></table></figure><p>注意：使用fastjson需要引入fastjson-1.2.2.jar</p><h2 id="基于xml的数据交换">基于XML的数据交换</h2><ul><li>注意：如果服务器端响应XML的话，响应的内容类型需要写成：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/xml;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>xml和JSON都是常用的数据交换格式</p><ul><li>XML体积大，解析麻烦。较少用。</li><li>JSON体积小，解析简单，较常用。</li></ul></li><li><p>基于XML的数据交换，前端代码</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>使用XML完成数据交换<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 1.创建XMLHTTPRequest对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 2.注册回调函数</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 服务器端响应了一个XML字符串，这里怎么接收呢？</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 使用XMLHTTPRequest对象的responseXML属性，接收返回之后，可以自动封装成document对象（文档对象）</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> xmlDoc = <span class="variable language_">this</span>.<span class="property">responseXML</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//console.log(xmlDoc)</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 获取所有的&lt;student&gt;元素，返回了多个对象，应该是数组。</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> students = xmlDoc.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;student&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//console.log(students[0].nodeName)</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> html = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; students.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">var</span> student = students[i]</span></span><br><span class="line"><span class="language-javascript">                            <span class="comment">// 获取&lt;student&gt;元素下的所有子元素</span></span></span><br><span class="line"><span class="language-javascript">                            html += <span class="string">&quot;&lt;tr&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">                            html += <span class="string">&quot;&lt;td&gt;&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;&lt;/td&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">var</span> nameOrAge = student.<span class="property">childNodes</span></span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; nameOrAge.<span class="property">length</span>; j++) &#123;</span></span><br><span class="line"><span class="language-javascript">                                <span class="keyword">var</span> node = nameOrAge[j]</span></span><br><span class="line"><span class="language-javascript">                                <span class="keyword">if</span> (node.<span class="property">nodeName</span> == <span class="string">&quot;name&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                                    <span class="comment">//console.log(&quot;name = &quot; + node.textContent)</span></span></span><br><span class="line"><span class="language-javascript">                                    html += <span class="string">&quot;&lt;td&gt;&quot;</span>+node.<span class="property">textContent</span>+<span class="string">&quot;&lt;/td&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">                                &#125;</span></span><br><span class="line"><span class="language-javascript">                                <span class="keyword">if</span> (node.<span class="property">nodeName</span> == <span class="string">&quot;age&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                                    <span class="comment">//console.log(&quot;age = &quot; + node.textContent)</span></span></span><br><span class="line"><span class="language-javascript">                                    html += <span class="string">&quot;&lt;td&gt;&quot;</span>+node.<span class="property">textContent</span>+<span class="string">&quot;&lt;/td&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">                                &#125;</span></span><br><span class="line"><span class="language-javascript">                            &#125;</span></span><br><span class="line"><span class="language-javascript">                            html += <span class="string">&quot;&lt;/tr&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;stutbody&quot;</span>).<span class="property">innerHTML</span> = html</span></span><br><span class="line"><span class="language-javascript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">status</span>)</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 3.开启通道</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/ajax/ajaxrequest6?t=&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(), <span class="literal">true</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 4.发送请求</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">send</span>()</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>显示学生列表<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span> <span class="attr">id</span>=<span class="string">&quot;stutbody&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;tr&gt;</span></span><br><span class="line"><span class="comment">        &lt;td&gt;1&lt;/td&gt;</span></span><br><span class="line"><span class="comment">        &lt;td&gt;zhangsan&lt;/td&gt;</span></span><br><span class="line"><span class="comment">        &lt;td&gt;20&lt;/td&gt;</span></span><br><span class="line"><span class="comment">    &lt;/tr&gt;</span></span><br><span class="line"><span class="comment">    &lt;tr&gt;</span></span><br><span class="line"><span class="comment">        &lt;td&gt;2&lt;/td&gt;</span></span><br><span class="line"><span class="comment">        &lt;td&gt;lisi&lt;/td&gt;</span></span><br><span class="line"><span class="comment">        &lt;td&gt;22&lt;/td&gt;</span></span><br><span class="line"><span class="comment">    &lt;/tr&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基于XML的数据交换，后端java程序：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.ajax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: 代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: AjaxRequest6Servlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 服务器端返回XML字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: bjpowernode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-05-15 11:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ajaxrequest6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxRequest6Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 注意：响应的内容类型是XML。</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/xml;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &lt;students&gt;</span></span><br><span class="line"><span class="comment">            &lt;student&gt;</span></span><br><span class="line"><span class="comment">                &lt;name&gt;zhangsan&lt;/name&gt;</span></span><br><span class="line"><span class="comment">                &lt;age&gt;20&lt;/age&gt;</span></span><br><span class="line"><span class="comment">            &lt;/student&gt;</span></span><br><span class="line"><span class="comment">            &lt;student&gt;</span></span><br><span class="line"><span class="comment">                &lt;name&gt;lisi&lt;/name&gt;</span></span><br><span class="line"><span class="comment">                &lt;age&gt;22&lt;/age&gt;</span></span><br><span class="line"><span class="comment">            &lt;/student&gt;</span></span><br><span class="line"><span class="comment">        &lt;/students&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;students&gt;&quot;</span>);</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;student&gt;&quot;</span>);</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;name&gt;zhangsan&lt;/name&gt;&quot;</span>);</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;age&gt;20&lt;/age&gt;&quot;</span>);</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;/student&gt;&quot;</span>);</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;student&gt;&quot;</span>);</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;name&gt;lisi&lt;/name&gt;&quot;</span>);</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;age&gt;22&lt;/age&gt;&quot;</span>);</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;/student&gt;&quot;</span>);</span><br><span class="line">        xml.append(<span class="string">&quot;&lt;/students&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        out.print(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ajax乱码问题">AJAX乱码问题</h2><ul><li><p>测试内容：</p><ul><li>发送ajax get请求<ul><li>发送数据到服务器，服务器获取的数据是否乱码？</li><li>服务器响应给前端的中文，会不会乱码？</li></ul></li><li>发送ajax post请求<ul><li>发送数据到服务器，服务器获取的数据是否乱码？</li><li>服务器响应给前端的中文，会不会乱码？</li></ul></li></ul></li><li><p>包括还要测试tomcat服务器的版本：</p><ul><li>tomcat10和tomcat9都要进行测试。</li></ul></li><li><p>测试结果：</p><ul><li><p>对于tomcat10来说，关于字符集，我们程序员不需要干涉，不会出现乱码。</p></li><li><p>对于tomcat9来说呢？</p><ul><li>响应中文的时候，会出现乱码，怎么解决？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>发送ajaxpost请求的时候，发送给服务器的数据，服务器接收之后乱码，怎么解决？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="ajax的异步与同步">AJAX的异步与同步</h2><ul><li><p>什么是异步？什么是同步？</p><ul><li>ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）</li><li>如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。）</li></ul></li><li><p>异步和同步在代码上如何实现？</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这个是ajax请求1</span></span><br><span class="line"><span class="comment">// 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。</span></span><br><span class="line"><span class="comment">// false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。</span></span><br><span class="line">xhr1.<span class="title function_">open</span>(<span class="string">&quot;请求方式&quot;</span>, <span class="string">&quot;URL&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">xhr1.<span class="title function_">send</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这个是ajax请求2</span></span><br><span class="line"><span class="comment">// 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。</span></span><br><span class="line">xhr2.<span class="title function_">open</span>(<span class="string">&quot;请求方式&quot;</span>, <span class="string">&quot;URL&quot;</span>, <span class="literal">true</span>) </span><br><span class="line">xhr2.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><ul><li><p>什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）</p><ul><li>举一个例子<ul><li>用户注册<ul><li>用户名需要发送ajax请求进行校验</li><li>邮箱地址也需要发送ajax请求校验</li><li>其他的也可能需要发送ajax请求。。。</li><li>并且最终注册按钮的时候，也是发送ajax请求进行注册。</li><li>那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。</li></ul></li></ul></li></ul></li></ul><h2 id="ajax代码封装">AJAX代码封装</h2><ul><li><p>AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。</p></li><li><p>接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）</p></li><li><p>手动开发jQuery，源代码</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jQuery</span>(<span class="params">selector</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> selector == <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selector.<span class="title function_">charAt</span>(<span class="number">0</span>) == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">            domObj = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(selector.<span class="title function_">substring</span>(<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">jQuery</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> selector == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">onload</span> = selector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">html</span> = <span class="keyword">function</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line">        domObj.<span class="property">innerHTML</span> = htmlStr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">click</span> = <span class="keyword">function</span>(<span class="params">fun</span>)&#123;</span><br><span class="line">        domObj.<span class="property">onclick</span> = fun</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">focus</span> = <span class="keyword">function</span> (<span class="params">fun</span>)&#123;</span><br><span class="line">        domObj.<span class="property">onfocus</span> = fun</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">blur</span> = <span class="keyword">function</span>(<span class="params">fun</span>) &#123;</span><br><span class="line">        domObj.<span class="property">onblur</span> = fun</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">change</span> = <span class="keyword">function</span> (<span class="params">fun</span>)&#123;</span><br><span class="line">        domObj.<span class="property">onchange</span> = fun</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = <span class="keyword">function</span>(<span class="params">v</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> domObj.<span class="property">value</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            domObj.<span class="property">value</span> = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的方法，发送ajax请求</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析：使用ajax函数发送ajax请求的时候，需要程序员给我们传过来什么？</span></span><br><span class="line"><span class="comment">     *      请求的方式(type)：GET/POST</span></span><br><span class="line"><span class="comment">     *      请求的URL(url)：url</span></span><br><span class="line"><span class="comment">     *      请求时提交的数据(data)：data</span></span><br><span class="line"><span class="comment">     *      请求时发送异步请求还是同步请求(async)：true表示异步，false表示同步。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jQuery.<span class="property">ajax</span> = <span class="keyword">function</span>(<span class="params">jsonArgs</span>)&#123;</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="comment">// 我们这个工具类在封装的时候，先不考虑那么多，假设服务器返回的都是json格式的字符串。</span></span><br><span class="line">                    <span class="keyword">var</span> jsonObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>)</span><br><span class="line">                    <span class="comment">// 调用函数</span></span><br><span class="line">                    jsonArgs.<span class="title function_">success</span>(jsonObj)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (jsonArgs.<span class="property">type</span>.<span class="title function_">toUpperCase</span>() == <span class="string">&quot;POST&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.</span></span><br><span class="line">            xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, jsonArgs.<span class="property">url</span>, jsonArgs.<span class="property">async</span>)</span><br><span class="line">            <span class="comment">// 4.</span></span><br><span class="line">            xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">            xhr.<span class="title function_">send</span>(jsonArgs.<span class="property">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (jsonArgs.<span class="property">type</span>.<span class="title function_">toUpperCase</span>() == <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">            xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, jsonArgs.<span class="property">url</span> + <span class="string">&quot;?&quot;</span> + jsonArgs.<span class="property">data</span>, jsonArgs.<span class="property">async</span>)</span><br><span class="line">            xhr.<span class="title function_">send</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$ = jQuery</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里有个细节，执行这个目的是为了让静态方法ajax生效。</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">jQuery</span>()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用以上库，怎么用？</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/ajax/js/jQuery-1.0.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#btn1&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                type : <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                url : <span class="string">&quot;/ajax/ajaxrequest11&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                data : <span class="string">&quot;username=&quot;</span> + $(<span class="string">&quot;#username&quot;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">async</span> : <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">                success : <span class="keyword">function</span>(<span class="params">json</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    $(<span class="string">&quot;#div1&quot;</span>).<span class="title function_">html</span>(json.<span class="property">uname</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ajax实现省市联动">AJAX实现省市联动</h2><ul><li><p>什么是省市联动？</p><ul><li>在网页上，选择对应的省份之后，动态的关联出该省份对应的市。选择对应的市之后，动态的关联出该市对应的区。（首先要清楚需求）</li></ul></li><li><p>进行数据库表的设计</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id(PK-自增)  codenamepcode</span><br><span class="line">---------------------------------------------</span><br><span class="line">1001 河北省null</span><br><span class="line">2002 河南省null</span><br><span class="line">3003 石家庄    001</span><br><span class="line">4004 邯郸 001</span><br><span class="line">5005 郑州 002</span><br><span class="line">6006 洛阳 002</span><br><span class="line">7007 丛台区    004  </span><br><span class="line"></span><br><span class="line">将全国所有的省、市、区、县等信息都存储到一张表当中。</span><br><span class="line">采用的存储方式实际上是code pcode形势。</span><br></pre></td></tr></table></figure><ul><li><p>建表t_area，模拟好数据。</p></li><li><p>首先实现第一个功能：</p><ul><li>页面加载完毕之后，先把省份全部展现出来。</li></ul></li></ul><h2 id="ajax跨域问题">AJAX跨域问题</h2><h3 id="跨域">跨域</h3><ul><li>跨域是指从一个域名的网页去请求另一个域名的资源。比如从<ahref="https://baidu.com">百度</a>页面去请求<ahref="https://www.jd.com">京东</a>的资源。</li><li>通过超链接或者form表单提交或者window.location.href的方式进行跨域是不存在问题的（<strong>大家可以编写程序测试一下</strong>）。但在一个域名的网页中的一段js代码发送ajax请求去访问另一个域名中的资源，由于同源策略的存在导致无法跨域访问，那么ajax就存在这种跨域问题。</li><li>同源策略是指一段脚本只能读取来自同一来源的窗口和文档的属性，同源就是协议、域名和端口都相同。</li><li>同源策略有什么用？如果你刚刚在网银输入账号密码，查看了自己还有1万块钱，紧接着访问一些不规矩的网站，这个网站可以访问刚刚的网银站点，并且获取账号密码，那后果可想而知。所以，从安全的角度来讲，同源策略是有利于保护网站信息的。</li><li>有一些情况下，我们是需要使用ajax进行跨域访问的。比如某公司的A页面(a.bjpowernode.com)有可能需要获取B页面(b.bjpowernode.com)。</li><li><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202305181934864.png"alt="对跨域的理解" /><figcaption aria-hidden="true">对跨域的理解</figcaption></figure></li></ul><h3 id="同源还是不同源">同源还是不同源</h3><ul><li><p>区分同源和不同源的三要素</p><ul><li>协议</li><li>域名</li><li>端口</li></ul></li><li><p>协议一致，域名一致，端口号一致，三个要素都一致，才是同源，其它一律都是不同源</p></li></ul><table><colgroup><col style="width: 35%" /><col style="width: 32%" /><col style="width: 12%" /><col style="width: 18%" /></colgroup><thead><tr><th><strong>URL1</strong></th><th><strong>URL2</strong></th><th><strong>是否同源</strong></th><th>描述</th></tr></thead><tbody><tr><td>http://localhost:8080/a/index.html</td><td>http://localhost:8080/a/first</td><td>同源</td><td>协议 域名 端口一致</td></tr><tr><td>http://localhost:8080/a/index.html</td><td>http://localhost:8080/b/first</td><td>同源</td><td>协议 域名 端口一致</td></tr><tr><td>http://www.myweb.com:8080/a.js</td><td>https://www.myweb.com:8080/b.js</td><td>不同源</td><td>协议不同</td></tr><tr><td>http://www.myweb.com:8080/a.js</td><td>http://www.myweb.com:8081/b.js</td><td>不同源</td><td>端口不同</td></tr><tr><td>http://www.myweb.com/a.js</td><td>http://www.myweb2.com/b.js</td><td>不同源</td><td>域名不同</td></tr><tr><td>http://www.myweb.com/a.js</td><td>http://crm.myweb.com/b.js</td><td>不同源</td><td>子域名不同</td></tr></tbody></table><h3 id="复现ajax跨域问题">复现AJAX跨域问题</h3><h3 id="ajax跨域解决方案">AJAX跨域解决方案</h3><h4 id="方案1设置响应头">方案1：设置响应头</h4><ul><li><p>核心原理：跨域访问的资源允许你跨域访问。</p></li><li><p>实现：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost:8080&quot;</span>); <span class="comment">// 允许某个</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>); <span class="comment">// 允许所有</span></span><br></pre></td></tr></table></figure><h4 id="方案2jsonp">方案2：jsonp</h4><ul><li>jsonp：json withpadding（带填充的json【学完之后再理解这个什么意思！！！】）</li><li>jsonp不是一个真正的ajax请求。只不过可以完成ajax的局部刷新效果。可以说jsonp是一种类ajax请求的机制。</li><li>jsonp不是ajax请求，但是可以完成局部刷新的效果，并且可以解决跨域问题。</li><li>注意：jsonp解决跨域的时候，只支持GET请求。不支持post请求。</li></ul><h4 id="方案3jquery封装的jsonp">方案3：jQuery封装的jsonp</h4><ul><li><p>牛人们写的jQuery库，已经对jsonp进行了封装。大家可以直接拿来用。</p></li><li><p>用之前需要引入jQuery库的js文件。（这里的jQuery库咱们就不再封装了，咱们直接用jQuery写好的jsonp方式。）</p></li><li><p>jQuery中的jsonp其实就是我们方案2的高度封装，底层原理完全相同。</p></li><li><p>核心代码</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    type : <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    url : <span class="string">&quot;跨域的url&quot;</span>,</span><br><span class="line">    dataType : <span class="string">&quot;jsonp&quot;</span>, <span class="comment">// 指定数据类型</span></span><br><span class="line">    jsonp : <span class="string">&quot;fun&quot;</span>, <span class="comment">// 指定参数名（不设置的时候，默认是：&quot;callback&quot;）</span></span><br><span class="line">    jsonpCallback : <span class="string">&quot;sayHello&quot;</span> <span class="comment">// 指定回调函数的名字</span></span><br><span class="line">   <span class="comment">// （不设置的时候，jQuery会自动生成一个随机的回调函数，</span></span><br><span class="line">       <span class="comment">//并且这个回调函数还会自动调用success的回调函数。）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​</p><h4 id="方案4代理机制httpclient">方案4：代理机制（httpclient）</h4><ul><li>使用Java程序怎么去发送get/post请求呢？【GET和POST请求就是HTTP请求。】<ul><li>第一种方案：使用JDK内置的API（java.net.URL…..），这些API是可以发送HTTP请求的。</li><li>第二种方案：使用第三方的开源组件，比如：apache的httpclient组件。（httpclient组件是开源免费的，可以直接用）</li></ul></li><li>在java程序中，使用httpclient组件可以发送http请求。<ul><li>对于httpclient组件的代码，大家目前可以不进行深入的研究，可以从网上直接搜。然后粘贴过来，改一改，看看能不能完成发送get和post请求。</li><li>使用httpclient组件，需要先将这个组件相关的jar包引入到项目当中。</li></ul></li></ul><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202305181936911.png"alt="AJAX跨域解决方案之代理机制" /><figcaption aria-hidden="true">AJAX跨域解决方案之代理机制</figcaption></figure><h4 id="方案5nginx反向代理">方案5：nginx反向代理</h4><ul><li>nginx反向代理中也是使用了这种代理机制来完成AJAX的跨域，实现起来非常简单，只要修改一个nginx的配置即可。以后大家学习nginx之后再说吧。！！！！</li></ul><h2 id="ajax实现搜索联想-自动补全">AJAX实现搜索联想 自动补全</h2><ul><li>什么是搜索联想？自动补全？<ul><li>百度是一个很典型的代表。在百度的搜索框中输入相关信息的时候，会有搜索联想以及自动补全。</li><li>搜索联想和自动补全：实际上是为了方便用户的使用。让用户的体验更好。</li><li>搜索联想：当用户输入一些单词之后，自动联想出用户要搜索的信息，给一个提示。</li><li>自动补全：当联想出一些内容之后，用户点击某个联想的单词，然后将这个单词自动补全到搜索框当中。</li><li>搜索联想和自动补全功能，因为是页面局部刷新效果，所以需要使用ajax请求来完成。</li></ul></li><li>搜索联想，自动补全功能的核心实现原理？<ul><li>当键盘事件发生之后，比如：keyup：键弹起事件。</li><li>发送ajax请求，请求中提交用户输入的搜索内容，例如：北京（发送ajax请求，携带“北京”两个字）</li><li>后端接收到ajax请求，接收到“北京”两个字，执行select语句进行模糊查询。返回查询结果。</li><li>将查询结果封装成json格式的字符串，将json格式的字符串响应到前端。</li><li>前端接收到json格式的字符串之后，解析这个json字符串，动态展示页面。</li></ul></li></ul><h2 id="附录http状态信息">附录：HTTP状态信息</h2><h3 id="xx-信息">1xx: 信息</h3><table><colgroup><col style="width: 27%" /><col style="width: 72%" /></colgroup><thead><tr><th style="text-align: left;">消息:</th><th style="text-align: left;">描述:</th></tr></thead><tbody><tr><td style="text-align: left;">100 Continue</td><tdstyle="text-align: left;">服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</td></tr><tr><td style="text-align: left;">101 Switching Protocols</td><tdstyle="text-align: left;">服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td></tr></tbody></table><h3 id="xx-成功">2xx: 成功</h3><table><colgroup><col style="width: 35%" /><col style="width: 64%" /></colgroup><thead><tr><th style="text-align: left;">消息:</th><th style="text-align: left;">描述:</th></tr></thead><tbody><tr><td style="text-align: left;">200 OK</td><tdstyle="text-align: left;">请求成功（其后是对GET和POST请求的应答文档。）</td></tr><tr><td style="text-align: left;">201 Created</td><td style="text-align: left;">请求被创建完成，同时新的资源被创建。</td></tr><tr><td style="text-align: left;">202 Accepted</td><tdstyle="text-align: left;">供处理的请求已被接受，但是处理未完成。</td></tr><tr><td style="text-align: left;">203 Non-authoritative Information</td><tdstyle="text-align: left;">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</td></tr><tr><td style="text-align: left;">204 No Content</td><tdstyle="text-align: left;">没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td></tr><tr><td style="text-align: left;">205 Reset Content</td><tdstyle="text-align: left;">没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</td></tr><tr><td style="text-align: left;">206 Partial Content</td><tdstyle="text-align: left;">客户发送了一个带有Range头的GET请求，服务器完成了它。</td></tr></tbody></table><h3 id="xx-重定向">3xx: 重定向</h3><table><colgroup><col style="width: 26%" /><col style="width: 73%" /></colgroup><thead><tr><th style="text-align: left;">消息:</th><th style="text-align: left;">描述:</th></tr></thead><tbody><tr><td style="text-align: left;">300 Multiple Choices</td><tdstyle="text-align: left;">多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td></tr><tr><td style="text-align: left;">301 Moved Permanently</td><td style="text-align: left;">所请求的页面已经转移至新的url。</td></tr><tr><td style="text-align: left;">302 Found</td><td style="text-align: left;">所请求的页面已经临时转移至新的url。</td></tr><tr><td style="text-align: left;">303 See Other</td><td style="text-align: left;">所请求的页面可在别的url下被找到。</td></tr><tr><td style="text-align: left;">304 Not Modified</td><tdstyle="text-align: left;">未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td></tr><tr><td style="text-align: left;">305 Use Proxy</td><tdstyle="text-align: left;">客户请求的文档应该通过Location头所指明的代理服务器提取。</td></tr><tr><td style="text-align: left;">306 <em>Unused</em></td><tdstyle="text-align: left;">此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</td></tr><tr><td style="text-align: left;">307 Temporary Redirect</td><td style="text-align: left;">被请求的页面已经临时移至新的url。</td></tr></tbody></table><h3 id="xx-客户端错误">4xx: 客户端错误</h3><table><colgroup><col style="width: 35%" /><col style="width: 64%" /></colgroup><thead><tr><th style="text-align: left;">消息:</th><th style="text-align: left;">描述:</th></tr></thead><tbody><tr><td style="text-align: left;">400 Bad Request</td><td style="text-align: left;">服务器未能理解请求。</td></tr><tr><td style="text-align: left;">401 Unauthorized</td><td style="text-align: left;">被请求的页面需要用户名和密码。</td></tr><tr><td style="text-align: left;">402 Payment Required</td><td style="text-align: left;">此代码尚无法使用。</td></tr><tr><td style="text-align: left;">403 Forbidden</td><td style="text-align: left;">对被请求页面的访问被禁止。</td></tr><tr><td style="text-align: left;">404 Not Found</td><td style="text-align: left;">服务器无法找到被请求的页面。</td></tr><tr><td style="text-align: left;">405 Method Not Allowed</td><td style="text-align: left;">请求中指定的方法不被允许。</td></tr><tr><td style="text-align: left;">406 Not Acceptable</td><td style="text-align: left;">服务器生成的响应无法被客户端所接受。</td></tr><tr><td style="text-align: left;">407 Proxy Authentication Required</td><tdstyle="text-align: left;">用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td></tr><tr><td style="text-align: left;">408 Request Timeout</td><td style="text-align: left;">请求超出了服务器的等待时间。</td></tr><tr><td style="text-align: left;">409 Conflict</td><td style="text-align: left;">由于冲突，请求无法被完成。</td></tr><tr><td style="text-align: left;">410 Gone</td><td style="text-align: left;">被请求的页面不可用。</td></tr><tr><td style="text-align: left;">411 Length Required</td><td style="text-align: left;">“Content-Length”未被定义。如果无此内容，服务器不会接受请求。</td></tr><tr><td style="text-align: left;">412 Precondition Failed</td><td style="text-align: left;">请求中的前提条件被服务器评估为失败。</td></tr><tr><td style="text-align: left;">413 Request Entity Too Large</td><tdstyle="text-align: left;">由于所请求的实体的太大，服务器不会接受请求。</td></tr><tr><td style="text-align: left;">414 Request-url Too Long</td><tdstyle="text-align: left;">由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</td></tr><tr><td style="text-align: left;">415 Unsupported Media Type</td><tdstyle="text-align: left;">由于媒介类型不被支持，服务器不会接受请求。</td></tr><tr><td style="text-align: left;">416</td><tdstyle="text-align: left;">服务器不能满足客户在请求中指定的Range头。</td></tr><tr><td style="text-align: left;">417 Expectation Failed</td><td style="text-align: left;"></td></tr></tbody></table><h3 id="xx-服务器错误">5xx: 服务器错误</h3><table><colgroup><col style="width: 37%" /><col style="width: 62%" /></colgroup><thead><tr><th style="text-align: left;">消息:</th><th style="text-align: left;">描述:</th></tr></thead><tbody><tr><td style="text-align: left;">500 Internal Server Error</td><tdstyle="text-align: left;">请求未完成。服务器遇到不可预知的情况。</td></tr><tr><td style="text-align: left;">501 Not Implemented</td><tdstyle="text-align: left;">请求未完成。服务器不支持所请求的功能。</td></tr><tr><td style="text-align: left;">502 Bad Gateway</td><tdstyle="text-align: left;">请求未完成。服务器从上游服务器收到一个无效的响应。</td></tr><tr><td style="text-align: left;">503 Service Unavailable</td><td style="text-align: left;">请求未完成。服务器临时过载或当机。</td></tr><tr><td style="text-align: left;">504 Gateway Timeout</td><td style="text-align: left;">网关超时。</td></tr><tr><td style="text-align: left;">505 HTTP Version Not Supported</td><tdstyle="text-align: left;">服务器不支持请求中指明的HTTP协议版本。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Servlet-JSP-课堂笔记</title>
      <link href="/posts/30777.html"/>
      <url>/posts/30777.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于直播">关于直播</h1><ol type="1"><li>什么时间直播？<ul><li>晚上8:00到10:00</li></ul></li><li>每周直播几天？<ul><li>3天（周一、周三、周五）</li><li>本周比较特殊：周四周五周六三天直播，从下周开始就是一三五直播。</li></ul></li><li>直播什么内容？<ul><li>从JavaWEB开始。（Servlet为核心，从Servlet开始学习。）</li><li>JSP（JSP使用较少了，但是还有用，所以时间上少一些。快速地学习一下JSP。）</li><li>AJAX（异步通信技术。）</li><li>jQuery（JavaScript库。）</li><li>MyBatis</li><li>Spring</li><li>SpringMVC</li><li>SpringBoot</li><li>SpringCloud</li><li>….</li></ul></li></ol><h1id="需要提前准备了哪些技术接下来的课才能听懂">需要提前准备了哪些技术，接下来的课才能听懂？</h1><ul><li>JavaSE（Java语言的标准版，Java提供的最基本的类库）<ul><li>Java的开发环境搭建</li><li>Java的基础语法</li><li>Java的面向对象</li><li>数组</li><li>常用类</li><li>异常</li><li>集合</li><li>多线程</li><li>IO流</li><li>反射机制</li><li>注解Annotation</li><li>…..</li></ul></li><li>MySQL（数据库）<ul><li>最基本的要求是：能够编写增删改查等简单的SQL语句即可。</li></ul></li><li>JDBC（Java语言链接数据库）<ul><li>这是一套Java语言链接数据库的接口。</li></ul></li><li>WEB前端（会一些）<ul><li>HTML（网页）</li><li>CSS（层叠样式表语言，修饰HTML）</li><li>JavaScript（一种脚本语言，运行在浏览器当中，让浏览器中的元素可以增删改。让网页产生更强的交互效果）</li></ul></li><li>WEB后端<ul><li>Servlet（Server Applet：服务器端的Java小程序）</li><li>JSP</li><li>AJAX</li><li>jQuery</li><li>MyBatis</li><li>Spring</li><li>SpringMVC</li><li>SpringBoot</li><li>SpringCloud</li><li>……</li></ul></li></ul><h1 id="typora软件介绍">Typora软件介绍</h1><ul><li>Markdown文本编辑器（可以编辑xxx.md文件）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test code!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="servlet">Servlet</h1><h2 id="关于系统架构">关于系统架构</h2><ol type="1"><li>系统架构包括什么形式？<ul><li>C/S架构</li><li>B/S架构</li></ul></li><li>C/S架构？<ul><li>Client / Server（客户端 / 服务器）</li><li>C/S架构的软件或者说系统有哪些呢？<ul><li>QQ（先去腾讯官网下载一个QQ软件，几十MB，然后把这个客户端软件安装上去，然后输入QQ号以及密码，登录之后，就可以和你的朋友聊天了，就可以使用这个软件了。）</li></ul></li><li>C/S架构的特点：需要安装特定的客户端软件。</li><li>C/S架构的系统优点和缺点分别是什么？<ul><li>优点：<ul><li>速度快（软件中的数据大部分都是集成到客户端软件当中的，很少量的数据从服务器端传送过来，所以C/S结构的系统速度快）</li><li>体验好（速度又快，界面又酷炫，当然体验好了。）</li><li>界面酷炫（专门的语言去实现界面的，更加灵活。）</li><li>服务器压力小（因为大量的数据都是集成在客户端软件当中，所以服务器只需要传送很少的数据量，当然服务器压力小。）</li><li>安全（因为大量的数据是集成在客户端软件当中的，并且客户端有很多个，服务器虽然只有一个，就算服务器那边地震了，火灾了，服务器受损了，问题也不大，因为大量的数据在多个客户端上有缓存，有存储，所以从这个方面来说，C/S结构的系统比较安全。）</li><li>…..</li></ul></li><li>缺点：<ul><li>升级维护比较差劲。（升级维护比较麻烦。成本比较高。每一个客户端软件都需要升级。有一些软件不是那么容易安装的。）</li></ul></li></ul></li></ul></li><li>B/S架构？<ul><li>B/S（Browser / Server，浏览器 / 服务器）</li><li>http://www.baidu.com</li><li>http://www.jd.com</li><li>http://www.126.com</li><li>B/S结构的系统是不是一个特殊的C/S系统？<ul><li>实际上B/S结构的系统还是一个C/S，只不过这个C比较特殊，这个Client是一个固定不变浏览器软件。</li></ul></li><li>B/S结构的系统优点和缺点是：<ul><li>优点：<ul><li>升级维护方便，成本比较低。（只需要升级服务器端即可。）</li><li>不需要安装特定的客户端软件，用户操作极其方便。只需要打开浏览器，输入网址即可。</li></ul></li><li>缺点：<ul><li>速度慢（不是因为带宽低的问题，是因为所有的数据都是在服务器上，用户发送的每一个请求都是需要服务器全身心的响应数据，所以B/S结构的系统在网络中传送的数据量比较大。）</li><li>体验差（界面不是那么酷炫，因为浏览器只支持三个语言HTML CSSJavaScript。在加上速度慢。）</li><li>不安全（所有的数据都在服务器上，只要服务器发生火灾，地震等不可抗力，最终数据全部丢失。）</li><li>….</li></ul></li></ul></li></ul></li><li>C/S和B/S结构的系统，哪个好，哪个不好？<ul><li>这个问题问的没有水平。并不是哪个好，哪个不好。不同结构的系统在不同的业务场景下有不同的适用场景。</li><li>娱乐性软件建议使用？<ul><li>C/S 结构</li></ul></li><li>公司内部使用的一些业务软件建议使用？<ul><li>公司内部使用的系统，需要维护成本低。</li><li>公司内部使用的系统，不需要很酷炫。</li><li>公司内部使用的企业级系统主要是能够进行数据的维护即可。</li><li>B/S 结构。</li></ul></li></ul></li><li>注意了：开发B/S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。<ul><li>开发一个WEB系统你需要会哪些技术？<ul><li>WEB前端（运行在浏览器上的程序。）<ul><li>HTML</li><li>CSS</li><li>JavaScript</li></ul></li><li>WEB后端（WEB服务器端的程序。）<ul><li>Java可以（Java做WEB开发我们称为JavaWEB开发。JavaWEB开发最核心的规范：Servlet【ServerApplet服务器端的Java小程序。】）</li><li>C语言也可以</li><li>C++也可以</li><li>Python也行</li><li>PHP也可以</li><li>….</li></ul></li></ul></li></ul></li><li>JavaEE是什么？<ul><li>Java包括三大块：<ul><li>JavaSE<ul><li>Java标准版（一套类库：别人写好的一套类库，只不过这个类库是标准类库，走EE，或者走ME，这个SE一定是基础，先学。）</li></ul></li><li>JavaEE（WEB方向，WEB系统。）<ul><li>Java企业版（也是一套类库：也是别人写好的一套类库，只不过这套类库可以帮助我们完成企业级项目的开发，专门为企业内部提供解决方案的一套（多套）类库。）</li><li>别人写好的，你用就行了，用它可以开发企业级项目。</li><li>可以开发web系统。</li><li>Java比较火爆的就是这个JavaEE方向。</li></ul></li><li>JavaME<ul><li>Java微型版（还是一套类库，只不过这套类库帮助我们进行电子微型设备内核程序的开发）</li><li>机顶盒内核程序，吸尘器内核程序，电冰箱内核程序，电饭煲内核程序。。。。。</li></ul></li></ul></li><li>JavaEE实际上包括很多种规范，13种规范，其中Servlet就是JavaEE规范之一。学Servlet还是Java语言。</li></ul></li></ol><h2id="bs结构的系统通信原理没有涉及到java小程序">B/S结构的系统通信原理（没有涉及到Java小程序）</h2><ul><li>WEB系统的访问过程<ul><li>第一步：打开浏览器</li><li>第二步：找到地址栏</li><li>第三步：输入一个合法的网址</li><li>第四步：回车</li><li>第五步：在浏览器上会展示响应的结果。</li></ul></li><li>关于域名：<ul><li>https://www.baidu.com/ （网址）</li><li>www.baidu.com 是一个域名</li><li>在浏览器地址栏上输入域名，回车之后，域名解析器会将域名解析出来一个具体的IP地址和端口号等。</li><li>解析结果也许是：http://110.242.68.3:80/index.html</li></ul></li><li>IP地址是啥？<ul><li>计算机在网络当中的一个身份证号。在同一个网络当中，IP地址是唯一的。</li><li>A计算机要想和B计算机通信，首先你需要知道B计算机的IP地址，有了IP地址才能建立连接。</li></ul></li><li>端口号是啥？<ul><li>一个端口代表一个软件（一个端口代表一个应用，一个端口仅代表一个服务）。</li><li>一个计算机当中有很多软件，每一个软件启动之后都有一个端口号。</li><li>在同一个计算机上，端口号具有唯一性。</li></ul></li><li>一个WEB系统的通信原理？通信步骤：<ul><li>第一步：用户输入网址（URL）</li><li>第二步：域名解析器进行域名解析：http://110.242.68.3:80/index.html</li><li>第三步：浏览器软件在网络中搜索110.242.68.3这一台主机，直到找到这台主机。</li><li>第四步：定位110.242.68.3这台主机上的服务器软件，因为是80端口，可以很轻松的定位到80端口对应的服务器软件。</li><li>第五步：80端口对应的服务器软件得知浏览器想要的资源名是：index.html</li><li>第六步：服务器软件找到index.html文件，并且将index.html文件中的内容直接输出响应到浏览器上。</li><li>第七步：浏览器接收到来自服务器的代码（HTML CSS JS）</li><li>第八步：浏览器渲染，执行HTML CSS JS代码，展示效果。</li></ul></li><li>什么是URL？<ul><li>统一资源定位符（http://www.baidu.com）</li></ul></li><li>什么是请求，什么是响应？<ul><li>请求和响应实际上说的是数据的流向不同。</li><li>从Browser端发送数据到Server端，我们称为请求。英语单词：request</li><li>从Server端向浏览器Browser端发送数据，我们称为响应。英语单词：response</li><li>B –&gt; S （请求request）</li><li>S –&gt; B （响应response）</li></ul></li></ul><h2 id="关于web服务器软件">关于WEB服务器软件</h2><ul><li><p>WEB服务器软件都有哪些呢？（这些软件都是提前开发好的。）</p><ul><li>Tomcat（WEB服务器）</li><li>jetty（WEB服务器）</li><li>JBOSS（应用服务器）</li><li>WebLogic（应用服务器）</li><li>WebSphere（应用服务器）</li></ul></li><li><p>应用服务器和WEB服务器的关系？</p><ul><li>应用服务器实现了JavaEE的所有规范。(JavaEE有13个不同的规范。)</li><li>WEB服务器只实现了JavaEE中的Servlet + JSP两个核心的规范。</li><li>通过这个讲解说明了：应用服务器是包含WEB服务器的。</li><li>用过JBOSS服务器的同学应该很清楚，JBOSS中内嵌了一个Tomcat服务器。</li></ul></li><li><p>Tomcat下载</p><ul><li>apache官网地址：https://www.apache.org/</li><li>tomcat官网地址：https://tomcat.apache.org</li><li>tomcat开源免费的轻量级WEB服务器。</li><li>tomcat还有另外一个名字：catalina（catalina是美国的一个岛屿，风景秀丽，据说作者是在这个风景秀丽的小岛上开发了一个轻量级的WEB服务器，体积小，运行速度快，因此tomcat又被称为catalina）</li><li>tomcat的logo是一只公猫（寓意表示Tomcat服务器是轻巧的，小巧的，果然，体积小，运行速度快，只实现了Servlet+JSP规范）</li><li>tomcat是java语言写的。</li><li>tomcat服务器要想运行，必须先又jre（Java的运行时环境）</li></ul></li><li><p>Tomcat服务器要想运行，需要先有jre，所以要先安装JDK，配置java运行环境。</p><ul><li>JAVA_HOME=C:Files.1</li><li>PATH=%JAVA_HOME%</li><li>目前JAVA_HOME没有配置，思考一个问题，这样行不行呢？目前只运行java程序是没问题的。真的没问题吗？</li></ul></li><li><p>Tomcat服务器的安装：</p><ul><li>绿色版本的安装很简单，直接zip包解压即可。解压就是安装。</li><li>我有一个好习惯，在C盘的根目录下新建一个dev目录，java开发所有相关的工具都安装到dev目录下，这样比较方便管理。（你随意）</li><li>启动Tomcat<ul><li>bin目录下有一个文件：startup.bat,通过它可以启动Tomcat服务器。<ul><li>xxx.bat文件是个什么文件？bat文件是windows操作系统专用的，bat文件是批处理文件，这种文件中可以编写大量的windows的dos命令，然后执行bat文件就相当于批量的执行dos命令。</li><li>startup.sh，这个文件在windows当中无法执行，在Linux环境当中可以使用。在Linux环境下能够执行的是shell命令，大量的shell命令编写在shell文件当中，然后执行这个shell文件可以批量的执行shell命令。</li><li>tomcat服务器提供了bat和sh文件，说明了这个tomcat服务器的通用性。</li><li>分析startup.bat文件得出，执行这个命令，实际上最后是执行：catalina.bat文件。</li><li>catalina.bat文件中有这样一行配置：MAINCLASS=org.apache.catalina.startup.Bootstrap（这个类就是main方法所在的类。）</li><li>tomcat服务器就是Java语言写的，既然是java语言写的，那么启动Tomcat服务器就是执行main方法。</li></ul></li><li>我们尝试打开dos命令窗口，在dos命令窗口中输入startup.bat来启动tomcat服务器。</li><li>启动Tomcat服务器只配置path对应的bin目录是不行的。有两个环境变量需要配置：<ul><li>JAVA_HOME=JDK的根</li><li>CATALINA_HOME=Tomcat服务器的根</li></ul></li></ul></li></ul></li><li><p>关于Tomcat服务器的目录</p><ul><li>bin ：这个目录是Tomcat服务器的命令文件存放的目录，比如：启动Tomcat，关闭Tomcat等。</li><li>conf：这个目录是Tomcat服务器的配置文件存放目录。（server.xml文件中可以配置端口号，默认Tomcat端口是8080）</li><li>lib：这个目录是Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。</li><li>logs:Tomcat服务器的日志目录，Tomcat服务器启动等信息都会在这个目录下生成日志文件。</li><li>temp：Tomcat服务器的临时目录。存储临时文件。</li><li>webapps：这个目录当中就是用来存放大量的webapp（webapplication：web应用）</li><li>work：这个目录是用来存放JSP文件翻译之后的java文件以及编译之后的class文件。</li></ul></li><li><p>配置Tomcat服务器需要哪些环境变量？</p><ul><li>JAVA_HOME=JDK的根</li><li>CATALINA_HOME=Tomcat服务器的根</li><li>PATH=%JAVA_HOME%;%CATALINA_HOME%</li></ul></li><li><p>启动Tomcat： startup</p></li><li><p>关闭Tomcat：stop（shutdown.bat文件重命名为stop.bat，为什么？原因是shutdown命令和windows中的关机命令冲突。所以修改一下。）</p></li><li><p>怎么测试Tomcat服务器有没有启动成功呢？</p><ul><li>打开浏览器，在浏览器的地址栏上输入URL即可：<ul><li>http://ip地址:端口号</li><li>ip地址是什么？端口号我知道，是8080</li><li>本机的IP地址是：127.0.0.1，或者是localhost，都行。</li></ul></li></ul></li></ul><h2id="实现一个最基本的web应用这个web应用中没有java小程序">实现一个最基本的web应用（这个web应用中没有java小程序）</h2><ul><li><p>第一步：找到CATALINA_HOME</p><ul><li>因为所有的webapp要放到webapps目录下。（没有为什么，这是Tomcat服务器的要求。如果不放到这里，Tomcat服务器找不到你的应用。）</li></ul></li><li><p>第二步：在CATALINA_HOME，起名：oa</p><ul><li>这个目录名oa就是你这个webapp的名字。</li></ul></li><li><p>第三步：在oa目录下新建资源文件，例如：index.html</p><ul><li>编写index.html文件的内容。</li></ul></li><li><p>第四步：启动Tomcat服务器</p></li><li><p>第五步：打开浏览器，在浏览器地址栏上输入这样的URL：</p></li><li><p>http://127.0.0.1:8080/oa/index.html</p></li><li><p>思考一个问题：</p><ul><li>我们在浏览器上直接输入一个URL，然后回车。这个动作和超链接一样吗？既然是一样的，我们完全可以使用超链接。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注意以下的路径，以/开始，带项目名，是一个绝对路径。不需要添加：http://127.0.0.1:8080--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oa/login.html&quot;</span>&gt;</span>user login2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--多个层级也没有关系，正常访问即可。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意：我们目前前端上的路径都以“/”开始的，都是加项目名的。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oa/test/debug/d.html&quot;</span>&gt;</span>d page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>http://127.0.0.1:8080/oa/userList.html<ul><li>访问这个地址，可以展示一个用户列表页面。但是这个用户列表页面是写死在HTML文件当中的。这种资源我们称为静态资源。怎么能变成动态资源。显然需要连接数据库。</li><li>连接数据库需要JDBC程序，也就是说需要编写Java程序连接数据库，数据库中有多少条记录，页面上就显示多少条记录，这种技术被称为动态网页技术。（动态网页技术并不是说页面中有flash动画。动态网页技术是说页面中的数据是动态的，根据数据库中数据的变化而变化。）</li></ul></li></ul><h2id="对于一个动态的web应用来说一个请求和响应的过程有多少个角色参与角色和角色之间有多少个协议">对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议</h2><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202305181943690.png"alt="BS结构系统的通信原理2" /><figcaption aria-hidden="true">BS结构系统的通信原理2</figcaption></figure><ul><li>有哪些角色（在整个BS结构的系统当中，有哪些人参与进去了）<ul><li>浏览器软件的开发团队（浏览器软件太多了：谷歌浏览器、火狐浏览器、IE浏览器….）</li><li>WEB Server的开发团队（WEBServer这个软件也是太多了：Tomcat、Jetty、WebLogic、JBOSS、WebSphere….）</li><li>DB Server的开发团队（DBServer这个软件也是太多了：Oracle、MySQL…..）</li><li>webapp的开发团队（WEB应用是我们做为JavaWEB程序员开发的）</li></ul></li><li>角色和角色之间需要遵守哪些规范，哪些协议<ul><li>webapp的开发团队 和 WEB Server的开发团队 之间有一套规范:JavaEE规范之一Servlet规范。<ul><li>Servlet规范的作用是什么？<ul><li>WEB Server 和 webapp解耦合。</li></ul></li></ul></li><li>Browser 和WebServer之间有一套传输协议：HTTP协议。（超文本传输协议。）</li><li>webapp开发团队 和 DB Server的开发团队之间有一套规范：JDBC规范。</li></ul></li></ul><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202305181943758.png"alt="BS结构系统的角色和协议" /><figcaption aria-hidden="true">BS结构系统的角色和协议</figcaption></figure><ul><li>Servlet规范是一个什么规范？<ul><li>遵循Servlet规范的webapp，这个webapp就可以放在不同的WEB服务器中运行。（因为这个webapp是遵循Servlet规范的。）</li><li>Servlet规范包括什么呢？<ul><li>规范了哪些接口</li><li>规范了哪些类</li><li>规范了一个web应用中应该有哪些配置文件</li><li>规范了一个web应用中配置文件的名字</li><li>规范了一个web应用中配置文件存放的路径</li><li>规范了一个web应用中配置文件的内容</li><li>规范了一个合法有效的web应用它的目录结构应该是怎样的。</li><li>…..</li></ul></li></ul></li></ul><h2id="开发一个带有servletjava小程序的webapp重点">开发一个带有Servlet（Java小程序）的webapp（重点）</h2><ul><li><p>开发步骤是怎样的？</p><ul><li><p>第一步：在webapps目录下新建一个目录，起名crm（这个crm就是webapp的名字）。当然，也可以是其它项目，比如银行项目，可以创建一个目录bank，办公系统可以创建一个oa。</p><ul><li>注意：crm就是这个webapp的根</li></ul></li><li><p>第二步：在webapp的根下新建一个目录：WEB-INF</p><ul><li>注意：这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样。必须的必须。</li></ul></li><li><p>第三步：在WEB-INF目录下新建一个目录：classes</p><ul><li>注意：这个目录的名字必须是全部小写的classes。这也是Servlet规范中规定的。另外这个目录下一定存放的是Java程序编译之后的class文件（这里存放的是字节码文件）。</li></ul></li><li><p>第四步：在WEB-INF目录下新建一个目录：lib</p><ul><li>注意：这个目录不是必须的。但如果一个webapp需要第三方的jar包的话，这个jar包要放到这个lib目录下，这个目录的名字也不能随意编写，必须是全部小写的lib。例如java语言连接数据库需要数据库的驱动jar包。那么这个jar包就一定要放到lib目录下。这Servlet规范中规定的。</li></ul></li><li><p>第五步：在WEB-INF目录下新建一个文件：web.xml</p><ul><li><p>注意：这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。</p></li><li><p>这个文件最好从其他的webapp中拷贝，最好别手写。没必要。复制粘贴</p></li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>第六步：编写一个Java程序，这个小Java程序也不能随意开发，这个小java程序必须实现Servlet接口。</p><ul><li>这个Servlet接口不在JDK当中。（因为Servlet不是JavaSE了。Servlet属于JavaEE，是另外的一套类库。）</li><li>Servlet接口（Servlet.class文件）是Oracle提供的。（最原始的是sun公司提供的。）</li><li>Servlet接口是JavaEE的规范中的一员。</li><li>Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Servlet接口。Tomcat服务器中应该有这个接口，Tomcat服务器的CATALINA_HOME-api.jar，解压这个servlet-api.jar之后，你会看到里面有一个Servlet.class文件。</li><li>重点：从JakartaEE9开始，Servlet接口的全名变了：jakarta.servlet.Servlet</li><li>注意：编写这个Java小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。</li></ul></li><li><p>第七步：编译我们编写的HelloServlet</p><ul><li><p>重点：你怎么能让你的HelloServlet编译通过呢？配置环境变量CLASSPATH</p><p>CLASSPATH=.;C:-tomcat-10.0.12-api.jar</p></li><li><p>思考问题：以上配置的CLASSPATH和Tomcat服务器运行有没有关系？</p><ul><li>没有任何关系，以上配置这个环境变量只是为了让你的HelloServlet能够正常编译生成class文件。</li></ul></li></ul></li><li><p>第八步：将以上编译之后的HelloServlet.class文件拷贝到WEB-INF。</p></li><li><p>第九步：在web.xml文件中编写配置信息，让“请求路径”和“Servlet类名”关联在一起。</p><ul><li>这一步用专业术语描述：在web.xml文件中注册Servlet类。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--servlet描述信息--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--任何一个servlet都对应一个servlet-mapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>fdsafdsagfdsafdsa<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个位置必须是带有包名的全限定类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--servlet映射信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个也是随便的，不过这里写的内容要和上面的一样。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>fdsafdsagfdsafdsa<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里需要一个路径--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个路径唯一的要求是必须以 / 开始--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当前这个路径可以随便写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/fdsa/fd/saf/d/sa/fd/sa/fd<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>第十步：启动Tomcat服务器</p></li><li><p>第十一步：打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是：</p><ul><li>http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd<br /></li><li>非常重要的一件事：浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的url-pattern一致。</li><li>注意：浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是：浏览器上的请求路径带项目名：/crm</li></ul></li><li><p>浏览器上编写的路径太复杂，可以使用超链接。（<strong>非常重要：html页面只能放到WEB-INF目录外面。</strong>）</p></li><li><p>以后不需要我们编写main方法了。tomcat服务器负责调用main方法，Tomcat服务器启动的时候执行的就是main方法。我们javaweb程序员只需要编写Servlet接口的实现类，然后将其注册到web.xml文件中，即可。</p></li><li><p>总结一下：一个合法的webapp目录结构应该是怎样的？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webapproot</span><br><span class="line">     |------WEB-INF</span><br><span class="line">       |------classes(存放字节码)</span><br><span class="line">       |------lib(第三方jar包)</span><br><span class="line">       |------web.xml(注册Servlet)</span><br><span class="line">     |------html</span><br><span class="line">     |------css</span><br><span class="line">     |------javascript</span><br><span class="line">     |------image</span><br><span class="line">     ....</span><br></pre></td></tr></table></figure><ul><li><p>浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程？（以下这个过程描述的很粗糙。其中还有很多步骤我省略了。）</p><ul><li>用户输入URL，或者直接点击超链接：http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd<br /></li><li>然后Tomcat服务器接收到请求，截取路径：/crm/fdsa/fd/saf/d/sa/fd/sa/fd<br /></li><li>Tomcat服务器找到crm项目</li><li>Tomcat服务器在web.xml文件中查找/fdsa/fd/saf/d/sa/fd/sa/fd对应的Servlet是：com.bjpowernode.servlet.HelloServlet</li><li>Tomcat服务器通过反射机制，创建com.bjpowernode.servlet.HelloServlet的对象。</li><li>Tomcat服务器调用com.bjpowernode.servlet.HelloServlet对象的service方法。</li></ul></li></ul><h2 id="关于javaee的版本">关于JavaEE的版本</h2><ul><li>JavaEE目前最高版本是 JavaEE8</li><li>JavaEE被Oracle捐献了，Oracle将JavaEE规范捐献给Apache了。</li><li>Apache把JavaEE换名了，以后不叫JavaEE了，以后叫做 jakarta EE。</li><li>以后没有JavaEE了。以后都叫做Jakarta EE。</li><li>JavaEE8版本升级之后的”JavaEE9”，不再是”JavaEE9”这个名字了，叫做JakartaEE9</li><li>JavaEE8的时候对应的Servlet类名是：javax.servlet.Servlet</li><li>JakartaEE9的时候对应的Servlet类名是：jakarta.servlet.Servlet（包名都换了）</li><li>如果你之前的项目还是在使用javax.servlet.Servlet，那么你的项目无法直接部署到Tomcat10+版本上。你只能部署到Tomcat9-版本上。在Tomcat9以及Tomcat9之前的版本中还是能够识别javax.servlet这个包。</li></ul><h2id="解决tomcat服务器在dos命令窗口中的乱码问题控制台乱码">解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）</h2><p>将CATALINA_HOME/conf/logging.properties文件中的内容修改如下：</p><p>java.util.logging.ConsoleHandler.encoding = GBK</p><h2 id="向浏览器响应一段html代码">向浏览器响应一段HTML代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">    out.print(<span class="string">&quot;&lt;h1&gt;hello servlet!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="在servlet中连接数据库怎么做">在Servlet中连接数据库，怎么做？</h2><ul><li>Servlet是Java程序，所以在Servlet中完全可以编写JDBC代码连接数据库。</li><li>在一个webapp中去连接数据库，需要将驱动jar包放到WEB-INF/lib目录下。（com.mysql.cj.jdbc.Driver这个类就在驱动jar包当中。）</li></ul><h2id="在集成开发环境当中开发servlet程序">在集成开发环境当中开发Servlet程序</h2><ul><li><p>集成开发工具很多，其中目前使用比较多的是：</p><ul><li>IntelliJIDEA（这个居多，IDEA在提示功能方面要强于Eclipse，也就是说IDEA使用起来比Eclipse更加智能，更好用。JetBrain公司开发的。收费的。）</li><li>Eclipse（这个少一些），Eclipse目前还是有团队使用，只不过处于减少的趋势，自己从事工作之后，可能会遇到。Eclipse是IBM团队开发的。Eclipse寓意是“日食”。“日食”表示将太阳吃掉。太阳是SUN。IBM团队开发Eclipse的寓意是吞并SUN公司，但是2009年的时候SUN公司被Oracle公司并购了。IBM并没有成功并购SUN公司。</li></ul></li><li><p>使用IDEA集成开发工具开发Servlet</p><ul><li>第一步：New Project（我比较习惯先创建一个EmptyProject【空工程】，然后在空工程下新建Module【模块】，这不是必须的，只是一种习惯，你可以直接新建非空的Project），这个EmptyProject起名为：javaweb（不是必须的，只是一个名字而已。一般情况下新建的Project的名字最好和目录的名字一致。）</li><li>第二步：新建模块（File –&gt; new –&gt; Module…）<ul><li>这里新建的是一个普通的JavaSE模块（这里先不要新建JavaEnterprise模块）</li><li>这个Module自动会被放在javaweb的project下面。</li><li>这个Module起名：servlet01</li></ul></li><li>第三步：让Module变成JavaEE的模块。（让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module）<ul><li>在Module上点击右键：Add Framework Support…（添加框架支持）</li><li>在弹出的窗口中，选择Web Application（选择的是webapp的支持）</li><li>选择了这个webapp的支持之后，IDEA会自动给你生成一个符合Servlet规范的webpp目录结构。</li><li><strong>重点，需要注意的：在IDEA工具中根据WebApplication模板生成的目录中有一个web目录，这个目录就代表webapp的根</strong></li></ul></li><li>第四步（非必须）：根据WebApplication生成的资源中有index.jsp文件，这里我选择删除这个index.jsp文件。</li><li>第五步：编写Servlet（StudentServlet）<ul><li>class StudentServlet implements Servlet</li><li>这个时候发现Servlet.class文件没有。怎么办？将CATALINA_HOME/lib/servlet-api.jar和jsp-api.jar添加到classpath当中（这里的classpath说的是IDEA的classpath）<ul><li>File –&gt; Project Structrue –&gt; Modules –&gt; + 加号 –&gt; AddJARS….</li></ul></li><li>实现jakarta.servlet.Servlet接口中的5个方法。</li></ul></li><li>第六步：在Servlet当中的service方法中编写业务代码（我们这里连接数据库了。）</li><li>第七步：在WEB-INF目录下新建了一个子目录：lib（这个目录名可不能随意，必须是全部小写的lib），并且将连接数据库的驱动jar包放到lib目录下。</li><li>第八步：在web.xml文件中完成StudentServlet类的注册。（请求路径和Servlet之间对应起来）</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.StudentServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/student<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>第九步：给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。</p><ul><li><p>student.html</p></li><li><p>这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。</p></li><li><p>student.html文件的内容</p></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>student page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里的项目名是 /xmm ，无法动态获取，先写死--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/xmm/servlet/student&quot;</span>&gt;</span>student list<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>第十步：让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。</p><ul><li>IDEA工具右上角，绿色小锤子右边有一个：Add Configuration</li><li>左上角加号，点击Tomcat Server –&gt; local</li><li>在弹出的界面中设置服务器Server的参数（基本上不用动）</li><li>在当前窗口中有一个Deployment（点击这个用来部署webapp），继续点击加号，部署即可。</li><li>修改 Application context为：/xmm</li></ul></li><li><p>第十一步：启动Tomcat服务器</p><ul><li>在右上角有绿色的箭头，或者绿色的小虫子，点击这个绿色的小虫子，可以采用debug的模式启动Tomcat服务器。</li><li>我们开发中建议适用debug模式启动Tomcat</li></ul></li><li><p>第十二步：打开浏览器，在浏览器地址栏上输入：http://localhost:8080/xmm/student.html</p></li></ul><h2 id="servlet对象的生命周期">Servlet对象的生命周期</h2><ul><li><p>什么是Servlet对象生命周期？</p><ul><li>Servlet对象什么时候被创建。</li><li>Servlet对象什么时候被销毁。</li><li>Servlet对象创建了几个？</li><li>Servlet对象的生命周期表示：一个Servlet对象从出生在最后的死亡，整个过程是怎样的。</li></ul></li><li><p>Servlet对象是由谁来维护的？</p><ul><li>Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。</li><li>Servlet对象的生命周期是由Tomcat服务器（WEB Server）全权负责的。</li><li>Tomcat服务器通常我们又称为：WEB容器。（这个叫法你要知道【WEBContainer】）</li><li>WEB容器来管理Servlet对象的死活。</li></ul></li><li><p>思考：我们自己new的Servlet对象受WEB容器的管理吗？</p><ul><li>我们自己new的Servlet对象是不受WEB容器管理的。</li><li>WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中（HashMap），只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。（自己new的Servlet对象不在容器当中）</li><li>web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系</li></ul></li></ul><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202305181944310.png"alt="WEB容器中的Map集合" /><figcaption aria-hidden="true">WEB容器中的Map集合</figcaption></figure><ul><li><p>研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？</p><ul><li>在Servlet中提供一个无参数的构造方法，启动服务器的时候看看构造方法是否执行。</li><li>经过测试得出结论：默认情况下，服务器在启动的时候Servlet对象并不会被实例化。</li><li>这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。</li></ul></li><li><p>怎么让服务器启动的时候创建Servlet对象呢？</p><ul><li>在servlet标签中添加<code>&lt;load-on-startup&gt;</code>子标签，在该子标签中填写整数，越小的整数优先级越高。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>aservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.AServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>aservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>Servlet对象生命周期</p><ul><li>默认情况下服务器启动的时候AServlet对象并没有被实例化</li><li>用户发送第一次请求的时候，控制台输出了以下内容：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AServlet无参数构造方法执行了</span><br><span class="line">AServlet&#x27;s init method execute!</span><br><span class="line">AServlet&#x27;s service method execute!</span><br></pre></td></tr></table></figure><ul><li><p>根据以上输出内容得出结论：</p><ul><li>用户在发送第一次请求的时候Servlet对象被实例化（AServlet的构造方法被执行了。并且执行的是无参数构造方法。）</li><li>AServlet对象被创建出来之后，Tomcat服务器马上调用了AServlet对象的init方法。（init方法在执行的时候，AServlet对象已经存在了。已经被创建出来了。）</li><li>用户发送第一次请求的时候，init方法执行之后，Tomcat服务器马上调用AServlet对象的service方法。</li></ul></li><li><p>用户继续发送第二次请求，控制台输出了以下内容：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AServlet&#x27;s service method execute!</span><br></pre></td></tr></table></figure><ul><li><p>根据以上输出结果得知，用户在发送第二次，或者第三次，或者第四次请求的时候，Servlet对象并没有新建，还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明：</p><ul><li>第一：Servlet对象是单例的（单实例的。但是要注意：Servlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为假单例。之所以单例是因为Servlet对象的创建我们javaweb程序员管不着，这个对象的创建只能是Tomcat来说了算，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。）</li><li>第二：无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。</li><li>第三：只要用户发送一次请求：service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。</li></ul></li><li><p>关闭服务器的时候，控制台输出了以下内容：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AServlet&#x27;s destroy method execute!</span><br></pre></td></tr></table></figure><ul><li><p>通过以上输出内容，可以得出以下结论：</p><ul><li>Servlet的destroy方法只被Tomcat服务器调用一次。</li><li>destroy方法是在什么时候被调用的？<ul><li>在服务器关闭的时候。</li><li>因为服务器关闭的时候要销毁AServlet对象的内存。</li><li>服务器在销毁AServlet对象内存之前，Tomcat服务器会自动调用AServlet对象的destroy方法。</li></ul></li></ul></li><li><p>请问：destroy方法调用的时候，对象销毁了还是没有销毁呢？</p><ul><li>destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。</li></ul></li><li><p>Servlet对象更像一个人的一生：</p><ul><li>Servlet的无参数构造方法执行：标志着你出生了。</li><li>Servlet对象的init方法的执行：标志着你正在接受教育。</li><li>Servlet对象的service方法的执行：标志着你已经开始工作了，已经开始为人类提供服务了。</li><li>Servlet对象的destroy方法的执行：标志着临终。有什么遗言，抓紧的。要不然，来不及了。</li></ul></li><li><p>关于Servlet类中方法的调用次数？</p><ul><li>构造方法只执行一次。</li><li>init方法只执行一次。</li><li>service方法：用户发送一次请求则执行一次，发送N次请求则执行N次。</li><li>destroy方法只执行一次。</li></ul></li><li><p>当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题？</p><ul><li>报错了：500错误。</li><li>注意：500是一个HTTP协议的错误状态码。</li><li>500一般情况下是因为服务器端的Java程序出现了异常。（服务器端的错误都是500错误：服务器内部错误。）</li><li>如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。</li><li>所以，一定要注意：在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。</li></ul></li><li><p>思考：Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗？</p><ul><li>不能。</li><li>Servlet规范中有要求，作为javaweb程序员，编写Servlet类的时候，不建议手动编写构造方法，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。</li></ul></li><li><p>init、service、destroy方法中使用最多的是哪个方法？</p><ul><li>使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。</li><li>什么时候使用init方法呢？<ul><li>init方法很少用。</li><li>通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如：初始化数据库连接池，初始化线程池….</li></ul></li><li>什么时候使用destroy方法呢？<ul><li>destroy方法也很少用。</li><li>通常在destroy方法当中，进行资源的关闭。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的，抓紧时间保存一下。</li></ul></li></ul></li></ul><h2 id="genericservlet">GenericServlet</h2><ul><li><p>我们编写一个Servlet类直接实现Servlet接口有什么缺点？</p><ul><li>我们只需要service方法，其他方法大部分情况下是不需要使用的。代码很丑陋。</li></ul></li><li><p>适配器设计模式Adapter</p><ul><li>手机直接插到220V的电压上，手机直接就报废了。怎么办？可以找一个充电器。这个充电器就是一个适配器。手机连接适配器。适配器连接220V的电压。这样问题就解决了。</li></ul></li><li><p>编写一个GenericServlet类，这个类是一个抽象类，其中有一个抽象方法service。</p><ul><li>GenericServlet实现Servlet接口。</li><li>GenericServlet是一个适配器。</li><li>以后编写的所有Servlet类继承GenericServlet，重写service方法即可。</li></ul></li><li><p>思考：GenericServlet类是否需要改造一下？怎么改造？更利于子类程序的编写？</p><ul><li><p>思考第一个问题：我提供了一个GenericServlet之后，init方法还会执行吗？</p><ul><li>还会执行。会执行GenericServlet类中的init方法。</li></ul></li><li><p>思考第二个问题：init方法是谁调用的？</p><ul><li>Tomcat服务器调用的。</li></ul></li><li><p>思考第三个问题：init方法中的ServletConfig对象是谁创建的？是谁传过来的？</p><ul><li>都是Tomcat干的。</li><li>Tomcat服务器先创建了ServletConfig对象，然后调用init方法，将ServletConfig对象传给了init方法。</li></ul></li><li><p>思考一下Tomcat服务器伪代码：</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tomcat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// Tomcat服务器伪代码</span></span><br><span class="line">        <span class="comment">// 创建LoginServlet对象（通过反射机制，调用无参数构造方法来实例化LoginServlet对象）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bjpowernode.javaweb.servlet.LoginServlet&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> (Servlet)obj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ServletConfig对象</span></span><br><span class="line">        <span class="comment">// Tomcat服务器负责将ServletConfig对象实例化出来。</span></span><br><span class="line">        <span class="comment">// 多态（Tomcat服务器完全实现了Servlet规范）</span></span><br><span class="line">        <span class="type">ServletConfig</span> <span class="variable">servletConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.catalina.core.StandardWrapperFacade();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Servlet的init方法</span></span><br><span class="line">        servlet.init(servletConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Servlet的service方法</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="servletconfig">ServletConfig</h2><ul><li><p>什么是ServletConfig？</p><ul><li>Servlet对象的配置信息对象。</li><li>ServletConfig对象中封装了<code>&lt;servlet&gt;&lt;/servlet&gt;</code>标签中的配置信息。（web.xml文件中servlet的配置信息）</li></ul></li><li><p>一个Servlet对应一个ServletConfig对象。</p></li><li><p>Servlet对象是Tomcat服务器创建，并且ServletConfig对象也是Tomcat服务器创建。并且默认情况下，他们都是在用户发送第一次请求的时候创建。</p></li><li><p>Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。</p></li><li><p>ServletConfig接口的实现类是Tomcat服务器给实现的。（Tomcat服务器说的就是WEB服务器。）</p></li><li><p>ServletConfig接口有哪些常用的方法？</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span>; <span class="comment">// 通过初始化参数的name获取value</span></span><br><span class="line"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getInitParameterNames</span><span class="params">()</span>; <span class="comment">// 获取所有的初始化参数的name</span></span><br><span class="line"><span class="keyword">public</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span>; <span class="comment">// 获取ServletContext对象</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletName</span><span class="params">()</span>; <span class="comment">// 获取Servlet的name</span></span><br></pre></td></tr></table></figure><ul><li>以上方法在Servlet类当中，都可以使用this去调用。因为GenericServlet实现了ServletConfig接口。</li></ul><h2 id="servletcontext">ServletContext</h2><ul><li><p>一个Servlet对象对应一个ServletConfig。100个Servlet对象则对应100个ServletConfig对象。</p></li><li><p>只要在同一个webapp当中，只要在同一个应用当中，所有的Servlet对象都是共享同一个ServletContext对象的。</p></li><li><p>ServletContext对象在服务器启动阶段创建，在服务器关闭的时候销毁。这就是ServletContext对象的生命周期。ServletContext对象是应用级对象。</p></li><li><p>Tomcat服务器中有一个webapps，这个webapps下可以存放webapp，可以存放多个webapp，假设有100个webapp，那么就有100个ServletContext对象。但是，总之，一个应用，一个webapp肯定是只有一个ServletContext对象。</p></li><li><p>ServletContext被称为Servlet上下文对象。（Servlet对象的四周环境对象。）</p></li><li><p>一个ServletContext对象通常对应的是一个web.xml文件。</p></li><li><p>ServletContext对应显示生活中的什么例子呢？</p><ul><li>一个教室里有多个学生，那么每一个学生就是一个Servlet，这些学生都在同一个教室当中，那么我们可以把这个教室叫做ServletContext对象。那么也就是说放在这个ServletContext对象（环境）当中的数据，在同一个教室当中，物品都是共享的。比如：教室中有一个空调，所有的学生都可以操作。可见，空调是共享的。因为空调放在教室当中。教室就是ServletContext对象。</li></ul></li><li><p>ServletContext是一个接口，Tomcat服务器对ServletContext接口进行了实现。</p><ul><li>ServletContext对象的创建也是Tomcat服务器来完成的。启动webapp的时候创建的。</li></ul></li><li><p>ServletContext接口中有哪些常用的方法？</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span>; <span class="comment">// 通过初始化参数的name获取value</span></span><br><span class="line"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getInitParameterNames</span><span class="params">()</span>; <span class="comment">// 获取所有的初始化参数的name</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息？是以下的配置信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>pageSize<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>startIndex<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意：以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用ServletConfig对象来获取。--&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取应用的根路径（非常重要），因为在java源代码当中有一些地方可能会需要应用的根路径，这个方法可以动态获取应用的根路径</span></span><br><span class="line"><span class="comment">// 在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getContextPath</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//String contextPath = application.getContextPath();</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件的绝对路径（真实路径）</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getRealPath</span><span class="params">(String path)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ServletContext对象也是可以记录日志的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message, Throwable t)</span>;</span><br><span class="line"><span class="comment">// 这些日志信息记录到哪里了？</span></span><br><span class="line"><span class="comment">// localhost.2021-11-05.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tomcat服务器的logs目录下都有哪些日志文件？</span></span><br><span class="line"><span class="comment">//catalina.2021-11-05.log 服务器端的java程序运行的控制台信息。</span></span><br><span class="line"><span class="comment">//localhost.2021-11-05.log ServletContext对象的log方法记录的日志信息存储到这个文件中。</span></span><br><span class="line"><span class="comment">//localhost_access_log.2021-11-05.txt 访问日志</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServletContext对象还有另一个名字：应用域（后面还有其他域，例如：请求域、会话域）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么是所有用户共享的数据？ 不是共享的没有意义。因为ServletContext这个对象只有一个。只有共享的数据放进去才有意义。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么数据量要小？ 因为数据量比较大的话，太占用堆内存，并且这个对象的生命周期比较长，服务器关闭的时候，这个对象才会被销毁。大数据量会影响服务器的性能。占用内存较小的数据量可以考虑放进去。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么这些共享数据很少的修改，或者说几乎不修改？</span></span><br><span class="line"><span class="comment">// 所有用户共享的数据，如果涉及到修改操作，必然会存在线程并发所带来的安全问题。所以放在ServletContext对象中的数据一般都是只读的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据量小、所有用户共享、又不修改，这样的数据放到ServletContext这个应用域当中，会大大提升效率。因为应用域相当于一个缓存，放到缓存中的数据，下次在用的时候，不需要从数据库中再次获取，大大提升执行效率。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存（怎么向ServletContext应用域中存数据）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name, Object value)</span>; <span class="comment">// map.put(k, v)</span></span><br><span class="line"><span class="comment">// 取（怎么从ServletContext应用域中取数据）</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>; <span class="comment">// Object v = map.get(k)</span></span><br><span class="line"><span class="comment">// 删（怎么删除ServletContext应用域中的数据）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>; <span class="comment">// map.remove(k)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注意：以后我们编写Servlet类的时候，实际上是不会去直接继承GenericServlet类的，因为我们是B/S结构的系统，这种系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。我们编写的Servlet类要继承HttpServlet。（HttpServlet是HTTP协议专用的。）使用HttpServlet处理HTTP协议更便捷。但是你需要直到它的继承结构：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jakarta.servlet.Servlet（接口）【爷爷】</span><br><span class="line">jakarta.servlet.GenericServlet implements Servlet（抽象类）【儿子】</span><br><span class="line">jakarta.servlet.http.HttpServlet extends GenericServlet（抽象类）【孙子】</span><br><span class="line"></span><br><span class="line">我们以后编写的Servlet要继承HttpServlet类。</span><br></pre></td></tr></table></figure><ul><li><p>大家到目前为止都接触过哪些缓存机制了？</p><ul><li>堆内存当中的字符串常量池。<ul><li>“abc”先在字符串常量池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。</li></ul></li><li>堆内存当中的整数型常量池。<ul><li>[-128 ~ 127]一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。</li></ul></li><li>连接池(Connection Cache)<ul><li>这里所说的连接池中的连接是java语言连接数据库的连接对象：java.sql.Connection对象。</li><li>JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办？可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。</li><li>连接池<ul><li>最小连接数</li><li>最大连接数</li><li>连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。</li></ul></li></ul></li><li>线程池<ul><li>Tomcat服务器本身就是支持多线程的。</li><li>Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗？<ul><li>当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。</li><li>所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。</li></ul></li></ul></li><li>redis<ul><li>NoSQL数据库。非关系型数据库。缓存数据库。</li></ul></li><li>向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中了。</li></ul></li></ul><h2 id="http协议">HTTP协议</h2><ul><li><p>什么是协议？</p><ul><li>协议实际上是某些人，或者某些组织提前制定好的一套规范，大家都按照这个规范来，这样可以做到沟通无障碍。</li><li>协议就是一套规范，就是一套标准。由其他人或其他组织来负责制定的。</li><li>我说的话你能听懂，你说的话，我也能听懂，这说明我们之间是有一套规范的，一套协议的，这套协议就是：中国普通话协议。我们都遵守这套协议，我们之间就可以沟通无障碍。</li></ul></li><li><p>什么是HTTP协议？</p><ul><li>HTTP协议：是W3C制定的一种超文本传输协议。（通信协议：发送消息的模板提前被制定好。）</li><li>W3C：<ul><li>万维网联盟组织</li><li>负责制定标准的：HTTP HTML4.0 HTML5 XML DOM等规范都是W3C制定的。</li><li>万维网之父：蒂姆·伯纳斯·李</li></ul></li><li>什么是超文本？<ul><li>超文本说的就是：不是普通文本，比如流媒体：声音、视频、图片等。</li><li>HTTP协议支持：不但可以传送普通字符串，同样支持传递声音、视频、图片等流媒体信息。</li></ul></li><li>这种协议游走在B和S之间。B向S发数据要遵循HTTP协议。S向B发数据同样需要遵循HTTP协议。这样B和S才能解耦合。</li><li>什么是解耦合？<ul><li>B不依赖S。</li><li>S也不依赖B。</li></ul></li><li>B/S表示：B/S结构的系统（浏览器访问WEB服务器的系统）</li><li>浏览器 向WEB服务器发送数据，叫做：请求（request)</li><li>WEB服务器 向浏览器发送数据，叫做：响应（response）</li><li>HTTP协议包括：<ul><li>请求协议<ul><li>浏览器 向WEB服务器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。</li></ul></li><li>响应协议<ul><li>WEB服务器 向浏览器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。</li></ul></li></ul></li><li>HTTP协议就是提前制定好的一种消息模板。<ul><li>不管你是哪个品牌的浏览器，都是这么发。</li><li>不管你是哪个品牌的WEB服务器，都是这么发。</li><li>FF浏览器 可以向Tomcat发送请求，也可以向Jetty服务器发送请求。浏览器不依赖具体的服务器品牌。</li><li>WEB服务器也不依赖具体的浏览器品牌。可以是FF浏览器，也可以是Chrome浏览器，可以是IE，都行。</li></ul></li></ul></li><li><p>HTTP的请求协议（B –&gt; S）</p><ul><li><p>HTTP的请求协议包括：4部分</p><ul><li>请求行</li><li>请求头</li><li>空白行</li><li>请求体</li></ul></li><li><p>HTTP请求协议的具体报文：GET请求</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /servlet05/getServlet?username=lucy&amp;userpwd=1111 HTTP/1.1           请求行</span><br><span class="line">Host: localhost:8080                                                   请求头</span><br><span class="line">Connection: keep-alive</span><br><span class="line">sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?0</span><br><span class="line">sec-ch-ua-platform: &quot;Windows&quot;</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Referer: http://localhost:8080/servlet05/index.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">空白行</span><br><span class="line">请求体</span><br></pre></td></tr></table></figure><ul><li>HTTP请求协议的具体报文：POST请求</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">POST /servlet05/postServlet HTTP/1.1                请求行</span><br><span class="line">Host: localhost:8080         请求头</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 25</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?0</span><br><span class="line">sec-ch-ua-platform: &quot;Windows&quot;</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: http://localhost:8080</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Referer: http://localhost:8080/servlet05/index.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">空白行</span><br><span class="line">username=lisi&amp;userpwd=123        请求体</span><br></pre></td></tr></table></figure><ul><li><p>请求行</p><ul><li>包括三部分：<ul><li>第一部分：请求方式（7种）<ul><li>get（常用的）</li><li>post（常用的）</li><li>delete</li><li>put</li><li>head</li><li>options</li><li>trace</li></ul></li><li>第二部分：URI<ul><li>什么是URI？统一资源标识符。代表网络中某个资源的名字。但是通过URI是无法定位资源的。</li><li>什么是URL？统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的。</li><li>URI和URL什么关系，有什么区别？<ul><li>URL包括URI</li><li>http://localhost:8080/servlet05/index.html 这是URL。</li><li>/servlet05/index.html 这是URI。</li></ul></li></ul></li><li>第三部分：HTTP协议版本号</li></ul></li></ul></li><li><p>请求头</p><ul><li>请求的主机</li><li>主机的端口</li><li>浏览器信息</li><li>平台信息</li><li>cookie等信息</li><li>….</li></ul></li><li><p>空白行</p><ul><li>空白行是用来区分“请求头”和“请求体”</li></ul></li><li><p>请求体</p><ul><li>向服务器发送的具体数据。</li></ul></li><li><p>HTTP的响应协议（S –&gt; B）</p><ul><li><p>HTTP的响应协议包括：4部分</p><ul><li>状态行</li><li>响应头</li><li>空白行</li><li>响应体</li></ul></li><li><p>HTTP响应协议的具体报文：</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 ok                                     状态行</span><br><span class="line">Content-Type: text/html;charset=UTF-8               响应头</span><br><span class="line">Content-Length: 160</span><br><span class="line">Date: Mon, 08 Nov 2021 13:19:32 GMT</span><br><span class="line">Keep-Alive: timeout=20</span><br><span class="line">Connection: keep-alive</span><br><span class="line">空白行</span><br><span class="line">&lt;!doctype html&gt;                                     响应体</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;from get servlet&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;from get servlet&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><p>状态行</p><ul><li>三部分组成<ul><li>第一部分：协议版本号（HTTP/1.1）</li><li>第二部分：状态码（HTTP协议中规定的响应状态号。不同的响应结果对应不同的号码。）<ul><li>200 表示请求响应成功，正常结束。</li><li>404表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功。总之404错误是前端错误。</li><li>405表示前端发送的请求方式与后端请求的处理方式不一致时发生：<ul><li>比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405</li><li>比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</li></ul></li><li>500表示服务器端的程序出现了异常。一般会认为是服务器端的错误导致的。</li><li>以4开始的，一般是浏览器端的错误导致的。</li><li>以5开始的，一般是服务器端的错误导致的。</li></ul></li><li>第三部分：状态的描述信息<ul><li>ok 表示正常成功结束。</li><li>not found 表示资源找不到。</li></ul></li></ul></li></ul></li><li><p>响应头：</p><ul><li>响应的内容类型</li><li>响应的内容长度</li><li>响应的时间</li><li>….</li></ul></li><li><p>空白行：</p><ul><li>用来分隔“响应头”和“响应体”的。</li></ul></li><li><p>响应体：</p><ul><li>响应体就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。</li></ul></li><li><p>怎么查看的协议内容？</p><ul><li>使用chrome浏览器：F12。然后找到network，通过这个面板可以查看协议的具体内容。</li></ul></li><li><p>怎么向服务器发送GET请求，怎么向服务器发送POST请求？</p><ul><li>到目前为止，只有一种情况可以发送POST请求：使用form表单，并且form标签中的method属性值为：method=“post”。</li><li>其他所有情况一律都是get请求：<ul><li>在浏览器地址栏上直接输入URL，敲回车，属于get请求。</li><li>在浏览器上直接点击超链接，属于get请求。</li><li>使用form表单提交数据时，form标签中没有写method属性，默认就是get</li><li>或者使用form的时候，form标签中method属性值为：method=“get”</li><li>….</li></ul></li></ul></li><li><p>GET请求和POST请求有什么区别？</p><ul><li>get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个“?”，“?”后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。（get请求在“请求行”上发送数据）<ul><li>http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111</li></ul></li><li>post请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。（post在“请求体”当中发送数据）</li><li>get请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。</li><li>get请求无法发送大数据量。</li><li>post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片。</li><li>post请求可以发送大数据量，理论上没有长度限制。</li><li>get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据。</li><li>post请求在W3C中是这样说的：post请求比较适合向服务器端传送数据。</li><li>get请求是安全的。get请求是绝对安全的。为什么？因为get请求只是为了从服务器上获取数据。不会对服务器造成威胁。（get本身是安全的，你不要用错了。用错了之后又冤枉人家get不安全，你这样不好（太坏了），那是你自己的问题，不是get请求的问题。）</li><li>post请求是危险的。为什么？因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的。另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会选择拦截（监听）post请求。</li><li>get请求支持缓存。<ul><li>https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg</li><li>任何一个get请求最终的“响应结果”都会被浏览器缓存起来。在浏览器缓存当中：<ul><li>一个get请求的路径a 对应 一个资源。</li><li>一个get请求的路径b 对应 一个资源。</li><li>一个get请求的路径c 对应 一个资源。</li><li>……</li></ul></li><li>实际上，你只要发送get请求，浏览器做的第一件事都是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取。这种缓存机制目的是为了提高用户的体验。</li><li>有没有这样一个需求：我们不希望get请求走缓存，怎么办？怎么避免走缓存？我希望每一次这个get请求都去服务器上找资源，我不想从本地浏览器的缓存中取。<ul><li>只要每一次get请求的请求路径不同即可。</li><li>https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897898</li><li>https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897899</li><li>https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=系统毫秒数</li><li>怎么解决？可以在路径的后面添加一个每时每刻都在变化的“时间戳”，这样，每一次的请求路径都不一样，浏览器就不走缓存了。</li></ul></li></ul></li><li>post请求不支持缓存。（POST是用来修改服务器端的资源的。）<ul><li>post请求之后，服务器“响应的结果”不会被浏览器缓存起来。因为这个缓存没有意义。</li></ul></li></ul></li><li><p>GET请求和POST请求如何选择，什么时候使用GET请求，什么时候使用POST请求？</p><ul><li>怎么选择GET请求和POST请求呢？衡量标准是什么呢？你这个请求是想获取服务器端的数据，还是想向服务器发送数据。如果你是想从服务器上获取资源，建议使用GET请求，如果你这个请求是为了向服务器提交数据，建议使用POST请求。</li><li>大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是需要传给服务器，服务器将这些数据保存/修改等。</li><li>如果表单中有敏感信息，还是建议适用post请求，因为get请求会回显敏感信息到浏览器地址栏上。（例如：密码信息）</li><li>做文件上传，一定是post请求。要传的数据不是普通文本。</li><li>其他情况都可以使用get请求。</li></ul></li><li><p>不管你是get请求还是post请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的：</p><ul><li>name=value&amp;name=value&amp;name=value&amp;name=value</li><li>name是什么？<ul><li>以form表单为例：form表单中input标签的name。</li></ul></li><li>value是什么？<ul><li>以form表单为例：form表单中input标签的value。</li></ul></li></ul></li></ul><h2 id="模板方法设计模式">模板方法设计模式</h2><ul><li>什么是设计模式？<ul><li>某个问题的固定的解决方案。(可以被重复使用。)</li></ul></li><li>你知道哪些设计模式？<ul><li>GoF设计模式：<ul><li>通常我们所说的23种设计模式。（Gang ofFour：4人组提出的设计模式）</li><li>单例模式</li><li>工厂模式</li><li>代理模式</li><li>门面模式</li><li>责任链设计模式</li><li>观察者模式</li><li>模板方法设计模式</li><li>…..</li></ul></li><li>JavaEE设计模式：<ul><li>DAO</li><li>DTO</li><li>VO</li><li>PO</li><li>pojo</li><li>….</li></ul></li><li>….</li></ul></li><li>什么是模板方法设计模式？<ul><li>在模板类的模板方法当中定义核心算法骨架，具体的实现步骤可以延迟到子类当中完成。</li></ul></li><li>模板类通常是一个抽象类，模板类当中的模板方法定义核心算法，这个方法通常是final的（但也可以不是final的）</li><li>模板类当中的抽象方法就是不确定实现的方法，这个不确定怎么实现的事儿交给子类去做。</li></ul><h2 id="httpservlet源码分析">HttpServlet源码分析</h2><ul><li>HttpServlet类是专门为HTTP协议准备的。比GenericServlet更加适合HTTP协议下的开发。</li><li>HttpServlet在哪个包下？<ul><li>jakarta.servlet.http.HttpServlet</li></ul></li><li>到目前为止我们接触了servlet规范中哪些接口？<ul><li>jakarta.servlet.Servlet 核心接口（接口）</li><li>jakarta.servlet.ServletConfig Servlet配置信息接口（接口）</li><li>jakarta.servlet.ServletContext Servlet上下文接口（接口）</li><li>jakarta.servlet.ServletRequest Servlet请求接口（接口）</li><li>jakarta.servlet.ServletResponse Servlet响应接口（接口）</li><li>jakarta.servlet.ServletException Servlet异常（类）</li><li>jakarta.servlet.GenericServlet 标准通用的Servlet类（抽象类）</li></ul></li><li>http包下都有哪些类和接口呢？jakarta.servlet.http.*;<ul><li>jakarta.servlet.http.HttpServlet（HTTP协议专用的Servlet类，抽象类）</li><li>jakarta.servlet.http.HttpServletRequest（HTTP协议专用的请求对象）</li><li>jakarta.servlet.http.HttpServletResponse（HTTP协议专用的响应对象）</li></ul></li><li>HttpServletRequest对象中封装了什么信息？<ul><li>HttpServletRequest，简称request对象。</li><li>HttpServletRequest中封装了请求协议的全部内容。</li><li>Tomcat服务器（WEB服务器）将“请求协议”中的数据全部解析出来，然后将这些数据全部封装到request对象当中了。</li><li>也就是说，我们只要面向HttpServletRequest，就可以获取请求协议中的数据。</li></ul></li><li>HttpServletResponse对象是专门用来响应HTTP协议到浏览器的。</li><li>回忆Servlet生命周期？<ul><li>用户第一次请求<ul><li>Tomcat服务器通过反射机制，调用无参数构造方法。创建Servlet对象。(web.xml文件中配置的Servlet类对应的对象。)</li><li>Tomcat服务器调用Servlet对象的init方法完成初始化。</li><li>Tomcat服务器调用Servlet对象的service方法处理请求。</li></ul></li><li>用户第二次请求<ul><li>Tomcat服务器调用Servlet对象的service方法处理请求。</li></ul></li><li>用户第三次请求<ul><li>Tomcat服务器调用Servlet对象的service方法处理请求。</li></ul></li><li>….<ul><li>Tomcat服务器调用Servlet对象的service方法处理请求。</li></ul></li><li>服务器关闭<ul><li>Tomcat服务器调用Servlet对象的destroy方法，做销毁之前的准备工作。</li><li>Tomcat服务器销毁Servlet对象。</li></ul></li></ul></li><li>HttpServlet源码分析：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="comment">// 用户第一次请求，创建HelloServlet对象的时候，会执行这个无参数构造方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HelloServlet</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//override 重写 doGet方法</span></span><br><span class="line">    <span class="comment">//override 重写 doPost方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GenericServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>, ServletConfig,</span><br><span class="line">        java.io.Serializable &#123;</span><br><span class="line">           </span><br><span class="line"><span class="comment">// 用户第一次请求的时候，HelloServlet对象第一次被创建之后，这个init方法会执行。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.config = config;</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 用户第一次请求的时候，带有参数的init(ServletConfig config)执行之后，会执行这个没有参数的init()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// NOOP by default</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpServlet模板类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HttpServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 用户发送第一次请求的时候这个service会执行</span></span><br><span class="line">    <span class="comment">// 用户发送第N次请求的时候，这个service方法还是会执行。</span></span><br><span class="line">    <span class="comment">// 用户只要发送一次请求，这个service方法就会执行一次。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest  request;</span><br><span class="line">        HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将ServletRequest和ServletResponse向下转型为带有Http的HttpServletRequest和HttpServletResponse</span></span><br><span class="line">            request = (HttpServletRequest) req;</span><br><span class="line">            response = (HttpServletResponse) res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(lStrings.getString(<span class="string">&quot;http.non_http&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用重载的service方法。</span></span><br><span class="line">        service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个service方法的两个参数都是带有Http的。</span></span><br><span class="line">    <span class="comment">// 这个service是一个模板方法。</span></span><br><span class="line">    <span class="comment">// 在该方法中定义核心算法骨架，具体的实现步骤延迟到子类中去完成。</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求方式</span></span><br><span class="line">        <span class="comment">// 这个请求方式最终可能是：&quot;&quot;</span></span><br><span class="line">        <span class="comment">// 注意：request.getMethod()方法获取的是请求方式，可能是七种之一：</span></span><br><span class="line">        <span class="comment">// GET POST PUT DELETE HEAD OPTIONS TRACE</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果请求方式是GET请求，则执行doGet方法。</span></span><br><span class="line">        <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">                <span class="comment">// to go through further expensive logic</span></span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                    <span class="comment">// Invalid date header - proceed as if none was set</span></span><br><span class="line">                    ifModifiedSince = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">                    <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doHead(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">            <span class="comment">// 如果请求方式是POST请求，则执行doPost方法。</span></span><br><span class="line">            doPost(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">            doPut(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">            doDelete(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">            doOptions(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">            doTrace(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">            <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">            errArgs[<span class="number">0</span>] = method;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line"></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException&#123;</span><br><span class="line">        <span class="comment">// 报405错误</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">        sendMethodNotAllowed(req, resp, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 报405错误</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_post_not_supported&quot;</span>);</span><br><span class="line">        sendMethodNotAllowed(req, resp, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过以上源代码分析：</span></span><br><span class="line"><span class="comment">假设前端发送的请求是get请求，后端程序员重写的方法是doPost</span></span><br><span class="line"><span class="comment">假设前端发送的请求是post请求，后端程序员重写的方法是doGet</span></span><br><span class="line"><span class="comment">会发生什么呢？</span></span><br><span class="line"><span class="comment">发生405这样的一个错误。</span></span><br><span class="line"><span class="comment">405表示前端的错误，发送的请求方式不对。和服务器不一致。不是服务器需要的请求方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">通过以上源代码可以知道：只要HttpServlet类中的doGet方法或doPost方法执行了，必然405.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">怎么避免405的错误呢？</span></span><br><span class="line"><span class="comment">后端重写了doGet方法，前端一定要发get请求。</span></span><br><span class="line"><span class="comment">后端重写了doPost方法，前端一定要发post请求。</span></span><br><span class="line"><span class="comment">这样可以避免405错误。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这种前端到底需要发什么样的请求，其实应该后端说了算。后端让发什么方式，前端就得发什么方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有的人，你会看到为了避免405错误，在Servlet类当中，将doGet和doPost方法都进行了重写。</span></span><br><span class="line"><span class="comment">这样，确实可以避免405的发生，但是不建议，405错误还是有用的。该报错的时候就应该让他报错。</span></span><br><span class="line"><span class="comment">如果你要是同时重写了doGet和doPost，那还不如你直接重写service方法好了。这样代码还能</span></span><br><span class="line"><span class="comment">少写一点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>我们编写的HelloServlet直接继承HttpServlet，直接重写HttpServlet类中的service()方法行吗？<ul><li>可以，只不过你享受不到405错误。享受不到HTTP协议专属的东西。</li></ul></li><li>到今天我们终于得到了最终的一个Servlet类的开发步骤：<ul><li>第一步：编写一个Servlet类，直接继承HttpServlet</li><li>第二步：重写doGet方法或者重写doPost方法，到底重写谁，javaweb程序员说了算。</li><li>第三步：将Servlet类配置到web.xml文件当中。</li><li>第四步：准备前端的页面（form表单），form表单中指定请求路径即可。</li></ul></li></ul><h2 id="关于一个web站点的欢迎页面">关于一个web站点的欢迎页面</h2><ul><li><p>什么是一个web站点的欢迎页面？</p><ul><li>对于一个webapp来说，我们是可以设置它的欢迎页面的。</li><li>设置了欢迎页面之后，当你访问这个webapp的时候，或者访问这个web站点的时候，没有指定任何“资源路径”，这个时候会默认访问你的欢迎页面。</li><li>我们一般的访问方式是：<ul><li>http://localhost:8080/servlet06/login.html这种方式是指定了要访问的就是login.html资源。</li></ul></li><li>如果我们访问的方式是：<ul><li>http://localhost:8080/servlet06如果我们访问的就是这个站点，没有指定具体的资源路径。它默认会访问谁呢？</li><li>默认会访问你设置的欢迎页面。</li></ul></li></ul></li><li><p>怎么设置欢迎页面呢？</p><ul><li><p>第一步：我在IDEA工具的web目录下新建了一个文件login.html</p></li><li><p>第二步：在web.xml文件中进行了以下的配置</p></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>login.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>注意：设置欢迎页面的时候，这个路径不需要以“/”开始。并且这个路径默认是从webapp的根下开始查找。</p></li><li><p>第三步：启动服务器，浏览器地址栏输入地址</p><ul><li>http://localhost:8080/servlet07</li></ul></li><li><p>如果在webapp的根下新建一个目录，目录中再给一个文件，那么这个欢迎页该如何设置呢？</p><ul><li><p>在webapp根下新建page1</p></li><li><p>在page1下新建page2目录</p></li><li><p>在page2目录下新建page.html页面</p></li><li><p>在web.xml文件中应该这样配置</p></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>page1/page2/page.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>注意：路径不需要以“/”开始，并且路径默认从webapp的根下开始找。</p></li><li><p>一个webapp是可以设置多个欢迎页面的</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>page1/page2/page.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>login.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>注意：越靠上的优先级越高。找不到的继续向下找。</p></li><li><p>你有没有注意一件事：当我的文件名设置为index.html的时候，不需要在web.xml文件中进行配置欢迎页面。这是为什么？</p><ul><li><p>这是因为小猫咪Tomcat服务器已经提前配置好了。</p></li><li><p>实际上配置欢迎页面有两个地方可以配置：</p><ul><li><p>一个是在webapp内部的web.xml文件中。（在这个地方配置的属于局部配置）</p></li><li><p>一个是在CATALINA_HOME/conf/web.xml文件中进行配置。（在这个地方配置的属于全局配置）</p></li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>Tomcat服务器的全局欢迎页面是：index.html index.htmindex.jsp。如果你一个web站点没有设置局部的欢迎页面，Tomcat服务器就会以index.htmlindex.htm index.jsp作为一个web站点的欢迎页面。</p><ul><li>注意原则：局部优先原则。（就近原则）</li></ul></li><li><p>欢迎页可以是一个Servlet吗？</p><ul><li><p>当然可以。</p></li><li><p>你不要多想，欢迎页就是一个资源，既然是一个资源，那么可以是静态资源，也可以是动态资源。</p></li><li><p>静态资源：index.html welcome.html …..</p></li><li><p>动态资源：Servlet类。</p></li><li><p>步骤：</p><ul><li>第一步：写一个Servlet</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.print(<span class="string">&quot;&lt;h1&gt;welcome to bjpowernode!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二步：在web.xml文件中配置servlet</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>welcomeServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.WelcomeServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>welcomeServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/fdsa/fds/a/fds/af/ds/af/dsafdsafdsa<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>第三步：在web.xml文件中配置欢迎页</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>fdsa/fds/a/fds/af/ds/af/dsafdsafdsa<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="关于web-inf目录">关于WEB-INF目录</h2><ul><li>在WEB-INF目录下新建了一个文件：welcome.html</li><li>打开浏览器访问：http://localhost:8080/servlet07/WEB-INF/welcome.html出现了404错误。</li><li>注意：放在WEB-INF目录下的资源是受保护的。在浏览器上不能够通过路径直接访问。所以像HTML、CSS、JS、image等静态资源一定要放到WEB-INF目录之外。</li></ul><h2 id="httpservletrequest接口详解">HttpServletRequest接口详解</h2><ul><li><p>HttpServletRequest是一个接口，全限定名称：jakarta.servlet.http.HttpServletRequest</p></li><li><p>HttpServletRequest接口是Servlet规范中的一员。</p></li><li><p>HttpServletRequest接口的父接口：ServletRequest</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpServletRequest</span> <span class="keyword">extends</span> <span class="title class_">ServletRequest</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>HttpServletRequest接口的实现类谁写的?HttpServletRequest对象是谁给创建的？</p><ul><li>通过测试：org.apache.catalina.connector.RequestFacade 实现了HttpServletRequest接口</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestFacade</span> <span class="keyword">implements</span> <span class="title class_">HttpServletRequest</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>测试结果说明：Tomcat服务器（WEB服务器、WEB容器）实现了HttpServletRequest接口，还是说明了Tomcat服务器实现了Servlet规范。而对于我们javaweb程序员来说，实际上不需要关心这个，我们只需要面向接口编程即可。我们关心的是HttpServletRequest接口中有哪些方法，这些方法可以完成什么功能！！！！</p></li><li><p>HttpServletRequest对象中都有什么信息？都包装了什么信息？</p><ul><li>HttpServletRequest对象是Tomcat服务器负责创建的。这个对象中封装了什么信息？封装了HTTP的请求协议。</li><li>实际上是用户发送请求的时候，遵循了HTTP协议，发送的是HTTP的请求协议，Tomcat服务器将HTTP协议中的信息以及数据全部解析出来，然后Tomcat服务器把这些信息封装到HttpServletRequest对象当中，传给了我们javaweb程序员。</li><li>javaweb程序员面向HttpServletRequest接口编程，调用方法就可以获取到请求的信息了。</li></ul></li><li><p>request和response对象的生命周期？</p><ul><li>request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效。</li><li>一次请求对应一个request。</li><li>两次请求则对应两个request。</li><li>…..</li></ul></li><li><p>HttpServletRequest接口中有哪些常用的方法？</p><ul><li>怎么获取前端浏览器用户提交的数据？</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String[]&gt; getParameterMap() 这个是获取Map</span><br><span class="line">    Enumeration&lt;String&gt; <span class="title function_">getParameterNames</span><span class="params">()</span> 这个是获取Map集合中所有的key</span><br><span class="line">    String[] getParameterValues(String name) 根据key获取Map集合的value</span><br><span class="line">    String <span class="title function_">getParameter</span><span class="params">(String name)</span>  获取value这个一维数组当中的第一个元素。这个方法最常用。</span><br><span class="line">    <span class="comment">// 以上的4个方法，和获取用户提交的数据有关系。</span></span><br></pre></td></tr></table></figure><ul><li>思考：如果是你，前端的form表单提交了数据之后，你准备怎么存储这些数据，你准备采用什么样的数据结构去存储这些数据呢？<ul><li><p>前端提交的数据格式：username=abc&amp;userpwd=111&amp;aihao=s&amp;aihao=d&amp;aihao=tt</p></li><li><p>我会采用Map集合来存储：</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt;</span><br><span class="line">    key存储String</span><br><span class="line">    value存储String</span><br><span class="line">    这种想法对吗？不对。</span><br><span class="line">    如果采用以上的数据结构存储会发现key重复的时候value覆盖。</span><br><span class="line">    key         value</span><br><span class="line">    ---------------------</span><br><span class="line">    username    abc</span><br><span class="line">    userpwd     <span class="number">111</span></span><br><span class="line">    aihao       s</span><br><span class="line">    aihao       d</span><br><span class="line">    aihao       tt</span><br><span class="line">    这样是不行的，因为map的key不能重复。</span><br><span class="line">    Map&lt;String, String[]&gt;</span><br><span class="line">    key存储String</span><br><span class="line">    value存储String[]</span><br><span class="line">    keyvalue</span><br><span class="line">    -------------------------------</span><br><span class="line">    username&#123;<span class="string">&quot;abc&quot;</span>&#125;</span><br><span class="line">userpwd&#123;<span class="string">&quot;111&quot;</span>&#125;</span><br><span class="line">aihao&#123;<span class="string">&quot;s&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;tt&quot;</span>&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：前端表单提交数据的时候，假设提交了120这样的“数字”，其实是以字符串”120”的方式提交的，所以服务器端获取到的一定是一个字符串的”120”，而不是一个数字。（前端永远提交的是字符串，后端获取的也永远是字符串。）</p></li><li><p>手工开发一个webapp。测试HttpServletRequest接口中的相关方法。</p></li><li><p>先测试了4个常用的方法，获取请求参数的四个方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">Enumeration&lt;String&gt; names = request.getParameterNames();</span><br><span class="line">String[] values = request.getParameterValues(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>request对象实际上又称为“请求域”对象。</p><ul><li><p>应用域对象是什么？</p><ul><li><p>ServletContext （Servlet上下文对象。）</p></li><li><p>什么情况下会考虑向ServletContext这个应用域当中绑定数据呢？</p><ul><li>第一：所有用户共享的数据。</li><li>第二：这个共享的数据量很小。</li><li>第三：这个共享的数据很少的修改操作。</li><li>在以上三个条件都满足的情况下，使用这个应用域对象，可以大大提高我们程序执行效率。</li><li>实际上向应用域当中绑定数据，就相当于把数据放到了缓存（Cache）当中，然后用户访问的时候直接从缓存中取，减少IO的操作，大大提升系统的性能，所以缓存技术是提高系统性能的重要手段。</li></ul></li><li><p>你见过哪些缓存技术呢？</p><ul><li>字符串常量池</li><li>整数型常量池[-128~127]，但凡是在这个范围当中的Integer对象不再创建新对象，直接从这个整数型常量池中获取。大大提升系统性能。</li><li>数据库连接池（提前创建好N个连接对象，将连接对象放到集合当中，使用连接对象的时候，直接从缓存中拿。省去了连接对象的创建过程。效率提升。）</li><li>线程池（Tomcat服务器就是支持多线程的。所谓的线程池就是提前先创建好N个线程对象，将线程对象存储到集合中，然后用户请求过来之后，直接从线程池中获取线程对象，直接拿来用。提升系统性能）</li><li>后期你还会学习更多的缓存技术，例如：redis、mongoDB…..</li></ul></li><li><p>ServletContext当中有三个操作域的方法：</p></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name, Object obj)</span>; <span class="comment">// 向域当中绑定数据。</span></span><br><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>; <span class="comment">// 从域当中根据name获取数据。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>; <span class="comment">// 将域当中绑定的数据移除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上的操作类似于Map集合的操作。</span></span><br><span class="line">Map&lt;String, Object&gt; map;</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, obj); <span class="comment">// 向map集合中放key和value</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> map.get(<span class="string">&quot;name&quot;</span>); <span class="comment">// 通过map集合的key获取value</span></span><br><span class="line">map.remove(<span class="string">&quot;name&quot;</span>); <span class="comment">// 通过Map集合的key删除key和value这个键值对。</span></span><br></pre></td></tr></table></figure><ul><li><p>“请求域”对象</p><ul><li><p>“请求域”对象要比“应用域”对象范围小很多。生命周期短很多。请求域只在一次请求内有效。</p></li><li><p>一个请求对象request对应一个请求域对象。一次请求结束之后，这个请求域就销毁了。</p></li><li><p>请求域对象也有这三个方法：</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name, Object obj)</span>; <span class="comment">// 向域当中绑定数据。</span></span><br><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>; <span class="comment">// 从域当中根据name获取数据。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>; <span class="comment">// 将域当中绑定的数据移除</span></span><br></pre></td></tr></table></figure><ul><li>请求域和应用域的选用原则？<ul><li>尽量使用小的域对象，因为小的域对象占用的资源较少。</li><li>跳转</li><li>转发（一次请求）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：获取请求转发器对象</span></span><br><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/b&quot;</span>);</span><br><span class="line"><span class="comment">// 第二步：调用转发器的forward方法完成跳转/转发</span></span><br><span class="line">dispatcher.forward(request,response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步和第二步代码可以联合在一起。</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/b&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure><ul><li><p>两个Servlet怎么共享数据？</p><ul><li>将数据放到ServletContext应用域当中，当然是可以的，但是应用域范围太大，占用资源太多。不建议使用。</li><li>可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在同一次请求当中，这样就可以做到两个Servlet，或者多个Servlet共享同一份数据。</li></ul></li><li><p>转发的下一个资源必须是一个Servlet吗？</p><ul><li>不一定，只要是Tomcat服务器当中的合法资源，都是可以转发的。例如：html….</li><li>注意：转发的时候，路径的写法要注意，转发的路径以“/”开始，不加项目名。</li></ul></li><li><p>关于request对象中两个非常容易混淆的方法：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// uri?username=zhangsan&amp;userpwd=123&amp;sex=1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前一定是执行过：request.setAttribute(&quot;name&quot;, new Object())</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两个方法的区别是什么？</span></span><br><span class="line"><span class="comment">// 第一个方法：获取的是用户在浏览器上提交的数据。</span></span><br><span class="line"><span class="comment">// 第二个方法：获取的是请求域当中绑定的数据。</span></span><br></pre></td></tr></table></figure><ul><li>HttpServletRequest接口的其他常用方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取客户端的IP地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">remoteAddr</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line"></span><br><span class="line"><span class="comment">// get请求在请求行上提交数据。</span></span><br><span class="line"><span class="comment">// post请求在请求体中提交数据。</span></span><br><span class="line"><span class="comment">// 设置请求体的字符集。（显然这个方法是处理POST请求的乱码问题。这种方式并不能解决get请求的乱码问题。）</span></span><br><span class="line"><span class="comment">// Tomcat10之后，request请求体当中的字符集默认就是UTF-8，不需要设置字符集，不会出现乱码问题。</span></span><br><span class="line"><span class="comment">// Tomcat9前（包括9在内），如果前端请求体提交的是中文，后端获取之后出现乱码，怎么解决这个乱码？执行以下代码。</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Tomcat9之前（包括9），响应中文也是有乱码的，怎么解决这个响应的乱码？</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 在Tomcat10之后，包括10在内，响应中文的时候就不在出现乱码问题了。以上代码就不需要设置UTF-8了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意一个细节</span></span><br><span class="line"><span class="comment">// 在Tomcat10包括10在内之后的版本，中文将不再出现乱码。（这也体现了中文地位的提升。）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get请求乱码问题怎么解决？</span></span><br><span class="line"><span class="comment">// get请求发送的时候，数据是在请求行上提交的，不是在请求体当中提交的。</span></span><br><span class="line"><span class="comment">// get请求乱码怎么解决</span></span><br><span class="line"><span class="comment">// 方案：修改CATALINA_HOME/conf/server.xml配置文件</span></span><br><span class="line">&lt;Connector URIEncoding=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">    <span class="comment">// 注意：从Tomcat8之后，URIEncoding的默认值就是UTF-8，所以GET请求也没有乱码问题了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取应用的根路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取请求方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取请求的URI</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();  <span class="comment">// /aaa/testRequest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取servlet path</span></span><br><span class="line"><span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath(); <span class="comment">//   /testRequest</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2id="使用纯servlet做一个单表的crud操作">使用纯Servlet做一个单表的CRUD操作</h2><ul><li><p>使用纯粹的Servlet完成单表【对部门的】的增删改查操作。（B/S结构的。）</p></li><li><p>实现步骤</p><ul><li>第一步：准备一张数据库表。（sql脚本）</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 部门表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> dept;</span><br><span class="line"><span class="keyword">create table</span> dept(</span><br><span class="line">deptno <span class="type">int</span> <span class="keyword">primary key</span>,</span><br><span class="line">    dname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    loc <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert into</span> dept(deptno, dname, loc) <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;XiaoShouBu&#x27;</span>, <span class="string">&#x27;BEIJING&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> dept(deptno, dname, loc) <span class="keyword">values</span>(<span class="number">20</span>, <span class="string">&#x27;YanFaBu&#x27;</span>, <span class="string">&#x27;SHANGHAI&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> dept(deptno, dname, loc) <span class="keyword">values</span>(<span class="number">30</span>, <span class="string">&#x27;JiShuBu&#x27;</span>, <span class="string">&#x27;GUANGZHOU&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> dept(deptno, dname, loc) <span class="keyword">values</span>(<span class="number">40</span>, <span class="string">&#x27;MeiTiBu&#x27;</span>, <span class="string">&#x27;SHENZHEN&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept;</span><br></pre></td></tr></table></figure><ul><li><p>第二步：准备一套HTML页面（项目原型）【前端开发工具使用HBuilder】</p><ul><li>把HTML页面准备好</li><li>然后将HTML页面中的链接都能够跑通。（页面流转没问题。）</li><li>应该设计哪些页面呢？<ul><li>欢迎页面：index.html</li><li>列表页面：list.html（以列表页面为核心，展开其他操作。）</li><li>新增页面：add.html</li><li>修改页面：edit.html</li><li>详情页面：detail.html</li></ul></li></ul></li><li><p>第三步：分析我们这个系统包括哪些功能？</p><ul><li>什么叫做一个功能呢？<ul><li>只要 这个操作连接了数据库，就表示一个独立的功能。</li></ul></li><li>包括哪些功能？<ul><li>查看部门列表</li><li>新增部门</li><li>删除部门</li><li>查看部门详细信息</li><li>跳转到修改页面</li><li>修改部门</li></ul></li></ul></li><li><p>第四步：在IDEA当中搭建开发环境</p><ul><li>创建一个webapp（给这个webapp添加servlet-api.jar和jsp-api.jar到classpath当中。）</li><li>向webapp中添加连接数据库的jar包（mysql驱动）<ul><li>必须在WEB-INF目录下新建lib目录，然后将mysql的驱动jar包拷贝到这个lib目录下。这个目录名必须叫做lib，全部小写的。</li></ul></li><li>JDBC的工具类</li><li>将所有HTML页面拷贝到web目录下。</li></ul></li><li><p>第五步：实现第一个功能：查看部门列表</p><ul><li><p>我们应该怎么去实现一个功能呢？</p><ul><li>建议：你可以从后端往前端一步一步写。也可以从前端一步一步往后端写。都可以。但是千万要记住不要想起来什么写什么。你写代码的过程最好是程序的执行过程。也就是说：程序执行到哪里，你就写哪里。这样一个顺序流下来之后，基本上不会出现什么错误、意外。</li><li>从哪里开始？<ul><li>假设从前端开始，那么一定是从用户点击按钮那里开始的。</li></ul></li></ul></li></ul></li><li><p>第一：先修改前端页面的超链接，因为用户先点击的就是这个超链接。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oa/dept/list&quot;</span>&gt;</span>查看部门列表<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li><li><p>第二：编写web.xml文件</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>list<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.oa.web.action.DeptListServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>list<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--web.xml文件中的这个路径也是以“/”开始的，但是不需要加项目名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/dept/list<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>第三：编写DeptListServlet类继承HttpServlet类。然后重写doGet方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.oa.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptListServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第四：在DeptListServlet类的doGet方法中连接数据库，查询所有的部门，动态的展示部门列表页面.</p><ul><li><p>分析list.html页面中哪部分是固定死的，哪部分是需要动态展示的。</p></li><li><p>list.html页面中的内容所有的双引号要替换成单引号，因为out.print(““)这里有一个双引号，容易冲突。</p></li><li><p>现在写完这个功能之后，你会有一种感觉，感觉开发很繁琐，只使用servlet写代码太繁琐了。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">deptno</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dname</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;dname&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">loc</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;loc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    out.print(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>+(++i)+<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>+deptno+<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>+dname+<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;&lt;a href=&#x27;&#x27;&gt;删除&lt;/a&gt;&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;&lt;a href=&#x27;edit.html&#x27;&gt;修改&lt;/a&gt;&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;&lt;a href=&#x27;detail.html&#x27;&gt;详情&lt;/a&gt;&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第六步：查看部门详情。</p><ul><li><p>建议：从前端往后端一步一步实现。首先要考虑的是，用户点击的是什么？用户点击的东西在哪里？</p></li><li><p>一定要先找到用户点的“详情”在哪里。找了半天，终于在后端的java程序中找到了</p></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;写一个路径&#x27;</span>&gt;</span>详情<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>详情是需要连接数据库的，所以这个超链接点击之后也是需要执行一段java代码的。所以要将这个超链接的路径修改一下。</p><ul><li><p>注意：修改路径之后，这个路径是需要加项目名的。“/oa/dept/detail”</p></li><li><p>技巧：</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.print(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+contextPath+<span class="string">&quot;/dept/detail?deptno=&quot;</span>+deptno+<span class="string">&quot;&#x27;&gt;详情&lt;/a&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>重点：向服务器提交数据的格式：uri?name=value&amp;name=value&amp;name=value&amp;name=value</p><ul><li><p>这里的问号，必须是英文的问号。不能中文的问号。</p></li><li><p>解决404的问题。写web.xml文件。</p></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.oa.web.action.DeptDetailServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/dept/detail<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写一个类：DeptDetailServlet继承HttpServlet，重写doGet方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.oa.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptDetailServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//中文思路（思路来源于：你要做什么？目标：查看部门详细信息。）</span></span><br><span class="line">        <span class="comment">// 第一步：获取部门编号</span></span><br><span class="line">        <span class="comment">// 第二步：根据部门编号查询数据库，获取该部门编号对应的部门信息。</span></span><br><span class="line">        <span class="comment">// 第三步：将部门信息响应到浏览器上。（显示一个详情。）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在doGet方法当中：连接数据库，根据部门编号查询该部门的信息。动态展示部门详情页。</p><ul><li><p>第七步：删除部门</p><ul><li>怎么开始？从哪里开始？从前端页面开始，用户点击删除按钮的时候，应该提示用户是否删除。因为删除这个动作是比较危险的。任何系统在进行删除操作之前，是必须要提示用户的，因为这个删除的动作有可能是用户误操作。（在前端页面上写JS代码，来提示用户是否删除。）</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;del(30)&quot;</span> &gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">del</span>(<span class="params">dno</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&quot;亲，删了不可恢复哦！&quot;</span>))&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;/oa/dept/delete?deptno=&quot;</span> + dno;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>以上的前端程序要写到后端的java代码当中：</p></li><li><p>DeptListServlet类的doGet方法当中，使用out.print()方法，将以上的前端代码输出到浏览器上。</p><ul><li><p>解决404的问题：</p><ul><li><p>http://localhost:8080/oa/dept/delete?deptno=30</p></li><li><p>web.xml文件</p></li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.oa.web.action.DeptDelServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/dept/delete<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写DeptDelServlet继承HttpServlet，重写doGet方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.oa.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptDelServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 根据部门编号，删除部门。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除成功或者失败的时候的一个处理（这里我们选择了转发，并没有使用重定向机制。）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断删除成功了还是失败了。</span></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//删除成功</span></span><br><span class="line">    <span class="comment">//仍然跳转到部门列表页面</span></span><br><span class="line">    <span class="comment">//部门列表页面的显示需要执行另一个Servlet。怎么办？转发。</span></span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/dept/list&quot;</span>).forward(request, response);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 删除失败</span></span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/error.html&quot;</span>).forward(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第八步：新增部门</p><ul><li>注意：最后保存成功之后，转发到 /dept/list的时候，会出现405，为什么？<ul><li>第一：保存用的是post请求。底层要执行doPost方法。</li><li>第二：转发是一次请求，之前是post，之后还是post，因为它是一次请求。</li><li>第三：/dept/list Servlet当中只有一个doGet方法。</li><li>怎么解决？两种方案<ul><li>第一种：在/dept/listServlet中添加doPost方法，然后在doPost方法中调用doGet。</li><li>第二种：重定向。</li></ul></li></ul></li></ul></li><li><p>第九步：跳转到修改部门的页面</p></li><li><p>第十步：修改部门</p></li></ul><h2id="在一个web应用中应该如何完成资源的跳转">在一个web应用中应该如何完成资源的跳转</h2><ul><li><p>在一个web应用中通过两种方式，可以完成资源的跳转：</p><ul><li>第一种方式：转发</li><li>第二种方式：重定向</li></ul></li><li><p>转发和重定向有什么区别？</p><ul><li><p>代码上有什么区别？</p><ul><li>转发</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取请求转发器对象</span></span><br><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/dept/list&quot;</span>);</span><br><span class="line"><span class="comment">// 调用请求转发器对象的forward方法完成转发</span></span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并一行代码</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/dept/list&quot;</span>).forward(request, response);</span><br><span class="line"><span class="comment">// 转发的时候是一次请求，不管你转发了多少次。都是一次请求。</span></span><br><span class="line"><span class="comment">// AServlet转发到BServlet，再转发到CServlet，再转发到DServlet，不管转发了多少次，都在同一个request当中。</span></span><br><span class="line"><span class="comment">// 这是因为调用forward方法的时候，会将当前的request和response对象传递给下一个Servlet。</span></span><br></pre></td></tr></table></figure><ul><li>重定向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：路径上要加一个项目名。为什么？</span></span><br><span class="line"><span class="comment">// 浏览器发送请求，请求路径上是需要添加项目名的。</span></span><br><span class="line"><span class="comment">// 以下这一行代码会将请求路径“/oa/dept/list”发送给浏览器</span></span><br><span class="line"><span class="comment">// 浏览器会自发的向服务器发送一次全新的请求：/oa/dept/list</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;/oa/dept/list&quot;</span>);</span><br></pre></td></tr></table></figure><p>​</p><ul><li><p>形式上有什么区别？</p><ul><li>转发（一次请求）<ul><li>在浏览器地址栏上发送的请求是：http://localhost:8080/servlet10/a，最终请求结束之后，浏览器地址栏上的地址还是这个。没变。</li></ul></li><li>重定向（两次请求）<ul><li>在浏览器地址栏上发送的请求是：http://localhost:8080/servlet10/a，最终在浏览器地址栏上显示的地址是：http://localhost:8080/servlet10/b</li></ul></li></ul></li><li><p>转发和重定向的本质区别？</p><ul><li>转发：是由WEB服务器来控制的。A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的。</li><li>重定向：是浏览器完成的。具体跳转到哪个资源，是浏览器说了算。</li></ul></li><li><p>使用一个例子去描述这个转发和重定向</p><ul><li>借钱（转发：发送了一次请求）<ul><li>杜老师没钱了，找张三借钱，其实张三没有钱，但是张三够义气，张三自己找李四借了钱，然后张三把这个钱给了杜老师，杜老师不知道这个钱是李四的，杜老师只求了一个人。杜老师以为这个钱就是张三的。</li></ul></li><li>借钱（重定向：发送了两次请求）<ul><li>杜老师没钱了，找张三借钱，张三没有钱，张三有一个好哥们，叫李四，李四是个富二代，于是张三将李四的家庭住址告诉了杜老师，杜老师按照这个地址去找到李四，然后从李四那里借了钱。显然杜老师在这个过程中，求了两个人。并且杜老师知道最终这个钱是李四借给俺的。</li></ul></li></ul></li><li><p>转发和重定向应该如何选择？什么时候使用转发，什么时候使用重定向？</p><ul><li>如果在上一个Servlet当中向request域当中绑定了数据，希望从下一个Servlet当中把request域里面的数据取出来，使用转发机制。</li><li>剩下所有的请求均使用重定向。（重定向使用较多。）</li></ul></li><li><p>跳转的下一个资源有没有要求呢？必须是一个Servlet吗？</p><ul><li>不一定，跳转的资源只要是服务器内部合法的资源即可。包括：Servlet、JSP、HTML…..</li></ul></li><li><p>转发会存在浏览器的刷新问题。</p></li></ul><h2id="将oa项目中的资源跳转修改为合适的跳转方式">将oa项目中的资源跳转修改为合适的跳转方式</h2><ul><li>删除之后，重定向</li><li>修改之后，重定向</li><li>保存之后，重定向</li><li>重定向：<ul><li>成功</li><li>失败</li></ul></li></ul><h2 id="servlet注解简化配置">Servlet注解，简化配置</h2><ul><li><p>分析oa项目中的web.xml文件</p><ul><li>现在只是一个单标的CRUD，没有复杂的业务逻辑，很简单的一丢丢功能。web.xml文件中就有如此多的配置信息。如果采用这种方式，对于一个大的项目来说，这样的话web.xml文件会非常庞大，有可能最终会达到几十兆。</li><li>在web.xml文件中进行servlet信息的配置，显然开发效率比较低，每一个都需要配置一下。</li><li>而且在web.xml文件中的配置是很少被修改的，所以这种配置信息能不能直接写到java类当中呢？可以的。</li></ul></li><li><p>Servlet3.0版本之后，推出了各种Servlet基于注解式开发。优点是什么？</p><ul><li>开发效率高，不需要编写大量的配置信息。直接在java类上使用注解进行标注。</li><li>web.xml文件体积变小了。</li></ul></li><li><p>并不是说注解有了之后，web.xml文件就不需要了：</p><ul><li>有一些需要变化的信息，还是要配置到web.xml文件中。一般都是注解+配置文件 的开发模式。</li><li>一些不会经常变化修改的配置建议使用注解。一些可能会被修改的建议写到配置文件中。</li></ul></li><li><p>我们的第一个注解：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jakarta.servlet.annotation.WebServlet</span><br></pre></td></tr></table></figure><ul><li><p>在Servlet类上使用：<span class="citation"data-cites="WebServlet">@WebServlet</span>，WebServlet注解中有哪些属性呢？</p><ul><li>name属性：用来指定Servlet的名字。等同于：<servlet-name></li><li>urlPatterns属性：用来指定Servlet的映射路径。可以指定多个字符串。<url-pattern></li><li>loadOnStartUp属性：用来指定在服务器启动阶段是否加载该Servlet。等同于：<load-on-startup></li><li>value属性：当注解的属性名是value的时候，使用注解的时候，value属性名是可以省略的。</li><li>注意：不是必须将所有属性都写上，只需要提供需要的。（需要什么用什么。）</li><li>注意：属性是一个数组，如果数组中只有一个元素，使用该注解的时候，属性值的大括号可以省略。</li></ul></li><li><p>注解对象的使用格式：</p><ul><li><span class="citation"data-cites="注解名称">@注解名称</span>(属性名=属性值, 属性名=属性值,属性名=属性值….)</li></ul></li></ul><h2id="使用模板方法设计模式优化oa项目">使用模板方法设计模式优化oa项目</h2><ul><li>上面的注解解决了配置文件的问题。但是现在的oa项目仍然存在一个比较臃肿的问题。<ul><li>一个单标的CRUD，就写了6个Servlet。如果一个复杂的业务系统，这种开发方式，显然会导致类爆炸。（类的数量太大。）</li><li>怎么解决这个类爆炸问题？可以使用模板方法设计模式。</li></ul></li><li>怎么解决类爆炸问题？<ul><li>以前的设计是一个请求一个Servlet类。1000个请求对应1000个Servlet类。导致类爆炸。</li><li>可以这样做：一个请求对应一个方法。一个业务对应一个Servlet类。</li><li>处理部门相关业务的对应一个DeptServlet。处理用户相关业务的对应一个UserServlet。处理银行卡卡片业务对应一个CardServlet。</li></ul></li></ul><h2id="分析使用纯粹servlet开发web应用的缺陷">分析使用纯粹Servlet开发web应用的缺陷</h2><ul><li>在Servlet当中编写HTML/CSS/JavaScript等前端代码。存在什么问题？<ul><li>java程序中编写前端代码，编写难度大。麻烦。</li><li>java程序中编写前端代码，显然程序的耦合度非常高。</li><li>java程序中编写前端代码，代码非常不美观。</li><li>java程序中编写前端代码，维护成本太高。（非常难于维护）<ul><li>修改小小的一个前端代码，只要有改动，就需要重新编译java代码，生成新的class文件，打一个新的war包，重新发布。</li></ul></li></ul></li><li>思考一下，如果是你的话，你准备怎么解决这个问题？<ul><li>思路很重要。使用什么样的思路去做、去解决这个问题<ul><li>上面的那个Servlet（Java程序）能不能不写了，让机器自动生成。我们程序员只需要写这个Servlet程序中的“前端的那段代码”，然后让机器将我们写的“前端代码”自动翻译生成“Servlet这种java程序”。然后机器再自动将“java”程序编译生成”class”文件。然后再使用JVM调用这个class中的方法。</li></ul></li></ul></li></ul><h2id="关于bs结构系统的会话机制session机制">关于B/S结构系统的会话机制（session机制）</h2><ul><li><p>什么是会话？</p><ul><li>会话对应的英语单词：session</li><li>用户打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做：一次会话。会话在服务器端也有一个对应的java对象，这个java对象叫做：session。</li><li>什么是一次请求：用户在浏览器上点击了一下，然后到页面停下来，可以粗略认为是一次请求。请求对应的服务器端的java对象是：request。</li><li>一个会话当中包含多次请求。（一次会话对应N次请求。）</li></ul></li><li><p>在java的servlet规范当中，session对应的类名：HttpSession（jarkata.servlet.http.HttpSession）</p></li><li><p>session机制属于B/S结构的一部分。如果使用php语言开发WEB项目，同样也是有session这种机制的。session机制实际上是一个规范。然后不同的语言对这种会话机制都有实现。</p></li><li><p>session对象最主要的作用是：保存会话状态。（用户登录成功了，这是一种登录成功的状态，你怎么把登录成功的状态一直保存下来呢？使用session对象可以保留会话状态。）</p></li><li><p>为什么需要session对象来保存会话状态呢？</p><ul><li>因为HTTP协议是一种无状态协议。</li><li>什么是无状态：请求的时候，B和S是连接的，但是请求结束之后，连接就断了。为什么要这么做？HTTP协议为什么要设计成这样？因为这样的无状态协议，可以降低服务器的压力。请求的瞬间是连接的，请求结束之后，连接断开，这样服务器压力小。</li><li>只要B和S断开了，那么关闭浏览器这个动作，服务器知道吗？<ul><li>不知道。服务器是不知道浏览器关闭的。</li></ul></li></ul></li><li><p>张三打开一个浏览器A，李四打开一个浏览器B，访问服务器之后，在服务器端会生成：</p><ul><li>张三专属的session对象</li><li>李四专属的session对象</li></ul></li><li><p>为什么不使用request对象保存会话状态？为什么不使用ServletContext对象保存会话状态？</p><ul><li>request.setAttribute()存，request.getAttribute()取，ServletContext也有这个方法。request是请求域。ServletContext是应用域。</li><li>request是一次请求一个对象。</li><li>ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个ServletContext对象只有一个。</li><li>ServletContext对象的域太大。</li><li>request请求域（HttpServletRequest）、session会话域（HttpSession）、application域（ServletContext）</li><li>request &lt; session &lt; application</li></ul></li><li><p>思考一下：session对象的实现原理。</p><ul><li>HttpSession session = request.getSession();</li><li>这行代码很神奇。张三访问的时候获取的session对象就是张三的。李四访问的时候获取的session对象就是李四的。</li></ul></li><li><p>session的实现原理：</p><ul><li>JSESSIONID=xxxxxx这个是以Cookie的形式保存在浏览器的内存中的。浏览器只要关闭。这个cookie就没有了。</li><li>session列表是一个Map，map的key是sessionid，map的value是session对象。</li><li>用户第一次请求，服务器生成session对象，同时生成id，将id发送给浏览器。</li><li>用户第二次请求，自动将浏览器内存中的id发送给服务器，服务器根据id查找session对象。</li><li>关闭浏览器，内存消失，cookie消失，sessionid消失，会话等同于结束。</li></ul></li><li><p>Cookie禁用了，session还能找到吗？</p><ul><li>cookie禁用是什么意思？服务器正常发送cookie给浏览器，但是浏览器不要了。拒收了。并不是服务器不发了。</li><li>找不到了。每一次请求都会获取到新的session对象。</li><li>cookie禁用了，session机制还能实现吗？<ul><li>可以。需要使用URL重写机制。</li><li>http://localhost:8080/servlet12/test/session;jsessionid=19D1C99560DCBF84839FA43D58F56E16</li><li>URL重写机制会提高开发者的成本。开发人员在编写任何请求路径的时候，后面都要添加一个sessionid，给开发带来了很大的难度，很大的成本。所以大部分的网站都是这样设计的：你要是禁用cookie，你就别用了。</li></ul></li></ul></li><li><p>总结一下到目前位置我们所了解的域对象：</p><ul><li>request（对应的类名：HttpServletRequest）<ul><li>请求域（请求级别的）</li></ul></li><li>session（对应的类名：HttpSession）<ul><li>会话域（用户级别的）</li></ul></li><li>application（对应的类名：ServletContext）<ul><li>应用域（项目级别的，所有用户共享的。）</li></ul></li><li>这三个域对象的大小关系<ul><li>request &lt; session &lt; application</li></ul></li><li>他们三个域对象都有以下三个公共的方法：<ul><li>setAttribute（向域当中绑定数据）</li><li>getAttribute（从域当中获取数据）</li><li>removeAttribute（删除域当中的数据）</li></ul></li><li>使用原则：尽量使用小的域。</li></ul></li><li><p>session掌握之后，我们怎么解决oa项目中的登录问题，怎么能让登录起作用。</p><ul><li>登录成功之后，可以将用户的登录信息存储到session当中。也就是说session中如果有用户的信息就代表用户登录成功了。session中没有用户信息，表示用户没有登录过。则跳转到登录页面。</li></ul></li><li><p>销毁session对象：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure><h2 id="cookie">Cookie</h2><ul><li><p>session的实现原理中，每一个session对象都会关联一个sessionid，例如：</p><ul><li>JSESSIONID=41C481F0224664BDB28E95081D23D5B8</li><li>以上的这个键值对数据其实就是cookie对象。</li><li>对于session关联的cookie来说，这个cookie是被保存在浏览器的“运行内存”当中。</li><li>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie发送给服务器。</li><li>例如，这个Cookie:JSESSIONID=41C481F0224664BDB28E95081D23D5B8就会再次发送给服务器。</li><li>服务器就是根据41C481F0224664BDB28E95081D23D5B8这个值来找到对应的session对象的。</li></ul></li><li><p>cookie怎么生成？cookie保存在什么地方？cookie有啥用？浏览器什么时候会发送cookie，发送哪些cookie给服务器？？？？？？？</p></li><li><p>cookie最终是保存在浏览器客户端上的。</p><ul><li>可以保存在运行内存中。（浏览器只要关闭cookie就消失了。）</li><li>也可以保存在硬盘文件中。（永久保存。）</li></ul></li><li><p>cookie有啥用呢？</p><ul><li>cookie和session机制其实都是为了保存会话的状态。</li><li>cookie是将会话的状态保存在浏览器客户端上。（cookie数据存储在浏览器客户端上的。）</li><li>session是将会话的状态保存在服务器端上。（session对象是存储在服务器上。）</li><li>为什么要有cookie和session机制呢？因为HTTP协议是无状态无连接协议。</li></ul></li><li><p>cookie的经典案例</p><ul><li>京东商城，在未登录的情况下，向购物车中放几件商品。然后关闭商城，再次打开浏览器，访问京东商城的时候，购物车中的商品还在，这是怎么做的？我没有登录，为什么购物车中还有商品呢？<ul><li>将购物车中的商品编号放到cookie当中，cookie保存在硬盘文件当中。这样即使关闭浏览器。硬盘上的cookie还在。下一次再打开京东商城的时候，查看购物车的时候，会自动读取本地硬盘中存储的cookie，拿到商品编号，动态展示购物车中的商品。<ul><li>京东存储购物车中商品的cookie可能是这样的：productIds=xxxxx,yyyy,zzz,kkkk</li><li>注意：cookie如果清除掉，购物车中的商品就消失了。</li></ul></li></ul></li><li>126邮箱中有一个功能：十天内免登录<ul><li>这个功能也是需要cookie来实现的。</li><li>怎么实现的呢？<ul><li>用户输入正确的用户名和密码，并且同时选择十天内免登录。登录成功后。浏览器客户端会保存一个cookie，这个cookie中保存了用户名和密码等信息，这个cookie是保存在硬盘文件当中的，十天有效。在十天内用户再次访问126的时候，浏览器自动提交126的关联的cookie给服务器，服务器接收到cookie之后，获取用户名和密码，验证，通过之后，自动登录成功。</li><li>怎么让cookie失效？<ul><li>十天过后自动失效。</li><li>或者改密码。</li><li>或者在客户端浏览器上清除cookie。</li></ul></li></ul></li></ul></li></ul></li><li><p>cookie机制和session机制其实都不属于java中的机制，实际上cookie机制和session机制都是HTTP协议的一部分。php开发中也有cookie和session机制，只要是你是做web开发，不管是什么编程语言，cookie和session机制都是需要的。</p></li><li><p>HTTP协议中规定：任何一个cookie都是由name和value组成的。name和value都是字符串类型的。</p></li><li><p>在java的servlet中，对cookie提供了哪些支持呢？</p><ul><li>提供了一个Cookie类来专门表示cookie数据。jakarta.servlet.http.Cookie;</li><li>java程序怎么把cookie数据发送给浏览器呢？response.addCookie(cookie);</li></ul></li><li><p>在HTTP协议中是这样规定的：当浏览器发送请求的时候，会自动携带该path下的cookie数据给服务器。（URL。）</p></li><li><p>关于cookie的有效时间</p><ul><li>怎么用java设置cookie的有效时间<ul><li>cookie.setMaxAge(60 * 60); 设置cookie在一小时之后失效。</li></ul></li><li>没有设置有效时间：默认保存在浏览器的运行内存中，浏览器关闭则cookie消失。</li><li>只要设置cookie的有效时间 &gt;0，这个cookie一定会存储到硬盘文件当中。</li><li>设置cookie的有效时间 = 0 呢？<ul><li>cookie被删除，同名cookie被删除。</li></ul></li><li>设置cookie的有效时间 &lt; 0 呢？<ul><li>保存在运行内存中。和不设置一样。</li></ul></li></ul></li><li><p>关于cookie的path，cookie关联的路径：</p><ul><li>假设现在发送的请求路径是“http://localhost:8080/servlet13/cookie/generate”生成的cookie，如果cookie没有设置path，默认的path是什么？<ul><li>默认的path是：http://localhost:8080/servlet13/cookie以及它的子路径。</li><li>也就是说，以后只要浏览器的请求路径是http://localhost:8080/servlet13/cookie这个路径以及这个路径下的子路径，cookie都会被发送到服务器。</li></ul></li><li>手动设置cookie的path<ul><li>cookie.setPath(“/servlet13”);表示只要是这个servlet13项目的请求路径，都会提交这个cookie给服务器。</li></ul></li></ul></li><li><p>浏览器发送cookie给服务器了，服务器中的java程序怎么接收？</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies(); <span class="comment">// 这个方法可能返回null</span></span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">        <span class="comment">// 获取cookie的name</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">        <span class="comment">// 获取cookie的value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用cookie实现一下十天内免登录功能。</p><ul><li>先实现登录功能<ul><li>登录成功<ul><li>跳转到部门列表页面</li></ul></li><li>登录失败<ul><li>跳转到登录失败页面</li></ul></li></ul></li><li>修改前端页面<ul><li>在登录页面给一个复选框，复选框后面给一句话：十天内免登录。</li><li>用户选择了复选框：表示要支持十天内免登录。</li><li>用户没有选择复选框：表示用户不想使用十天内免登录功能。</li></ul></li><li>修改Servlet中的login方法<ul><li>如果用户登录成功了，并且用户登录时选择了十天内免登录功能，这个时候应该在Servlet的login方法中创建cookie，用来存储用户名和密码，并且设置路径，设置有效期，将cookie响应给浏览器。（浏览器将其自动保存在硬盘文件当中10天）</li></ul></li><li>用户再次访问该网站的时候，访问这个网站的首页的时候，有两个走向:<ul><li>要么跳转到部门列表页面</li><li>要么跳转到登录页面</li><li>以上分别有两个走向，这显然是需要编写java程序进行控制的。</li></ul></li></ul></li></ul><h1 id="jsp">JSP</h1><ul><li><p>我的第一个JSP程序：</p><ul><li>在WEB-INF目录之外创建一个index.jsp文件，然后这个文件中没有任何内容。</li></ul></li><li><p>将上面的项目部署之后，启动服务器，打开浏览器，访问以下地址：</p><ul><li>http://localhost:8080/jsp/index.jsp展现在大家面前的是一个空白。</li><li>实际上访问以上的这个：index.jsp，底层执行的是：index_jsp.class这个java程序。</li><li>这个index.jsp会被tomcat翻译生成index_jsp.java文件，然后tomcat服务器又会将index_jsp.java编译生成index_jsp.class文件</li><li>访问index.jsp，实际上执行的是index_jsp.class中的方法。</li></ul></li><li><p>JSP实际上就是一个Servlet。</p><ul><li>index.jsp访问的时候，会自动翻译生成index_jsp.java，会自动编译生成index_jsp.class，那么index_jsp这就是一个类。</li><li>index_jsp 类继承HttpJspBase，而HttpJspBase类继承的是HttpServlet。所以index_jsp类就是一个Servlet类。</li><li>jsp的生命周期和Servlet的生命周期完全相同。完全就是一个东西。没有任何区别。</li><li>jsp和servlet一样，都是单例的。（假单例。）</li></ul></li><li><p>jsp文件第一次访问的时候是比较慢的，为什么？</p><ul><li>为什么大部分的运维人员在给客户演示项目的时候，为什么提前先把所有的jsp文件先访问一遍。</li><li>第一次比较麻烦：<ul><li>要把jsp文件翻译生成java源文件</li><li>java源文件要编译生成class字节码文件</li><li>然后通过class去创建servlet对象</li><li>然后调用servlet对象的init方法</li><li>最后调用servlet对象的service方法。</li></ul></li><li>第二次就比较快了，为什么？<ul><li>因为第二次直接调用单例servlet对象的service方法即可。</li></ul></li></ul></li><li><p>JSP是什么？</p><ul><li>JSP是java程序。（JSP本质还是一个Servlet）</li><li>JSP是：JavaServerPages的缩写。（基于Java语言实现的服务器端的页面。）</li><li>Servlet是JavaEE的13个子规范之一，那么JSP也是JavaEE的13个子规范之一。</li><li>JSP是一套规范。所有的web容器/web服务器都是遵循这套规范的，都是按照这套规范进行的“翻译”</li><li>每一个web容器/web服务器都会内置一个JSP翻译引擎。</li></ul></li><li><p>对JSP进行错误调试的时候，还是要直接打开JSP文件对应的java文件，检查java代码。</p></li><li><p>开发JSP的最高境界：</p><ul><li>眼前是JSP代码，但是脑袋中呈现的是java代码。</li></ul></li><li><p>JSP既然本质上是一个Servlet，那么JSP和Servlet到底有什么区别呢？</p><ul><li>职责不同：<ul><li>Servlet的职责是什么：收集数据。（Servlet的强项是逻辑处理，业务处理，然后链接数据库，获取/收集数据。）</li><li>JSP的职责是什么：展示数据。（JSP的强项是做数据的展示）</li></ul></li></ul></li><li><p>JSP的基础语法</p><ul><li>在jsp文件中直接编写文字，都会自动被翻译到哪里？<ul><li>翻译到servlet类的service方法的out.write(“翻译到这里”)，直接翻译到双引号里，被java程序当做普通字符串打印输出到浏览器。</li><li>在JSP中编写的HTML CSSJS代码，这些代码对于JSP来说只是一个普通的字符串。但是JSP把这个普通的字符串一旦输出到浏览器，浏览器就会对HTMLCSS JS进行解释执行。展现一个效果。</li></ul></li><li>JSP的page指令（这个指令后面再详细说，这里先解决一下中文乱码问题），解决响应时的中文乱码问题：<ul><li>通过page指令来设置响应的内容类型，在内容类型的最后面添加：charset=UTF-8<ul><li>&lt;%<span class="citation" data-cites="page">@page</span>contentType=“text/html;charset=UTF-8”%&gt;，表示响应的内容类型是text/html，采用的字符集UTF-8</li><li>&lt;%<span class="citation" data-cites="page">@page</span>import=“java.util.List,java.util.ArrayList”%&gt;</li></ul></li></ul></li><li>怎么在JSP中编写Java程序：<ul><li>&lt;% java语句; %&gt;<ul><li>在这个符号当中编写的被视为java程序，被翻译到Servlet类的service方法内部。</li><li>这里你要细心点，你要思考，在&lt;%%&gt;这个符号里面写java代码的时候，你要时时刻刻的记住你正在“方法体”当中写代码，方法体中可以写什么，不可以写什么，你心里是否明白呢？</li><li>在service方法当中编写的代码是有顺序的，方法体当中的代码要遵循自上而下的顺序依次逐行执行。</li><li>service方法当中不能写静态代码块，不能写方法，不能定义成员变量。。。。。。</li><li>在同一个JSP当中 &lt;%%&gt; 这个符号可以出现多个。</li></ul></li><li>&lt;%! %&gt;<ul><li>在这个符号当中编写的java程序会自动翻译到service方法之外。</li><li>这个语法很少用，为什么？不建议使用，因为在service方法外面写静态变量和实例变量，都会存在线程安全问题，因为JSP就是servlet，servlet是单例的，多线程并发的环境下，这个静态变量和实例变量一旦有修改操作，必然会存在线程安全问题。</li></ul></li><li>JSP的输出语句<ul><li>怎么向浏览器上输出一个java变量。</li><li>&lt;% String name = “jack”; out.write(“name =” + name); %&gt;</li><li>注意：以上代码中的out是JSP的九大内置对象之一。可以直接拿来用。当然，必须只能在service方法内部使用。</li><li>如果向浏览器上输出的内容中没有“java代码”，例如输出的字符串是一个固定的字符串，可以直接在jsp中编写，不需要写到&lt;%%&gt;这里。</li><li>如果输出的内容中含有“java代码”，这个时候可以使用以下语法格式：<ul><li>&lt;%= %&gt; 注意：在=的后面编写要输出的内容。</li><li>&lt;%= %&gt; 这个符号会被翻译到哪里？最终翻译成什么？<ul><li>翻译成了这个java代码： out.print();</li><li>翻译到service方法当中了。</li></ul></li><li>什么时候使用&lt;%=%&gt;输出呢？输出的内容中含有java的变量，输出的内容是一个动态的内容，不是一个死的字符串。如果输出的是一个固定的字符串，直接在JSP文件中编写即可。</li></ul></li></ul></li></ul></li><li>在JSP中如何编写JSP的专业注释<ul><li>&lt;%–JSP的专业注释，不会被翻译到java源代码当中。–%&gt;</li><li><!--这种注释属于HTML的注释，这个注释信息仍然会被翻译到java源代码当中，不建议。--></li></ul></li><li>JSP基础语法总结：<ul><li>JSP中直接编写普通字符串<ul><li>翻译到service方法的out.write(“这里”)</li></ul></li><li>&lt;%%&gt;<ul><li>翻译到service方法体内部，里面是一条一条的java语句。</li></ul></li><li>&lt;%! %&gt;<ul><li>翻译到service方法之外。</li></ul></li><li>&lt;%= %&gt;<ul><li>翻译到service方法体内部，翻译为：out.print();</li></ul></li><li>&lt;%<span class="citation" data-cites="page">@page</span>contentType=“text/html;charset=UTF-8”%&gt;<ul><li>page指令，通过contentType属性用来设置响应的内容类型。</li></ul></li></ul></li><li>使用Servlet + JSP完成oa项目的改造。<ul><li><p>使用Servlet处理业务，收集数据。 使用JSP展示数据。</p></li><li><p>将之前原型中的html文件，全部修改为jsp，然后在jsp文件头部添加page指令（指定contentType防止中文乱码），将所有的JSP直接拷贝到web目录下。</p></li><li><p>完成所有页面的正常流转。（页面仍然能够正常的跳转。修改超链接的请求路径。）</p><ul><li>&lt;%=request.getContextPath() %&gt;在JSP中动态的获取应用的根路径。</li></ul></li><li><p>Servlet中连接数据库，查询所有的部门，遍历结果集。</p><ul><li>遍历结果集的过程中，取出部门编号、部门名、位置等信息，封装成java对象。</li><li>将java对象存放到List集合中。</li><li>将List集合存储到request域当中。</li><li>转发forward到jsp。</li></ul></li><li><p>在JSP中：</p><ul><li>从request域当中取出List集合。</li><li>遍历List集合，取出每个部门对象。动态生成tr。</li></ul></li><li><p>思考一个问题：如果我只用JSP这一个技术，能不能开发web应用？</p><ul><li>当然可以使用JSP来完成所有的功能。因为JSP就是Servlet，在JSP的&lt;%%&gt;里面写的代码就是在service方法当中的，所以在&lt;%%&gt;当中完全可以编写JDBC代码，连接数据库，查询数据，也可以在这个方法当中编写业务逻辑代码，处理业务，都是可以的，所以使用单独的JSP开发web应用完全没问题。</li><li>虽然JSP一个技术就可以完成web应用，但是不建议，还是建议采用servlet +jsp的方式进行开发。这样都能将各自的优点发挥出来。JSP就是做数据展示。Servlet就是做数据的收集。（JSP中编写的Java代码越少越好。）一定要职责分明。</li></ul></li><li><p>JSP文件的扩展名必须是xxx.jsp吗？</p><ul><li><p>jsp文件的扩展名是可以配置的。不是固定的。</p></li><li><p>在CATALINA_HOME/conf/web.xml，在这个文件当中配置jsp文件的扩展名。</p></li></ul></li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jspx<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>xxx.jsp文件对于小猫咪来说，只是一个普通的文本文件，web容器会将xxx.jsp文件最终生成java程序，最终调用的是java对象相关的方法，真正执行的时候，和jsp文件就没有关系了。</p><ul><li>小窍门：JSP如果看不懂，建议把jsp翻译成java代码，就能看懂了。</li></ul></li><li><p>同学问：包名bean是什么意思？</p><ul><li><p>javabean（java的logo是一杯冒着热气的咖啡。javabean被翻译为：咖啡豆）</p></li><li><p>java是一杯咖啡，咖啡又是由一粒一粒的咖啡豆研磨而成。</p></li><li><p>整个java程序中有很多bean的存在。由很多bean组成。</p></li><li><p>什么是javabean？实际上javabean你可以理解为符合某种规范的java类，比如：</p></li><li><p>有无参数构造方法</p></li><li><p>属性私有化</p></li><li><p>对外提供公开的set和get方法</p></li><li><p>实现java.io.Serializable接口</p></li><li><p>重写toString</p></li><li><p>重写hashCode+equals</p></li><li><p>….</p></li><li><p>javabean其实就是java中的实体类。负责数据的封装。</p></li><li><p>由于javabean符合javabean规范，具有更强的通用性。</p></li><li><p>完成剩下所有功能的改造。</p></li></ul></li><li><p>当前的oa应用存在的问题：</p><ul><li>任何一个用户都可以访问这个系统，都可以对这个系统当中的数据进行增删改这些危险的操作。我只想让合法的用户去使用这个系统，不合法的用户不能访问这个系统，怎么办？<ul><li>加一个登录功能。登录成功的可以访问该系统，登录失败不能访问。</li></ul></li><li>实现登录功能：<ul><li>步骤1：数据库当中添加一个用户表：t_user<ul><li>t_user表当中存储的是用户的登录信息，最基本的也包括：登录的用户名和登录的密码。</li><li>密码一般在数据库表当中存储的是密文。一般不以明文的形式存储。（这里先使用明文方式。）</li><li>向t_user表中插入数据。</li></ul></li><li>步骤2：再实现一个登录页面。<ul><li>登录页面上应该有一个登录的表单。有用户名和密码输入的框。</li><li>用户点击登录，提交表单，提交用户名和密码。form是post方式提交。</li></ul></li><li>步骤3：后台要有一个对应的Servlet来处理登录的请求。<ul><li>登录成功：跳转到部门列表页面。</li><li>登录失败：跳转到失败的页面。</li></ul></li><li>步骤4：再提供一个登录失败的页面。</li></ul></li></ul></li><li><p>登录功能实现了，目前存在的最大的问题：</p><ul><li>这个登录功能目前只是一个摆设，没有任何作用。只要用户知道后端的请求路径，照样可以在不登录的情况下访问。</li><li>这个登录没有真正起到拦截的作用。怎么解决？</li></ul></li><li><p>JSP的指令</p><ul><li><p>指令的作用：指导JSP的翻译引擎如何工作（指导当前的JSP翻译引擎如何翻译JSP文件。）</p></li><li><p>指令包括哪些呢？</p><ul><li>include指令：包含指令，在JSP中完成静态包含，很少用了。（这里不讲）</li><li>taglib指令：引入标签库的指令。这个到JJSTL标签库的时候再学习。现在先不管。</li><li>page指令：目前重点学习一个page指令。</li></ul></li><li><p>指令的使用语法是什么？</p><ul><li>&lt;%<span class="citation" data-cites="指令名">@指令名</span>属性名=属性值 属性名=属性值 属性名=属性值….%&gt;</li></ul></li><li><p>关于page指令当中都有哪些常用的属性呢？</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page session=&quot;true|false&quot; %&gt;</span><br><span class="line">true表示启用JSP的内置对象session，表示一定启动session对象。没有session对象会创建。</span><br><span class="line">如果没有设置，默认值就是session=&quot;true&quot;</span><br><span class="line">session=&quot;false&quot; 表示不启动内置对象session。当前JSP页面中无法使用内置对象session。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page contentType=&quot;text/json&quot; %&gt;</span><br><span class="line">contentType属性用来设置响应的内容类型</span><br><span class="line">但同时也可以设置字符集。</span><br><span class="line">&lt;%@page contentType=&quot;text/json;charset=UTF-8&quot; %&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt;</span><br><span class="line">pageEncoding=&quot;UTF-8&quot; 表示设置响应时采用的字符集。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page import=&quot;java.util.List, java.util.Date, java.util.ArrayList&quot; %&gt;</span><br><span class="line">&lt;%@page import=&quot;java.util.*&quot; %&gt;</span><br><span class="line">import语句，导包。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page errorPage=&quot;/error.jsp&quot; %&gt;</span><br><span class="line">当前页面出现异常之后，跳转到error.jsp页面。</span><br><span class="line">errorPage属性用来指定出错之后的跳转位置。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page isErrorPage=&quot;true&quot; %&gt;</span><br><span class="line">表示启用JSP九大内置对象之一：exception</span><br><span class="line">默认值是false。</span><br></pre></td></tr></table></figure><ul><li><p>JSP的九大内置对象</p><ul><li><p>jakarta.servlet.jsp.PageContext pageContext 页面作用域</p></li><li><p>jakarta.servlet.http.HttpServletRequest request请求作用域</p></li><li><p>jakarta.servlet.http.HttpSession session 会话作用域</p></li><li><p>jakarta.servlet.ServletContext application 应用作用域</p><ul><li>pageContext &lt; request &lt; session &lt; application</li><li>以上四个作用域都有：setAttribute、getAttribute、removeAttribute方法。</li><li>以上作用域的使用原则：尽可能使用小的域。</li></ul></li><li><p>java.lang.Throwable exception</p></li><li><p>jakarta.servlet.ServletConfig config</p></li><li><p>java.lang.Object page （其实是this，当前的servlet对象）</p></li><li><p>jakarta.servlet.jsp.JspWriter out （负责输出）</p></li><li><p>jakarta.servlet.http.HttpServletResponse response（负责响应）</p></li></ul></li></ul><h1 id="el表达式">EL表达式</h1><ul><li>EL表达式是干什么用的？<ul><li>Expression Language（表达式语言）</li><li>EL表达式可以代替JSP中的java代码，让JSP文件中的程序看起来更加整洁，美观。</li><li>JSP中夹杂着各种java代码，例如&lt;% java代码%&gt;、&lt;%=%&gt;等，导致JSP文件很混乱，不好看，不好维护。所以才有了后期的EL表达式。</li><li>EL表达式可以算是JSP语法的一部分。EL表达式归属于JSP。</li></ul></li><li>EL表达式出现在JSP中主要是：<ul><li>从某个作用域中取数据，然后将其转换成字符串，然后将其输出到浏览器。这就是EL表达式的功效。三大功效：<ul><li>第一功效：从某个域中取数据。<ul><li>四个域：<ul><li>pageContext</li><li>request</li><li>session</li><li>application</li></ul></li></ul></li><li>第二功效：将取出的数据转成字符串。<ul><li>如果是一个java对象，也会自动调用java对象的toString方法将其转换成字符串。</li></ul></li><li>第三功效：将字符串输出到浏览器。<ul><li>和这个一样：&lt;%= %&gt;，将其输出到浏览器。</li></ul></li></ul></li></ul></li><li>EL表达式很好用，基本的语法格式：<ul><li>${表达式}</li></ul></li><li>EL表达式的使用：</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="comment">// 创建User对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setUsername(<span class="string">&quot;jackson&quot;</span>);</span><br><span class="line">user.setPassword(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将User对象存储到某个域当中。一定要存，因为EL表达式只能从某个范围中取数据。</span></span><br><span class="line"><span class="comment">// 数据是必须存储到四大范围之一的。</span></span><br><span class="line">request.setAttribute(<span class="string">&quot;userObj&quot;</span>, user);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--使用EL表达式取--%&gt;</span><br><span class="line">$&#123;这个位置写什么？？？？这里写的一定是存储到域对象当中时的name&#125;</span><br><span class="line">要这样写：</span><br><span class="line">$&#123;userObj&#125;</span><br><span class="line">等同于java代码：&lt;%=request.getAttribute(<span class="string">&quot;userObj&quot;</span>)%&gt;</span><br><span class="line">你不要这样写：$&#123;<span class="string">&quot;userObj&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">面试题：</span><br><span class="line">$&#123;abc&#125; 和 $&#123;<span class="string">&quot;abc&quot;</span>&#125;的区别是什么？</span><br><span class="line">$&#123;abc&#125;表示从某个域中取出数据，并且被取的这个数据的name是<span class="string">&quot;abc&quot;</span>，之前一定有这样的代码: 域.setAttribute(<span class="string">&quot;abc&quot;</span>, 对象);</span><br><span class="line">$&#123;<span class="string">&quot;abc&quot;</span>&#125; 表示直接将<span class="string">&quot;abc&quot;</span>当做普通字符串输出到浏览器。不会从某个域中取数据了。</span><br><span class="line"></span><br><span class="line">$&#123;userObj&#125; 底层是怎么做的？从域中取数据，取出user对象，然后调用user对象的toString方法，转换成字符串，输出到浏览器。</span><br><span class="line"></span><br><span class="line">&lt;%--如果想输出对象的属性值，怎么办？--%&gt;</span><br><span class="line">$&#123;userObj.username&#125; 使用这个语法的前提是：User对象有getUsername()方法。</span><br><span class="line">$&#123;userObj.password&#125; 使用这个语法的前提是：User对象有getPassword()方法。</span><br><span class="line">$&#123;userObj.age&#125; 使用这个语法的前提是：User对象有getAge()方法。</span><br><span class="line">$&#123;userObj.email&#125; 使用这个语法的前提是：User对象有getEmail()方法。</span><br><span class="line">EL表达式中的. 这个语法，实际上调用了底层的getXxx()方法。</span><br><span class="line">注意：如果没有对应的get方法，则出现异常。报<span class="number">500</span>错误。</span><br><span class="line"></span><br><span class="line">$&#123;userObj.addr222.zipcode&#125;</span><br><span class="line">以上EL表达式对应的java代码：</span><br><span class="line">user.getAddr222().getZipcode()</span><br></pre></td></tr></table></figure><ul><li><p>EL表达式优先从小范围中读取数据。</p><ul><li>pageContext &lt; request &lt; session &lt; application</li></ul></li><li><p>EL表达式中有四个隐含的隐式的范围：</p><ul><li>pageScope 对应的是 pageContext范围。</li><li>requestScope 对应的是 request范围。</li><li>sessionScope 对应的是 session范围。</li><li>applicationScope 对应的是 application范围。</li></ul></li><li><p>EL表达式对null进行了预处理。如果是null，则向浏览器输出一个空字符串。</p></li><li><p>EL表达式取数据的时候有两种形式：</p><ul><li>第一种：. （大部分使用这种方式）</li><li>第二种：[ ] （如果存储到域的时候，这个name中含有特殊字符，可以使用 []）<ul><li>request.setAttribute(“abc.def”, “zhangsan”);</li><li>${requestScope.abc.def} 这样是无法取值的。</li><li>应该这样：${requestScope[“abc.def”]}</li></ul></li></ul></li><li><p>掌握使用EL表达式，怎么从Map集合中取数据：</p><ul><li>${map.key}</li></ul></li><li><p>掌握使用EL表达式，怎么从数组和List集合中取数据：</p><ul><li>${数组[0]}</li><li>${数组[1]}</li><li>${list[0]}</li></ul></li><li><p>page指令当中，有一个属性，可以忽略EL表达式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;true&quot; %&gt;</span><br><span class="line">isELIgnored=&quot;true&quot; 表示忽略EL表达式</span><br><span class="line">isELIgnored=&quot;false&quot; 表示不忽略EL表达式。（这是默认值）</span><br><span class="line"></span><br><span class="line">isELIgnored=&quot;true&quot; 这个是全局的控制。</span><br><span class="line"></span><br><span class="line">可以使用反斜杠进行局部控制：\$&#123;username&#125; 这样也可以忽略EL表达式。</span><br></pre></td></tr></table></figure><ul><li><p>通过EL表达式获取应用的根：</p><ul><li>${pageContext.request.contextPath}</li></ul></li><li><p>EL表达式中其他的隐式对象：</p><ul><li>pageContext</li><li>param</li><li>paramValues</li><li>initParam</li></ul></li><li><p>EL表达式的运算符</p><ul><li>算术运算符<ul><li>+、-、*、/、%</li></ul></li><li>关系运算符<ul class="task-list"><li><label><input type="checkbox" />== eq != &gt; &gt;= &lt;&lt;=</label></li></ul></li><li>逻辑运算符<ul class="task-list"><li><label><input type="checkbox" />! &amp;&amp; || not andor</label></li></ul></li><li>条件运算符<ul class="task-list"><li><label><input type="checkbox" />? :</label></li></ul></li><li>取值运算符<ul><li>[ ]和.</li></ul></li><li>empty运算符<ul class="task-list"><li><label><inputtype="checkbox" />empty运算符的结果是boolean类型</label></li><li><label><input type="checkbox" />${empty param.username}</label></li><li><label><input type="checkbox" />${not emptyparam.username}</label></li><li><label><input type="checkbox" />${!emptyparam.password}</label></li></ul></li></ul></li></ul><h1 id="jstl标签库">JSTL标签库</h1><ul><li><p>什么是JSTL标签库？</p><ul><li>Java Standard Tag Lib（Java标准的标签库）</li><li>JSTL标签库通常结合EL表达式一起使用。目的是让JSP中的java代码消失。</li><li>标签是写在JSP当中的，但实际上最终还是要执行对应的java程序。（java程序在jar包当中。）</li></ul></li><li><p>使用JSTL标签库的步骤：</p><ul><li><p>第一步：引入JSTL标签库对应的jar包。</p><ul><li>tomcat10之后引入的jar包是：<ul><li>jakarta.servlet.jsp.jstl-2.0.0.jar</li><li>jakarta.servlet.jsp.jstl-api-2.0.0.jar</li></ul></li><li>在IDEA当中怎么引入？<ul><li>在WEB-INF下新建lib目录，然后将jar包拷贝到lib当中。然后将其“AddLib…”</li><li>一定是要和mysql的数据库驱动一样，都是放在WEB-INF/lib目录下的。</li><li>什么时候需要将jar包放到WEB-INF/lib目录下？如果这个jar是tomcat服务器没有的。</li></ul></li></ul></li><li><p>第二步：在JSP中引入要使用标签库。（使用taglib指令引入标签库。）</p><ul><li>JSTL提供了很多种标签，你要引入哪个标签？？？？重点掌握核心标签库。</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">这个就是核心标签库。</span><br><span class="line">prefix=&quot;这里随便起一个名字就行了，核心标签库，大家默认的叫做c，你随意。&quot;</span><br></pre></td></tr></table></figure><ul><li><p>第三步：在需要使用标签的位置使用即可。表面使用的是标签，底层实际上还是java程序。</p></li><li><p>JSTL标签的原理</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">以上uri后面的路径实际上指向了一个xxx.tld文件。</span><br><span class="line">tld文件实际上是一个xml配置文件。</span><br><span class="line">在tld文件中描述了“标签”和“java类”之间的关系。</span><br><span class="line">以上核心标签库对应的tld文件是：c.tld文件。它在哪里。</span><br><span class="line">在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下，有一个c.tld文件。</span><br></pre></td></tr></table></figure><ul><li>源码解析：配置文件tld解析</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;</span><br><span class="line">    &lt;description&gt;对该标签的描述&lt;/description&gt;</span><br><span class="line">    &lt;name&gt;catch&lt;/name&gt; 标签的名字</span><br><span class="line">    &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt; 标签对应的java类。</span><br><span class="line">    &lt;body-content&gt;JSP&lt;/body-content&gt; 标签体当中可以出现的内容，如果是JSP，就表示标签体中可以出现符合JSP所有语法的代码。例如EL表达式。</span><br><span class="line">    &lt;attribute&gt;</span><br><span class="line">        &lt;description&gt;</span><br><span class="line">        对这个属性的描述</span><br><span class="line">        &lt;/description&gt;</span><br><span class="line">        &lt;name&gt;var&lt;/name&gt; 属性名</span><br><span class="line">        &lt;required&gt;false&lt;/required&gt; false表示该属性不是必须的。true表示该属性是必须的。</span><br><span class="line">        &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; 这个描述说明了该属性是否支持EL表达式。false表示不支持。true表示支持EL表达式。</span><br><span class="line">    &lt;/attribute&gt;</span><br><span class="line">  &lt;/tag&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:catch var=&quot;&quot;&gt;</span><br><span class="line">JSP....</span><br><span class="line">&lt;/c:catch&gt;</span><br></pre></td></tr></table></figure><ul><li><p>jstl中的核心标签库core当中有哪些常用的标签呢？</p><ul><li><p>c:if</p><ul><li><c:if test="boolean类型，支持EL表达式">&lt;/c: if&gt;</li></ul></li><li><p>c:forEach</p><ul><li><c:forEach items="集合，支持EL表达式" var="集合中的元素" varStatus="元素状态对象">${元素状态对象.count} &lt;/c: forEach&gt;</li><li><c:forEach var="i" begin="1" end="10" step="2"> ${i} &lt;/c:forEach&gt;</li></ul></li><li><p>c:choose c:when c:otherwise</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=&quot;$&#123;param.age &lt; 18&#125;&quot;&gt;</span><br><span class="line">        青少年</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=&quot;$&#123;param.age &lt; 35&#125;&quot;&gt;</span><br><span class="line">        青年</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=&quot;$&#123;param.age &lt; 55&#125;&quot;&gt;</span><br><span class="line">        中年</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        老年</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><h2 id="改造oa">改造OA</h2><ul><li><p>使用什么技术改造呢？</p><ul><li>Servlet + JSP + EL表达式 + JSTL标签。进行改造。</li></ul></li><li><p>在前端HTML代码中，有一个标签，叫做base标签，这个标签可以设置整个网页的基础路径。</p><ul><li><p>这是Java的语法，也不是JSP的语法。是HTML中的一个语法。HTML中的一个标签。通常出现在head标签中。</p></li><li><p>&lt; base href=“http://localhost:8080/oa/”&gt;</p></li><li><p>在当前页面中，凡是路径没有以“/”开始的，都会自动将base中的路径添加到这些路径之前。</p><ul><li>&lt; a href=“ab/def”&gt;&lt;/ a&gt;</li><li>等同于：&lt; a href=“http://localhost:8080/oa/ab/def”&gt;&lt;/a&gt;</li></ul></li><li><p>需要注意：在JS代码中的路径，保险起见，最好不要依赖base标签。JS代码中的路径最好写上全路径。</p></li></ul></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href=<span class="string">&quot;$&#123;pageContext.request.scheme&#125;://$&#123;pageContext.request.serverName&#125;:$&#123;pageContext.request.serverPort&#125;$&#123;pageContext.request.contextPath&#125;/&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="filter过滤器">Filter过滤器</h1><ul><li><p>当前的OA项目存在什么缺陷？</p><ul><li>DeptServlet、EmpServlet、OrderServlet。每一个Servlet都是处理自己相关的业务。在这些Servlet执行之前都是需要判断用户是否登录了。如果用户登录了，可以继续操作，如果没有登录，需要用户登录。这段判断用户是否登录的代码是固定的，并且在每一个Servlet类当中都需要编写，显然代码没有得到重复利用。包括每一个Servlet都要解决中文乱码问题，也有公共的代码。这些代码目前都是重复编写，并没有达到复用。怎么解决这个问题?<ul><li>可以使用Servlet规范中的Filter过滤器来解决这个问题。</li></ul></li></ul></li><li><p>Filter是什么，有什么用，执行原理是什么？</p><ul><li>Filter是过滤器。</li><li>Filter可以在Servlet这个目标程序执行之前添加代码。也可以在目标Servlet执行之后添加代码。之前之后都可以添加过滤规则。</li><li>一般情况下，都是在过滤器当中编写公共代码。</li></ul></li><li><p>一个过滤器怎么写呢？</p><ul><li><p>第一步：编写一个Java类实现一个接口：jarkata.servlet.Filter。并且实现这个接口当中所有的方法。</p><ul><li>init方法：在Filter对象第一次被创建之后调用，并且只调用一次。</li><li>doFilter方法：只要用户发送一次请求，则执行一次。发送N次请求，则执行N次。在这个方法中编写过滤规则。</li><li>destroy方法：在Filter对象被释放/销毁之前调用，并且只调用一次。</li></ul></li><li><p>第二步：在web.xml文件中对Filter进行配置。这个配置和Servlet很像。</p></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.Filter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">或者使用注解：@WebFilter(&#123;&quot;*.do&quot;&#125;)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><ul><li>Servlet对象默认情况下，在服务器启动的时候是不会新建对象的。</li><li>Filter对象默认情况下，在服务器启动的时候会新建对象。</li><li>Servlet是单例的。Filter也是单例的。（单实例。）</li></ul></li><li><p>目标Servlet是否执行，取决于两个条件：</p><ul><li>第一：在过滤器当中是否编写了：chain.doFilter(request, response);代码。</li><li>第二：用户发送的请求路径是否和Servlet的请求路径一致。</li></ul></li><li><p>chain.doFilter(request, response); 这行代码的作用：</p><ul><li>执行下一个过滤器，如果下面没有过滤器了，执行最终的Servlet。</li></ul></li><li><p>注意：Filter的优先级，天生的就比Servlet优先级高。</p><ul><li>/a.do对应一个Filter，也对应一个Servlet。那么一定是先执行Filter，然后再执行Servlet。</li></ul></li><li><p>关于Filter的配置路径：</p><ul><li>/a.do、/b.do、/dept/save。这些配置方式都是精确匹配。</li><li>/* 匹配所有路径。</li><li>*.do 后缀匹配。不要以 / 开始</li><li>/dept/* 前缀匹配。</li></ul></li><li><p>在web.xml文件中进行配置的时候，Filter的执行顺序是什么？</p><ul><li>依靠filter-mapping标签的配置位置，越靠上优先级越高。</li></ul></li><li><p>过滤器的调用顺序，遵循栈数据结构。</p></li><li><p>使用@WebFilter的时候，Filter的执行顺序是怎样的呢？</p><ul><li>执行顺序是：比较Filter这个类名。</li><li>比如：FilterA和FilterB，则先执行FilterA。</li><li>比如：Filter1和Filter2，则先执行Filter1.</li></ul></li><li><p>Filter的生命周期？</p><ul><li>和Servlet对象生命周期一致。</li><li>唯一的区别：Filter默认情况下，在服务器启动阶段就实例化。Servlet不会。</li></ul></li><li><p>Filter过滤器这里有一个设计模式：</p><ul><li>责任链设计模式。</li><li>过滤器最大的优点：<ul><li>在程序编译阶段不会确定调用顺序。因为Filter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中filter-mapping的顺序就可以调整Filter的执行顺序。显然Filter的执行顺序是在程序运行阶段动态组合的。那么这种设计模式被称为责任链设计模式。</li></ul></li><li>责任链设计模式最大的核心思想：<ul><li>在程序运行阶段，动态的组合程序的调用顺序。</li></ul></li></ul></li><li><p>使用过滤器改造OA项目。</p></li></ul><h1 id="listener监听器">Listener监听器</h1><ul><li><p>什么是监听器？</p><ul><li>监听器是Servlet规范中的一员。就像Filter一样。Filter也是Servlet规范中的一员。</li><li>在Servlet中，所有的监听器接口都是以“Listener”结尾。</li></ul></li><li><p>监听器有什么用？</p><ul><li>监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机。</li><li>特殊的时刻如果想执行这段代码，你需要想到使用对应的监听器。</li></ul></li><li><p>Servlet规范中提供了哪些监听器？</p><ul><li>jakarta.servlet包下：<ul><li>ServletContextListener</li><li>ServletContextAttributeListener</li><li>ServletRequestListener</li><li>ServletRequestAttributeListener</li></ul></li><li>jakarta.servlet.http包下：<ul><li>HttpSessionListener</li><li>HttpSessionAttributeListener<ul><li>该监听器需要使用@WebListener注解进行标注。</li><li>该监听器监听的是什么？是session域中数据的变化。只要数据变化，则执行相应的方法。主要监测点在session域对象上。</li></ul></li><li>HttpSessionBindingListener<ul><li>该监听器不需要使用@WebListener进行标注。</li><li>假设User类实现了该监听器，那么User对象在被放入session的时候触发bind事件，User对象从session中删除的时候，触发unbind事件。</li><li>假设Customer类没有实现该监听器，那么Customer对象放入session或者从session删除的时候，不会触发bind和unbind事件。</li></ul></li><li>HttpSessionIdListener<ul><li>session的id发生改变的时候，监听器中的唯一一个方法就会被调用。</li></ul></li><li>HttpSessionActivationListener<ul><li>监听session对象的钝化和活化的。</li><li>钝化：session对象从内存存储到硬盘文件。</li><li>活化：从硬盘文件把session恢复到内存。</li></ul></li></ul></li></ul></li><li><p>实现一个监听器的步骤：以ServletContextListener为例。</p><ul><li>第一步：编写一个类实现ServletContextListener接口。并且实现里面的方法。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent event)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent event)</span>;</span><br></pre></td></tr></table></figure><ul><li>第二步：在web.xml文件中对ServletContextListener进行配置，如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.bjpowernode.javaweb.listener.MyServletContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>当然，第二步也可以不使用配置文件，也可以用注解，例如：<spanclass="citation" data-cites="WebListener">@WebListener</span></p></li><li><p>注意：所有监听器中的方法都是不需要javaweb程序员调用的，由服务器来负责调用？什么时候被调用呢？</p><ul><li>当某个特殊的事件发生（特殊的事件发生其实就是某个时机到了。）之后，被web服务器自动调用。</li></ul></li><li><p>思考一个业务场景：</p><ul><li>请编写一个功能，记录该网站实时的在线用户的个数。</li><li>我们可以通过服务器端有没有分配session对象，因为一个session代表了一个用户。有一个session就代表有一个用户。如果你采用这种逻辑去实现的话，session有多少个，在线用户就有多少个。这种方式的话：HttpSessionListener够用了。session对象只要新建，则count++，然后将count存储到ServletContext域当中，在页面展示在线人数即可。</li><li>业务发生改变了，只统计登录的用户的在线数量，这个该怎么办？<ul><li>session.setAttribute(“user”, userObj);</li><li>用户登录的标志是什么？session中曾经存储过User类型的对象。那么这个时候可以让User类型的对象实现HttpSessionBindingListener监听器，只要User类型对象存储到session域中，则count++，然后将count++存储到ServletContext对象中。页面展示在线人数即可。</li></ul></li></ul></li><li><p>实现oa项目中当前登录在线的人数。</p><ul><li>什么代表着用户登录了？<ul><li>session.setAttribute(“user”, userObj);User类型的对象只要往session中存储过，表示有新用户登录。</li></ul></li><li>什么代表着用户退出了？<ul><li>session.removeAttribute(“user”);User类型的对象从session域中移除了。</li><li>或者有可能是session销毁了。（session超时）</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【debug】VMware运行虚拟机报错</title>
      <link href="/posts/40097.html"/>
      <url>/posts/40097.html</url>
      
        <content type="html"><![CDATA[<h4 id="出现的问题">出现的问题</h4><p>​ 在今天安装Ubuntu系统后，运行虚拟机时出现“VMware Workstation 未能启动VMwareAuthorization Service。您可以尝试手动启动VMware AuthorizationService。如果此问题仍然存在，请联系 VMware 支持部门。”的错误信息。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202303102150078.png"alt="image-20230310215046744" /><figcaption aria-hidden="true">image-20230310215046744</figcaption></figure><h4 id="分析问题解决问题">分析问题&amp;解决问题</h4><p>去服务查看有无”VMAuthdService”这个服务</p><ul><li>有，应该是被禁用了。右键该服务-属性，将启动类型改为”自动“即可</li><li>无，管理员运行cmd命令<code>sc create VMAuthdService binpath= "D:\VMware\vmware-authd.exe"</code>（其中<code>D:\VMware</code>为你的VMware所在目录）</li></ul>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】操作系统知识点整理</title>
      <link href="/posts/39774.html"/>
      <url>/posts/39774.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-概述">第一章 概述</h2><h3 id="第一节-操作系统的特征">第一节 操作系统的特征</h3><p>一、并发（最基本）</p><p>注意（重要考点）：</p><p>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行</p><p>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</p><p>很多人搞不清楚并发和并行的区别？</p><p>并发：多个事件在同一时刻内发生，操作系统并发性是指同时存在多个运行的程序。在宏观上是一起发生，但在微观上是交替执行的。</p><p>并行：同一时间内多个事件同时发生，宏观上，微观上都是都是发生的。</p><p>二、共享（最基本）</p><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><ul><li>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问。</li><li>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</li></ul><p>三、虚拟</p><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><p><em>把你内存“变大了”，实际上没变大，但在感觉上变大了</em></p><p>四、异步</p><p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><h3 id="第二节-操作系统的发展">第二节 操作系统的发展</h3><p>一、手工操作阶段（此阶段无操作系统）</p><p>缺点：独占全集。速度极慢。CPU利用不充分。</p><p>二、批处理阶段</p><p>Ⅰ、单道批处理系统</p><p>主要优点：缓解了一定程度的人机速度矛盾资源利用率有所提升。</p><p>主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。</p><p>Ⅱ、多道批处理系统</p><p>主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。</p><p>主要缺点：没有人机交互。</p><p>三、分时操作系统</p><p>分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</p><p>主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p>主要缺点：不能优先处理一些紧急任务。操作系统对各个用户作业都是完全公平的，循环地为每个用户作业服务一个时间片，不区分任务的紧急性。</p><p>四、实时操作系统</p><p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p><ul><li>系统调用时操作系统为应用程序使用内核功能锁提供的结构。</li></ul><h3 id="第三节-操作系统运行机制">第三节 操作系统运行机制</h3><p>一、内核态和用户态</p><p>CPU有两种状态，“内核态”和“用户态”</p><ul><li>处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</li><li>处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</li></ul><p>CPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序还是应用程序？</p><p>CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示“内核态”，0表示“用户态”。</p><ul><li>访管指令：只能是用户态使用，作用是将用户态转变为核心态</li><li>处于核心态时，可以执行除访管指令的所有指令</li><li>广义指令是指系统调用指令，可以由<strong>用户态调用</strong>，但只能由<strong>核心态运行</strong></li><li>输入/输出指令<strong>涉及到中断</strong>，所以必须在核心态</li><li>计算机通过<strong>硬件</strong>完成操作系统由用户态到核心态的转换，这是通过中断机制来实现的</li></ul><figure><imgsrc="https://pic2.zhimg.com/80/v2-e029e3a21af986f7ebad65b6853e6dcd_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>二、中断</p><p>Ⅰ、中断类型</p><p>中断：也称外中断，是指来自CPU外部的事件。很典型的是一个时钟中断（并发运行的基础），表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。</p><p>异常：也称内终端，是指来自CPU内部的事件。如程序的非法操作码、地址越界、运算溢出等，异常不能被屏蔽，一旦出现就应该立即处理。</p><p>如何处理中断？</p><p>不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。</p><ul><li>在中断相关操作中，保存被中断的断点/PC里面的内容是由硬件自动完成的。</li></ul><p>三、系统调用</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-db6773114fe01f5204f23af5f45f93cc_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>传递系统调用参数→执行陷入指令（用户态）→执行相应的内请求核程序处理系统调用（核心态）→返回应用程序</p><ul><li>陷入指令/trap指令/访管指令是在<strong>用户态执行</strong>的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态。</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。</li></ul><h3 id="第四节-操作系统的结构">第四节 操作系统的结构</h3><p>一、操作系统的结构（新增考点分层，模块化，外核）</p><table><colgroup><col style="width: 8%" /><col style="width: 44%" /><col style="width: 47%" /></colgroup><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分层结构</td><td>易于调试和验证 易扩充和易维护</td><td>仅可调用相邻层 效率低，不可跨层调用</td></tr><tr><td>模块化</td><td>易于维护，逻辑清晰 各模块之间直接调用</td><td>难以调式和验证</td></tr><tr><td>大内核</td><td>性能高，内核个功能直接调用</td><td>复杂，难以维护，一个功能坏全部瘫痪（可靠性低）</td></tr><tr><td>微内核</td><td>功能少，易于维护 某个出错不会导致整个崩溃</td><td>性能低，需要频繁切换状态</td></tr><tr><td>外核</td><td>更灵活使用硬件资源 减少资源的映射层提升效率</td><td>使系统更加复杂 降低系统的一致性</td></tr></tbody></table><p>二、操作系统的加载</p><p>①CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序（先进行硬件自检，再开机）。</p><p>②将磁盘的第一块一一主引导记录读入内存，执行磁盘引导程序，扫描分区表。</p><p>③从活动分区（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序。</p><p>④从根目录下找到完整的操作系统初始化程序（即启动管理器）并执行，完成“开机”的一系列动作。</p><p>三、虚拟机</p><figure><imgsrc="https://pic3.zhimg.com/80/v2-f591373878e34e9499c3965716ded2ae_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="第二章-进程与线程">第二章 进程与线程</h2><h3 id="第一节-进程">第一节 进程</h3><p>一、进程的概念</p><p>背景：为了实现操作系统的并发性和共享性，以便更好的描述和控制程序的并发执行，由此引入了进程的概念。</p><p>进程实体（进程映像）由三部分组成：程序段、数据段、PCB（进程控制块）组成。PCB是进程存在的唯一标志。PCB是给操作系统用的，而程序段和数据段是给进程自己使用的。</p><p>※进程映像是静态的，而进程则是动态的</p><ul><li>学习技巧：进程控制会导致进程状态的转换。无论哪个进程控制原语，要做的无非三类事情：</li></ul><p>1.更新PCB中的信息</p><p>a.所有的进程控制原语·定都会修改进程状态标志</p><p>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境</p><p>c.某进程丌始运行前必然要恢复期运行环境</p><p>2.将PCB插入合适的队列</p><p>3.分配/回收资源</p><p>二、进程的状态</p><figure><imgsrc="https://pic3.zhimg.com/80/v2-d664515f7d53211a6d253e87e043b2be_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>从运行态转变为就绪态有两种情况——时间片用完，有优先级更高级的进程需要运行。</li><li>只有运行态到阻塞态的转换是由进程自身决定的。</li></ul><p>三、进程间的通信</p><p>为什么进程通信需要有操作系统的支持？</p><p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p><p>Ⅰ、共享存储</p><p>设置一个共享内存区域，并映射到进程的虚拟地址空间，要互斥的访问共享空间，有基于数据结构（低级）和基于存储区的共享（高级）</p><p>Ⅱ、消息传递</p><p>传递结构化的消息，系统提供“发送/接受原语”，两种方式，直接通信方式和间接通信方式</p><p>直接通信方式是将消息直接挂到接受进程的消息队列里。</p><p>间接通信方式是将消息先发送到中间体。</p><p>Ⅲ、管道通信</p><p>设置一个管道，其实就是一个内存缓冲区，一个管道只能实现半双工通信，实现双向同时通信要建立两个管道，各各进程之间要互斥访问。</p><p>一个管道只能有<strong>一个读进程</strong>，但能有<strong>多个写进程</strong>。当管道为空时，读进程阻塞；当管道不为空时，写进程阻塞。</p><h3 id="第二节-线程">第二节 线程</h3><p>背景：有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件)</p><table><colgroup><col style="width: 21%" /><col style="width: 50%" /><col style="width: 28%" /></colgroup><thead><tr><th></th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源</td><td>资源分配的基本单位哦</td><td>资源调度的基本单位</td></tr><tr><td>并发性</td><td>只能进程间并发</td><td>进程内也可以并发</td></tr><tr><td>系统开销</td><td>开销大</td><td>开销小</td></tr><tr><td>地址空间和资源</td><td>每个进程之间独立的地址空间和资源</td><td>共享地址空间和资源</td></tr></tbody></table><p>Ⅰ、用户级线程</p><p>1.线程的管理工作由准来完成？</p><p>2.线程切换是否需要CPU变态？</p><p>3.操作系统是否能意识到用户级线程的存在？</p><p>4.这种线程的实现方式有什么优点和缺点？</p><p>1.用户级线程由<strong>应用程序</strong>通过线程库实现，所有的线程管理工作都由<strong>应用程序负责</strong>（包括线程切换)。</p><p>2.用户级线程中，线程切换可以在<strong>用户态</strong>下即可完成，<strong>无需操作系统干预</strong>。</p><p>3.在<strong>用户</strong>看来，是有<strong>多个线程</strong>。但是在<strong>操作系统内核</strong>看来，并意识<strong>不到线程的存在</strong>。“用户级线程”就是“从用户视角看能看到的线程”。</p><p>4.优缺点</p><p>优点：用户级线程的切换在用户空问即可完成，<strong>不需要切换到核心态</strong>，线程管理的系统<strong>开销小，效率高。</strong></p><p>缺点：当<strong>一个用户级线程被阻塞后，整个进程都会被阻塞</strong>，并发度不高。多个线程不可在多核处理机上并行运行。</p><p>Ⅱ、内核级线程</p><p>1.内核级线程的管理工作由<strong>操作系统内核</strong>完成。</p><p>2.线程调度、切换等工作都由内核负贵，因此<strong>内核级线程</strong>的切换必然需要在<strong>核心态</strong>下才能完成。</p><p>3.操作系统会为每个内核级线程建立相应的TCB(Thread ControlBlock,线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”。</p><p>4.优缺点</p><p>优点：当个线程被<strong>阻塞后，别的线程还可以继续执行，并发能力强</strong>。多线程可在多核处理机上并行执行。</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的<strong>成本高</strong>，<strong>开销大</strong>。</p><p>Ⅲ、多线程模型</p><table><colgroup><col style="width: 2%" /><col style="width: 37%" /><col style="width: 33%" /><col style="width: 26%" /></colgroup><thead><tr><th></th><th>一对一</th><th>多对一</th><th>多对多</th></tr></thead><tbody><tr><td>内容</td><td>将每个用户级线程映射到一个内核级线程</td><td>多个用户级线程映射到一个内核级线程</td><td>多个用户级线程映射到多个内核级线程上</td></tr><tr><td>优点</td><td>当一个线程被阻塞后，允许调度另一个线程运行，并发能力强</td><td>线程管理是在用户空间上进行的，效率比较高</td><td>克服多对一的缺点，有客服一对一开销大的缺点</td></tr><tr><td>缺点</td><td>每创建一个用户级线程，相应就需要创建一个内核级线程，开销大</td><td>如果一个线程阻塞，则都会发送阻塞，只允许一个线程运行</td><td>/</td></tr></tbody></table><figure><imgsrc="https://pic1.zhimg.com/80/v2-5856dbf67d07d3c90ed32dade81a8898_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="第三节-处理机调度">第三节 处理机调度</h3><p>一、调度的分类</p><p>Ⅰ、高级调度（作业调度）：从后备队列中调入一个作业进入就绪队列中。</p><p>Ⅱ、中级调度（内存调度）：中级调度实际上是外存与内存之间的调度。把进程从外存调入。</p><p>Ⅲ、低级调度（进程调度）：从就绪队列中选取一个进程，然后使其由就绪态变为执行态。</p><p>二、</p><p>三、算法指标</p><figure><imgsrc="https://pic2.zhimg.com/80/v2-a51be549cf38db6f8a168d43782a4fc9_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>周转时间反映的是等待时间+运行时间。</li><li>带权周转时间越大，表明要等待的时间相对运行时间越长。所以不是越大越好，而是越小越好。</li></ul><p>四、调度算法</p><p>Ⅰ、先来先服务算法（FCFS）</p><ul><li><p><strong>算法思想</strong>：主要从“<strong>公平</strong>”的角度考虑(类似于我们生活中排队买东西的例子)，先请求 CPU 的进程首先分配到 CPU。当一个进程进入就绪队列时，它的 PCB会被链接到队列尾部。当 CPU空闲时，它会分配给位于队列头部的进程，并且这个运行进程从队列中移去。</p></li><li><p><strong>算法规则</strong>：按照作业/进程<strong>到达的先后顺序</strong>进行服务</p></li><li><p><strong>用于作业/进程调度</strong>：用于作业调度时，考虑的是哪个作业先到达<strong>后备队列</strong>；用于进程调度时，考虑的是哪个进程先到达<strong>就绪队列</strong></p></li><li><p><strong>是否可抢占?</strong>：非抢占式的算法，即一旦 CPU分配给了一个进程，该进程就会使用 CPU 直到释放 CPU为止，即程序终止或是请求 I/O。FCFS算法对于分时系统（每个用户需要定时得到一定的 CPU时间）是特别麻烦的。允许一个进程使用 CPU 过长将是个严重错误</p></li><li><p><strong>优缺点</strong></p></li><li><ul><li>优点：公平、算法实现简单</li><li>缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。</li><li><strong>是否会导致饥饿(某进程/作业长期得不到服务)</strong>：不会</li></ul></li></ul><p>Ⅱ、短作业优先调度算法（SJF）</p><ul><li><p><strong>算法思想</strong>：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p></li><li><p><strong>算法规则</strong>：按”最短的作业/进程优先得到服务(所谓“最短”，是指要求服务时间最短)</p></li><li><p><strong>用于作业/进程调度</strong>：即可用于作业调度，也可用于进程调度。用于进程调度时称为“<strong>短进程优先(SPF</strong>,Shortest Process First) 算法”</p></li><li><p><strong>是否可抢占?</strong>：SJF和SPF是非抢占式的算法。但是也有抢占式的版本–最短剩余时间优先算法(SRTN, Shortest Remaining Time Next )</p></li><li><p>最短剩余时间优先算法——每当有进程加入就绪队列改变时就需要调度，<strong>如果新到达的进程剩余时间【剩余运行时间】比当前运行的进程剩余时间更短，则由新进程抢占CPU，而当前运行进程重新回到就绪队列</strong>。<strong>另外，当一个进程完成时也需要根据该调度算法进行调度</strong></p></li><li><p><strong>优缺点</strong></p></li><li><ul><li>优点：“最短的”平均等待时间、平均周转时间。</li><li>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</li></ul></li><li><p><strong>是否会导致饥饿(某进程/作业长期得不到服务)</strong>：会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”<strong>现象。如果一直得不到服务，则称为“饿死”</strong></p></li></ul><p>Ⅲ、高响应比优先调度算法</p><ul><li><p><strong>算法思想</strong>：要综合考虑作业/进程的等待时间和要求服务的时间</p></li><li><p><strong>算法规则</strong>：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务【响应比&gt;=1】响应比等待时间要求服务时间要求服务时间响应比=等待时间+要求服务时间要求服务时间</p></li><li><p><strong>用于作业/进程调度</strong>：即可用于作业调度，也可用于进程调度。</p></li><li><p><strong>是否可抢占?</strong>：非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p></li><li><p><strong>优缺点</strong></p></li><li><ul><li>综合考虑了等待时间和运行时间(要求服务时间)</li><li>等待时间相同时，要求服务时间短的优先(SJF 的优点)</li><li>要求服务时间相同时，等待时间长的优先(FCFS 的优点)</li><li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li></ul></li><li><p><strong>是否会导致饥饿(某进程/作业长期得不到服务)</strong>：不会</p></li></ul><blockquote><p>这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。</p></blockquote><p>Ⅳ、优先级调度算法</p><ul><li><p><strong>算法思想</strong>：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</p></li><li><p><strong>算法规则</strong>：调度时选择优先级最高的作业/进程</p></li><li><p><strong>用于作业/进程调度</strong>：既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中</p></li><li><p><strong>是否可抢占?</strong>：抢占式、非抢占式都有。做题时的区别在于:非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</p></li><li><p><strong>优缺点</strong></p></li><li><ul><li>优点:用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li><li>缺点:若源源不断地有高优先级进程到来，则可能导致饥饿</li></ul></li><li><p><strong>是否会导致饥饿(某进程/作业长期得不到服务)</strong>：可能会导致饥饿。</p></li></ul><p><strong>非抢占式</strong>的优先级调度算法:每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</p><p><strong>抢占式</strong>的优先级调度算法:每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列发生改变时也需要检查是会发生抢占。</p><p>静态优先级：优先级是在创建进程时就已经确定了，且整个运行期间保持不变。</p><p>动态优先级：在进程运行过程中，根据进程的情况的变化动态调整优先级。</p><p>一般来说：系统进程&gt;用户进程；交互型&gt;非交互型；I/O型进程&gt;计算型进程。</p><p>Ⅴ、时间片轮转调度算法</p><ul><li><p><strong>算法思想</strong>：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p></li><li><p><strong>算法规则</strong>：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到<strong>就绪队列队尾</strong>重新排队。</p></li><li><p><strong>用于作业/进程调度</strong>：用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p></li><li><p><strong>是否可抢占?</strong>：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</p></li><li><p><strong>优缺点</strong></p></li><li><ul><li>优点：<strong>公平;响应快，适用于分时操作系统;</strong></li><li>缺点：缺点:由于高频率的进程切换，因此有一定开销;不区分任务的紧急程度。</li></ul></li><li><p><strong>是否会导致饥饿(某进程/作业长期得不到服务)</strong>：不会。</p></li></ul><p>（常考）时间片太长或太短会有什么影响？</p><p>如果时间片<strong>太大</strong>，使得每个进程都可以在一个时间片内就完成，则<strong>时间片轮转调度算法退化为先来先服务调度算法</strong>，<strong>并且会增大进程响应时间</strong>。</p><p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片<strong>太小</strong>，会导致进程切换过于频繁，<strong>系统会花大量的时间来处理进程切换</strong>，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><p>Ⅵ、多级反馈队列调度算法（最好的算法）</p><p>综合以上的调度算法的优点</p><ul><li>FCFS算法的优点是公平</li><li>SJF算法的优点是能尽快处理完短作业，平均等待/周转时间等参数很优秀</li><li>时间片轮转调度算法可以让各个进程得到及时的响应</li><li>优先级调度算法可以灵活地调整各种进程被服务的机会</li></ul><figure><imgsrc="https://pic2.zhimg.com/80/v2-fd2f6f51daa45a60e7a5c59a35662101_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="题型总结">题型总结：</h3><h3 id="第四节-同步与互斥">第四节 同步与互斥</h3><p>一、同步与互斥概念</p><p>Ⅰ、同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><p>例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。</p><p>Ⅱ、互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待,当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p><p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时,系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。</p><p>Ⅲ、两个进程同时进入临界区，同步机制应遵循以下准则：</p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ul><p>二、实现临界互斥的基本方法</p><p>Ⅰ、软件实现方法</p><p>①单标志法</p><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。turn的背后逻辑是表示谦让。</p><p>问题：算法的目的是让对方互相访问，假如对方不想占用临界资源，则会导致临界资源空闲。<strong>违背了“空闲让进”</strong>。</p><p>②双标志法先检查</p><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0]=ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为tue,之后开始访问临界区。flag背后逻辑是表示意愿。</p><p>问题：可能会同时进入临界区（违背“忙则等待”)。即在检查对方flag之后和切换自己flag之前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行。</p><p>③双标志法后检查</p><p>算法思想：双标志先检查法的改版。前·个算法的问题是先“检查”后“上锁”，但是这两个操作又无法气阿成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p><p>问题：当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值flag设置为TRUE，并且同时检测对方的状态（执行while语句），发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。违反“空闲让进”和“忙则等待”。</p><p>④皮特森算法</p><p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一·个有礼貌的进程。</p><blockquote><p>bool flag[2]; //表意愿 int turn =0; //表谦让 P0进程：<strong>flag[0]=true; //表示意愿，自己想进入临界资源</strong><strong>turn =1; //</strong>表示谦让，让对方先进入临界资源 <strong>while(flag [1]&amp;turn==1);//能循环的条件是1.对方想进入2.对方表示不想谦让，二者都要满足，才能循环</strong>critical section; flag[0]=false; remainder section; P1进程：<strong>flag[1]=true;</strong> <strong>turn =0;</strong> <strong>while(flag [0]&amp;turn==0);</strong> critical section; flag[1]=false;remainder section;</p></blockquote><p>Ⅱ、硬件实现方法</p><p>①中断屏蔽法</p><p>优点：简单、高效</p><p>缺点：</p><p>将屏蔽中断权力交给用户进程可能会对整个系统造成意想不到的影响。</p><p>屏蔽中断只会对<strong>当前占用的CPU有效</strong>，其他CPU会继续运行，因此不适合多处理器系统。</p><p>②硬件指令法</p><p>old记录是否已被上锁；再将lock设为true;检查临界区是否已被上锁(若已上锁，则循环重复前几步)</p><p>优点：实现简单，适合多处理机。</p><p>缺点：不满足让权等待，从而导致饥饿现象。</p><h3 id="第五节-信号量机制">第五节 信号量机制</h3><p>信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语wait(S)和signal(S)来访问，也可以记为“P操作”（通过）和“V操作（释放）”。原语是指完成某种功能且不被分割不被中断执行的操作序列，通常可由硬件来实现完成不被分割执行特性的功能。</p><p>一、整型信号量</p><p>用一个整型信号量表示一个资源数，但只要信号量为S ≤0，则会一直不断测试，违反了“让权等待”。</p><blockquote><p>wait(S){ while(S&lt;=0); S=S-1; } signal(S){ S=S+1; }</p></blockquote><p>二、记录型信号量(绝对的重点)</p><p>记录型信号量是不存在“忙等”现象的进程同步机制。（设置了阻塞队列解决忙等）除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程，记录型信号量是由于釆用了记录型的数据结构得名。</p><blockquote><p>typedef struct{ int value; struct process *L; } semaphore;</p></blockquote><ul><li>wait操作，S.value–，表示进程请求一个该类资源，当S.value&lt;0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到该类资源的等待队列S.L中，可见该机制遵循了“让权等待”的准则。</li></ul><blockquote><p>void wait(semaphore S) //相当于申请资源 S.value –; if (S.value&lt;0){ add this process to S.L; block(S.L); } }</p></blockquote><ul><li>signal操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，故S.value++。若加1后仍是S.value&lt;=0，则表示在S.L中仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.L中的第一个等待进程唤醒。</li></ul><blockquote><p>void signal(semaphore S) //相当于释放资源 S.value ++; if (S.value&lt;=0){ remove a process P from S.L; wakeup(P); } }</p></blockquote><p>什么时候执行block和wakeup？</p><p>申请资源时，当value<strong>小于0</strong>时，就会执行block，让其进入阻塞队列中。当一个进程执行完，若value还是<strong>小于等于0</strong>，则会执行wakeup操作。</p><p>三、实现同步，互斥，前驱关系</p><p>Ⅰ、实现同步</p><p>在“前操作”之后执行V(S)</p><p>在“后操作”之前执行P(S)</p><p>Ⅱ、实现互斥</p><p>信号量机构也能很方便地解决进程互斥问题。设S为实现进程Pl、P2互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值应为1（即可用资源数为1)。只需把临界区置于P(S)和V(S)之间，即可实现两进程对临界资源的互斥访问。</p><p>实现互斥（mutex）的P操作一定要在实现同步（empty）的P操作之后。否则就会导致”死锁“现象。而V操作的顺序颠倒没有影响。</p><p>三、经典同步问题</p><p>Ⅰ、生产者-消费者问题（最常考）</p><ul><li>互斥：在任一时间只能有一个线程操作缓冲区（缓冲区时临界资源）</li><li>当缓冲区为空，消费者必须等待生产者（调度/同步约束）</li><li>当缓冲区为满，生产者必须等待消费者（调度/同步约束）</li></ul><p>Ⅱ、读者-写者问题</p><p>读者写者问题是并发程序设计中的经典问题。问题描述为：对于同一个文件，读操作可以同时并行，读写操作互斥，写与写互斥。</p><p>Ⅲ、哲学家进餐问题</p><p>Ⅳ、吸烟者问题</p><p>四、管程</p><p>概念：<ahref="https://link.zhihu.com/?target=https%3A//so.csdn.net/so/search%3Fq%3D%E4%BF%A1%E5%8F%B7%E9%87%8F%26spm%3D1001.2101.3001.7020">信号量</a>机制存在的问题：编写程序困难、易出错。于是，产生了一种新的进程同步工具——管程。</p><p>组成：</p><p>共享数据结构</p><p>对数据结构初始化的语句</p><p>一组用来访问数据结构的过程（函数）</p><ul><li>各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据。</li></ul><p>这个”入口“其实就是指对该数据结构进行操作的一组过程（或函数）</p><ul><li>每次仅允许一个进程在管程内执行某个内部过程。</li></ul><h3 id="第六节-死锁">第六节 死锁</h3><p>一、死锁产生的条件</p><p>①互斥条件：资源是互斥使用的</p><p>②不剥夺条件：进程只能由自己释放</p><p>③请求和保持：已获得资源同时，还在请求另外一个资源</p><p>④循环等待：存在一个循环等待链</p><p>二、死锁预防——破坏死锁产生条件</p><table><colgroup><col style="width: 13%" /><col style="width: 43%" /><col style="width: 43%" /></colgroup><thead><tr><th></th><th>内容</th><th>缺点</th></tr></thead><tbody><tr><td>破坏互斥条件</td><td>将临界资源改造为可共享使用的资源（如SPOOLing技术）</td><td>可行性不高，很多时候无法破坏互斥条件</td></tr><tr><td>破坏不剥夺条件</td><td>方案一，申请的资源得不到满足时，立即释放拥有的所有资源方案二，申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级）</td><td>缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿</td></tr><tr><td>破坏请求和保持条件</td><td>运行前分配好所有需要的资源，之后一直保持</td><td>资源利用率低；可能导致饥饿</td></tr><tr><td>破坏循环等待条件</td><td>给资源编号，必须按编号从小到大的顺序申请资源（申请资源的顺序）</td><td>不方便增加新设备；会导致资源浪费；用户编程麻烦</td></tr></tbody></table><p>三、死锁避免</p><p>《银行家算法》</p><p>主要思想是避免系统进入不安全状态，在每次进行资源分配时，它首先检查系统是否由足够的资源满足要求，若有则先进行<strong>试分配</strong>，并对分配后的新状态进行安全性检查。若新状态安全，则<strong>正式分配上述资源</strong>，否则拒绝分配上述资源。</p><p>四、死锁检测和解除：</p><p>检测：利用资源分配图（资源有向图）来检测。</p><p>①资源剥夺：从死锁进程处抢夺资源。</p><p>②撤销进程法：强制撤销部分或全部死锁，并剥夺这些进程的资源。</p><p>③进程回退法：让进程回退到足以避免死锁的时候。</p><h2 id="第三章-内存管理">第三章 内存管理</h2><h3 id="第一节-概念">第一节 概念</h3><figure><imgsrc="https://pic1.zhimg.com/80/v2-76fa911eb0f2a542ee349615ca36275c_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>按字节编制就是每个存储单元为1字节，8bit</li><li>按字编制就是每个存储单位为1字，字的大小计算机的不同都不一样，现代计算机基本都为64bit</li></ul><p>从你在idea上编辑源代码文件时，点击“播放”按钮，即运行按钮，会发生以下几件事</p><ul><li>编译：把你写的代码文件生成目标模块，也就是机器语言，能让计算机“看得懂”</li><li>连接：把你写的各种文件给连接起来，即由目标模块生成为装入模块，也就是为装入内存做准备</li><li>装入：这个很简单了，就是将装入模块装入内存，形成物理地址</li></ul><p><strong>连接方式</strong></p><p>连接也分情况好吧</p><p>①静态连接：把所有文件在装入前，一股脑先全部连接起来，待到装入时，再一股脑全部丢进去。有人说了，我内存寸土寸金，你这一股脑丢进去，我有的目标模块用不到，你不给我浪费了吗！？是的。所以要改进。</p><p>②装入时动态连接：采用边装入边连接。就是在装入时连接。优点嘛就是便于修改和更新，便于实现对目标模块的共享。实则并未解决上面问题。</p><p>③运行时动态连接：需要运行目标模块才连接装入。凡是用不到，就不会调入内存和装入到模块上。优点是装入速度快，还可以节省大量的内存空间。</p><p><strong>装入方式</strong></p><p>连接分情况，转入也要分情况。多个目标模块的起始地址通常从0开始。这也就是所谓的逻辑地址。那装入分情况好吧，有点是直接一一对应，即逻辑地址对应物理地址那样装。不需要地址转换。即绝对装入。这个只适合早期的单道程序。</p><p>第二种就是可重定位装入（静态重定位）。给一个映射关系，但是这个映射关系不会改变，存储空间必须时连续的。假如装不下去，由于只能继续往下装，所以会导致内存不够。但是其他空间地址的内存有空间。灵活性较差。</p><p>第三种就是动态运行时装入（动态重定位）。映射关系可以改变，“内存哪里有空就往哪里钻”。可以将程序分配到不连续的存储区。现代操作系统多采用这种方式。</p><h3 id="第二节-内存分配">第二节 内存分配</h3><p>一、连续分配</p><p><strong>内部碎片</strong>就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；</p><p>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</p><p><strong>外部碎片</strong>指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</p><p>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。</p><p>Ⅰ、单一连续分配</p><p>这种分配方式下，内存被分成系统区和用户区。内存中只能有一道用户程序，用户程序独占整个用户空间。</p><p><strong>优点</strong>：实现简单，<strong>没有外部碎片</strong>（因为每次就给一个程序分配空间，当他运行完成，把空间释放，又还是一个完整的没有被分配的空间）。不一定需要内存保护（因为只有一个程序，不存在有其他程序越界访问的情况）</p><p><strong>缺点</strong>：只能用于单用户<strong>有内部碎片</strong>，存储空间的利用率很低（因为每次就一个程序在里面运行，会导致分配给他的空间有很多一部分他根本就用不上，因此会导致大量的内部碎片）</p><p>Ⅱ、固定分区分配</p><p>为了能让多个程序运行，并且让他们在运行的时候不会相互干扰，所以把用户空间分成多个固定大小的分区，每一个分区只存入一个作业。</p><p><strong>优点</strong>：实现简单，没有外部碎片（总会有一个分区可以放得下，所以不存在有很多很小的没有被分配的外部碎片）</p><p><strong>缺点</strong>：当用户程序太大的时候，会降低性能，并且会产生内部碎片（如果剩下一个较大的空间而分配给了一个小的进程，就会导致内部碎片）</p><p>Ⅲ、动态分区分配</p><p>会根据进程的大小来进行动态的分区分配，不预先划分内存分区，只是在进程装入内存的时候再建立分区。</p><p>动态分配策略会涉及一些分配算法：</p><table><colgroup><col style="width: 4%" /><col style="width: 22%" /><col style="width: 13%" /><col style="width: 26%" /><col style="width: 32%" /></colgroup><thead><tr><th>算法</th><th>优点</th><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>综合看性能最好，算法开销小（不能排列地址）</td><td></td><td>综合性能最好。算法开销小，不需要对空闲分区进行排序</td><td>\</td></tr><tr><td>最佳适应</td><td>优先使用更小的分区</td><td>按照空闲分区容量递增的次序</td><td>会有更大的分区被保留下来，更能满足大进程的需求</td><td>会产生很对难以利用的碎片，算法开销大，因为要重新对空闲分区进行排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区</td><td>按照空闲分区容量递减的次序</td><td>可以减少难以利用的碎片</td><td>大分区很容易被用完，不利于大进程，而且算法开销大</td></tr><tr><td>邻近适应</td><td>首次适应后，每次查找从上次位置继续查找</td><td>空闲分区以地址递增次序排列</td><td>不用每次都从低地址开始检索，算法开销小</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><p><strong>二、非连续分配</strong></p><p><strong>Ⅰ、基本分页存储管理（超重点）</strong></p><p>引入思想：固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想——把内存分为一个个相等的小分区,再按照分区大小把进程拆分成一个个小部分。各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><p>那它是怎么减少碎片的呢？举个简单的栗子就是：你拿了一桶水，给缺水地区的人们分水，为了公平，你要保证人们的杯子水是满的。但是最后总会碰到桶子里的水不够一杯。这就是基本分页的特点。内部碎片只会在为最后一个不完整的块申请一个主存空间时产生。这相对固定分区和动态分区已经好很多了。</p><p>那么程序的地址关系时如何映射到主存上呢？或者是说，当我知道一个程序的地址（逻辑地址），要如何才能找到内存地址（物理地址）。就要映入页表。</p><p>①页表</p><p>页表包括页号（由于顺序排放，所以是隐含的，实际不占据内存空间）和块号。</p><p>②地址转化</p><p><strong>计算页号和偏移量：</strong></p><p>页号=逻辑地址/页面长度（取除法的整数部分）</p><p>页内偏移量=逻辑地址%页面长度（取除法的余数部分)</p><p>③快表，又称相联存储器（TLB）</p><p>因为页表存放在内存种，每次访问内存导致访问变慢，所以在高速缓冲存储器中产生了快表。</p><p>目的就是加快执行速度。</p><p>④两级页表</p><p>背景：考虑这样一种情况，对于一个32位逻辑地址空间的分页系统，规定每一页的大小为4KB，每个表项占用4B，则这个页表需要占用4MB的内存空间，而且这段空间必须连续。显然这样的要求对于寸土寸金的内存空间来说太奢侈了，那么有没有什么好方法来解决这个问题呢？</p><p>二级页表就是将外部的页表进行拆分。离散将所需的页表存入内存，好处就是不用浪费主存空间去存储无用的页表项，也不用盲目地顺序查找页表。</p><p><strong>Ⅱ、基本分段存储管理（超重点）</strong></p><p>背景：分页是从计算机的角度考虑问题，目的是提高内存的利用率。分页通过硬件机制实现，对用户完全透明。而分段则方便编程，信息保护和共享，动态增长及动态链接等。</p><p><strong>基本思想：按照用户进程自身的逻辑关系划分为若干段。每个段有一个段名，每段从0开始编址。内存分配时，以段为单位进行分配，段内连续，段间可以不连续</strong></p><p>①段表</p><p>段号（隐含）+段号+本段在主存的起始地址</p><p>②分页与分段的区别</p><p>页是信息的<strong>物理单位</strong>。分页的主要日的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</p><p>段是信息的<strong>逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</p><p>页的大小固定且由<strong>系统决定</strong>。</p><p>段的长度却不固定，<strong>取决于用户编写的程序</strong>。</p><p>分页的用户进程地址空问是<strong>一维</strong>的</p><p>分段的用户进程地址空问是<strong>二维</strong>的</p><p>Ⅲ、段页式管理</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-422d11fd07a4bed9a39a01341fa5c253_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>※每个进程都会有一个页表或者段表。段页式也不例外，每个进程都有一个段表，但段表里面分为了很多的页表。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-24eb80554676ecd7352d11e53a8d6d68_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="第三节-虚拟内存管理">第三节 虚拟内存管理</h3><p>背景：由于传统存储管理方式的缺陷（连续分配和非连续分配）——一次性，作业必须一次性全部装入内存后才能开始运行和驻留性，就算用不到，也一直存在内存中，浪费了宝贵资源。</p><p>思想：基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空问不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</p><p>实现方式：请求分页存储管理；请求分段存储管理；请求段页式存储管理。</p><p>其最大的容量是由计算机的地址结构决定的，比如说计算机是32位的操作系统，那么它的最大容量为232 。</p><p>一、请求分页管理方式</p><p>请求分页存储管理方式和基本分页存储管理的主要区别是会调入调出（置换）</p><p>Ⅰ、页表机制</p><figure><imgsrc="https://pic2.zhimg.com/80/v2-93d08aad347ff599ce48abb4f6643ab1_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>添加了：</p><ul><li>状态位：是否已调入内存</li><li>访问字段：记录最近被访问的时间</li><li>修改位：页面调入内存后是否被修改</li><li>外存地址：页面在外存中存放的位置</li></ul><p>在请求分页系统中，若要访问的页面不在内存中时，便会产生一个<strong>缺页中断，</strong>然后分两种情况，一是内存里面还有空间，则直接位几次呢分配一个空的空闲块。二是若内存没空间了，则要由<strong>页面置换算法选择一个页面淘汰，</strong>若淘汰页面被修改过，则要写回其外存。未修改过的不用写回外存，直接丢弃就好了。</p><p>Ⅱ、页面置换算法</p><p>既然前面提到了，在无内存空间时，要采用页面置换算法换出一个页面，那涉及了哪些页面置换算法呢？</p><table style="width:100%;"><colgroup><col style="width: 19%" /><col style="width: 40%" /><col style="width: 40%" /></colgroup><thead><tr><th></th><th>内容</th><th>优缺点</th></tr></thead><tbody><tr><td>最佳置换算法（OPT）</td><td>优先淘汰最长时间不会被访问的</td><td>缺页率最好，性能最好，但无法实现</td></tr><tr><td>先进先出置换算法（FIFO）</td><td>优先淘汰最先进入内存的页面</td><td>实现简单，但性能很差，可能会出现Belady异常*</td></tr><tr><td>最近最久未使用置换算法（LRU）</td><td>优先淘汰最近最久没有被访问的页面</td><td>性能很好，但需要硬件支持，算法开销大，对所有页进行排序</td></tr><tr><td>时钟置换算法（CLOCK）</td><td>循环扫描各页面，第一轮淘汰访问位=0，并将扫描过的页面访问位改位0。若第一轮没选中，则进行第二轮扫描</td><td>实现简单，算法开销小；但未考虑页面是否被修改，修改后置换还要换出外存，这是主要的开销</td></tr><tr><td>改进型的时钟置换算法</td><td>第一轮:从当前位置开始扫描到第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为0第三轮:若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0,1）的帧用于替换</td><td>算法开销较小，性能也不错</td></tr></tbody></table><p>*：Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>二、页面分配策略</p><p>清楚一些名词</p><p>①驻留集：只请求分页存储管理中给进程分配的物理块的集合。在采用了虚拟存储技术的系统中，驻留集的大小一般小于进程的总大小。</p><p>太小，会导致缺页频繁，系统要花大量时间去处理缺页</p><p>太大，则会导致多道程序并发度下降（并发度下降CPU休息就多了）</p><p>②固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行过程中，物理块大小不变。</p><p>③可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。</p><p>④局部置换：发生缺页时准选进程自己的物理块进行置换。</p><p>⑤全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p><p>⑥抖动现象：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动。主要原因就是分配的物理块太少。但给的多了，会降低并发度，所以给多少就要研究了。（这里涉及工作集，自行百度了解一下即可）</p><p><strong>固定分配VS可变分配：区别在于进程运行期间驻留集大小是否可变。</strong></p><p><strong>局部置换VS全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出。</strong></p><p>①固定分配局部置换：物理块在整个运行期间都不改变。若进程在运行中发生缺页，则只能从<strong>该进程在内存中</strong>的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)</p><p>②可变分配全局置换：刚开始会为每个进程分配一定数量的物理块，操作系统会保持一个空闲物理块队列。岂某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。(<strong>只要缺页就加新的物理块，壕！！但会影响其他进程</strong>)</p><p>③可变分配局部置换：刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度：反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。（<strong>根据发生的缺页率来动态增加或减少进程的物理块，像屌丝，有多少用多少！</strong>)</p><p>内存映射文件</p><p>内存映射文件和标准IO操作最大的不同之处就在于它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。</p><p>“映射”就是建立一种对应关系,在这里主要是指硬盘上文件的位置与进程逻辑地址空间中一块相同区域之间一一对应,这种关系纯属是逻辑上的概念，物理上是不存在的。</p><h3 id="题目总结">题目总结：</h3><p>①（多级页表）已知系统为32位实地址，采用48位虚拟地址，页面大小为4KB,页表项大小为8B。假设系统使用纯页式存储，则要采用4级页表，页内偏移12位。</p><p>解释：页面大小为4KB，所以页内偏移12位，而页面为4KB，页表项的大小为8B，最多能有29 个页表项。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-efd319ab09208b9c7c8ff890bf0f5b80_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>②</p><figure><imgsrc="https://pic2.zhimg.com/80/v2-f2c4240fb72b75c15db3f3e0f87f11b9_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>解释：这是个很新的考题，其中页的大小为4KB，说明页内的偏移量占12位，所以02A01H中的A01属于页内偏移量，02属于页号。</p><p>但是观察标志位为0，说明不在主存，就要调入主存，但是页框只有两个，已经被3，4占着了，那这时候就要置换页面，观察访问位，都被访问过，然后看修改位，优先调出未被修改的，所以会调出3号页面。页框号为60H。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-dcc34f9ceb8094a55211ad57353311e0_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="第四章-文件管理">第四章 文件管理</h2><h3 id="第一节-文件的分类">第一节 文件的分类</h3><p>一、无结构文件（流式文件）</p><p>文件内部的数据就是一系列二进制流和字符流组成。又称“流式文件”。如windows中的txt文件。</p><p>二、有结构文件（记录式文件）</p><p>Ⅰ、顺序文件</p><p>1.串结构：记录顺序与关键字无关 2.顺序结构：记录按关键字顺序排列3.可变长记录的顺序文件无法实现随机存取，定长记录可以4.最大缺点：不方便增加和删除记录</p><p>顺序文件分为顺序存储和链式存储，哪些是可以随机存取？</p><p>链式存储是不能实现随机存取的。顺序存储，如果是可变长记录，无法实现随机存取。</p><p>如果是定长记录，可实现随机存取，若采用串结构，无法快速找到某关键字对应的记录。</p><p>若采用顺序结果，可以快速找到某关键字对应的记录。</p><p>Ⅱ、索引文件</p><p>正是由于顺序文件的查找，修改，增加的困难，所以引出了索引文件。</p><p>1.建立一张索引表，每个记录对应一个表项。各记录不用保持顺序，方便增加/删除记录。</p><p>2.索引表的结构：索引表本身就是定长记录的顺序文件，一个索引表项就是一条定长记录，因此索引文件可支持随机存取</p><p>3.若索引表按关键字顺序排列，则可支持快速检索</p><p>4.最大缺点：解决了顺序文件不方便增/删记录的问题，同时让不定长记录的文件实现了随机存取，但索引表可能占用很多空间</p><p>Ⅲ、索引顺序文件</p><p>正是由于索引表有时候比文件还大，浪费了存储空间，所以引出了索引顺序文件。</p><p>1.同样建立一张索引表。但不同与索引文件的是，不是为每个记录都设置表项，而是将记录按照某个规则进行分组，对组进行设置表项。</p><p>2.检索记录时先顺序查索引表，找到分组，再顺序查找分组。</p><p>3.当记录过多时，可建立多级索引表。</p><p>4.缺点：索引文件和索引顺序文件都提高了存取的速度，但因为配置索引表而增加了存储空间。</p><p><strong>题目：</strong>有一个顺序文件含有10000个记录，平均查找的记录数为5000个，采用索引顺序文件结构，则最好情况下平均只需查找()次记录。</p><p>解析：索引顺序文件，最好带情况是 � 组，每组有 �个记录。所以第一次查找索引表是平均次数为50次，第二次查找顺序表平均50为次。故总共次数为100次。</p><h3 id="第二节-文件目录">第二节 文件目录</h3><p>※一个文件对应一个FCB，一个FCB就是一个目录项，多个目录项构成目录文件。</p><p>FCB介绍：为了方便对文件的管理，会对每个文件都设立一个FCB（文件控制块）。文件控制块内容一般包含有文件名、文件类型、文件的物理地址、文件的起始块号、文件的存储权限、文件创建时间等等。</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-e25de1213ce9bec6e719f6ea3fc0a89b_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>众多文件的FCB</p><p>一、目录结构</p><p>Ⅰ、单级目录：一个系统只有一张目录表，不允许文件重名。</p><p>Ⅱ、两级目录：不同用户的文件可以重名，但不能对文件进行分类。</p><p>Ⅲ、多级（树型）目录：不同目录下文件可以重名，可以对文件进行分类，从根目录出发是“绝对路径”，从当前目录出发的路径是“相对路径”。</p><p>Ⅳ、无环图目录路径：在树型目录的基础上，增加一些指向同一节点的有向边，便于共享，一个实际存在外存的文件，可以被多个文件目录指向。删除时，为共享文件设置一个计数器（用来表明有多少个文件被共享），计数器为0时才真正删除该结点。</p><p>二、索引结点</p><p>只包含文件名和指针（无类型、存取权限等等对查找没用的信息），因此每个目录项的长度大幅减小，大大提升了文件检索速度——由于目录项长度的减小，因此每个磁盘块可以存放更多个目录项。</p><h3 id="第三节-文件的物理结构十分重要">第三节文件的物理结构（十分重要）</h3><p>一、连续分配</p><p>思想：要求每个文件在磁盘上占有一组连续的块。</p><p>如何进行地址转化？</p><p>文件目录中给出文件的起始块号和长度，当给出一个文件的逻辑块号i时，会找到该文件对应的目录项（FCB）。然后，就能找到起始地址，加i就可以得到物理地址</p><p><strong>物理块号=起始块号+逻辑块号</strong></p><p><strong>可以随机访问</strong></p><p>优点：支持顺序访问和直接访问，连续分配文件在读/写时速度最快</p><p>缺点：①连续分配当文件扩展时，十分不方便。</p><p>②连续分配会导致存储空间利用率低，会产生难以利用的空间碎片。</p><p>二、链接分配</p><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><p>Ⅰ、隐式链接</p><p>目录项记录了起始块号和结束块号。</p><p>思想：处理文件最后一个磁盘块外，每个磁盘块都会保存下一个盘块的指针，这个指针对于用户来说时透明的。</p><p>如何进行地址转化？</p><p>给出逻辑块号i，在目录项中可以找到起始块号，就可以依次知道后面的逻辑块号。所以读入i号逻辑块，总共需要i+1次磁盘I/O。</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-f1409928178bfb3dbd3467e67d24f2eb_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>优点：方便文件拓展，不会有碎片问题，外存利用率高。</p><p>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要消耗少量的存储空间。</p><p>Ⅱ、显式链接</p><p>思想：针对隐式链接的缺点，不支持随机访问，会设置一张FAT表，开机时，将FAT表<strong>读入内存，并常驻内存</strong>。FAT的各个表项长度相同，因此，物理块号字段可以是隐含的。</p><p>如何进行地址转化？</p><p>给出逻辑块号i，再在文件中找到FAT表，就可以知道文件的物理地址。</p><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高。并支持<strong>随机访问。</strong>相对于隐式来说，<strong>地址转换不需要访问磁盘，因此文件的访问效率更高</strong>。只需要访问在内存中的FAT。</p><p>缺点：文件分配表的需要占用一定的存储空间。</p><figure><imgsrc="https://pic3.zhimg.com/80/v2-5b2203ce9cbadc71af9ec30447081542_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>三、索引分配</p><p>思想：设置一个索引表，索引表记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p><p>于FAT表的区别：</p><p>在显示连接中的FAT表是一个磁盘对应一张，而索引分配方式中，索引表是一个文件对应一张。</p><p>优点：索引分配方式可以支持随机访问。文件拓展也很容易。</p><p>缺点：索引表占据一定的空间。</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-5fdedf497b3dda636824d1b59f9674df_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这时又引出新的问题，当文件过大，大到一个索引表无法表示全部的文件，这时候就需要用多个索引表。</p><figure><imgsrc="https://pic2.zhimg.com/80/v2-a0a15cf78891a92e56b2b4f0453d232d_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>索引结点：指向索引块的单个间接指针。如果文件不能被直接块完全索引，则使用单个间接指针。指向磁盘块的双重间接指针，该磁盘块是指向作为索引块的磁盘块的指针的集合。如果文件太大而无法通过直接块以及单个间接指针完全索引，则使用双索引指针。指向一个指针集合的磁盘块的三元索引指针。每个指针分别指向一个磁盘块，该块还包含一组指针，这些指针分别指向一个包含指向文件块的指针的索引块。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-38431db71d6c9400db45c0996d966014_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>高频考点：</p><p>①算出文件的最大长度：假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。若文件采用两层索引，则最大的文件长度可以达到256×256×1KB=64MB。</p><p>②索引分配如何进行地址转换？</p><p>要访问1026号逻辑块，则1026/256=4，1026%256=2，因此可以先将一级索引表调入内存，再查询二级索引表的2号表项即可知道1026号逻辑块存放的磁盘块号了。</p><p>题目：</p><p>1.在文件的索引节点中存放直接索引指针10个，一级和二级索引指针各1个。磁盘块大小为1KB,每个索引指针占4个字节。<strong>若某文件的索引节点已在内存中</strong>，则把该文件偏移量（按字节编址)为1234和307400处所在的磁盘块读入内存，需问的磁盘块个数分别是？</p><p>解析：“索引结点已存在内存中”说明不需要把索引结点从外存调入到内存，减少依次访问磁盘个数。八个直接索引所占的字节为8×1024B=8192B,这部分都是在直接索引里面就可以找到。只需要一次。但是一级索引为256×1024=262144，故要通过二级索引才可以找到，所以访问磁盘的次数为3次。</p><figure><imgsrc="https://pic2.zhimg.com/80/v2-b7ba95e5174868a6793e3975fa4272f5_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="第四节-文件存储空间管理">第四节 文件存储空间管理</h3><p>一、管理方法</p><p>Ⅰ、空闲表法</p><p>会设置个一个空闲表，上面记录了空闲块第一个空闲块号和空闲块数，所以当有文件要申请空闲空间时就可以为其分配。分配方式有首次适应、最佳适应、最坏适应等决定要为文件分配哪个区间。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-b8ac1d91e00ca79455b3cfcfbc956a34_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Ⅱ、空闲链表法</p><p>分为空闲盘块链和空闲盘区链</p><p>①空闲盘块链——以盘块为单位组成一条空闲链。适用离散分配的物理块。分配多个盘块需要进行多次操作。</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-4d79d9fb6b007a0bc428f9bd4eb4434f_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>②空闲盘区链——以盘区为单位组成一条空闲链。盘区是多个盘块组成。离散分配、连续分配都适用。唯一个文件分配多个盘块时效率更高。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-fc5a610b6060ad0bab0fac6752c2558c_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Ⅲ、位示图法</p><p>位示图是利⽤⼆进制的⼀位来表示磁盘中⼀个盘块的使⽤情况，磁盘上所有的盘块都有⼀个⼆进制位与之对应。当值为0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-daa3535c2791cd41ec0c89cb4780f893_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>常考的一个点是：会盘块号于字号，位号的关系。</p><p>注意字号、位号、盘块号是否从0开始。</p><p>如果给出的盘块号、字号、位号都从1开始</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-0e732a5452fdbe3322f74c31edd0d287_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如何分配：若文件需要K个块，①顺序扫描位示图，找到K个相邻或不相邻的“0”；②根据字号、位号算出对应的<strong>盘块号</strong>，将相应盘块分配给文件：③将相应位设置为“1”。</p><p>如何回收：①根据回收的盘块号计算出对应的字号、位号；②将相应二进制位设为“0”。</p><p>Ⅳ、成组链接法（了解）</p><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UX系统中采用了成组链接法对磁盘空闲块进行管理。</p><p>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-7ac54aa96e4a11da655e994e04d82d47_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>※文件再打开时不会直接把文件数据读入内存。再读/写文件是才会把文件数据从外存调入到内存中。</p><h3 id="第五节-文件保护">第五节 文件保护</h3><table><colgroup><col style="width: 8%" /><col style="width: 52%" /><col style="width: 39%" /></colgroup><thead><tr><th></th><th>内容</th><th>优缺点</th></tr></thead><tbody><tr><td>口令保护</td><td>为文件设置一个口令，用户想要访问就必须提供口令</td><td>实现开销小，但是口令放在FCB不安全</td></tr><tr><td>加密保护</td><td>用一个密码对内容进行加密，访问时必须提供密码</td><td>安全性高，但加密/解密需要耗费一定的时间</td></tr><tr><td>访问控制</td><td>用一个ACL（访问控制表）记录各个客户对文件的访问权限</td><td>实现灵活，可以实现复杂文件的保护功能</td></tr></tbody></table><h3 id="第六节-磁盘">第六节 磁盘</h3><p>一、磁盘结构</p><figure><imgsrc="https://pic3.zhimg.com/80/v2-806de7b637dbde51b91db63aa8c28876_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>柱面</strong>：硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的”0”开始编号，从图2这张放大的硬盘结构图我们可以看出，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。</p><p><strong>磁道</strong>：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。</p><p>磁盘的物理地址：（柱面号，盘面号，扇区号）就可以唯一确定磁盘块的位置。</p><p>疑问：为什么柱面号要在盘面号的前面，原因就是为了减少移动磁头的次数。</p><p>二、磁盘调度算法</p><p>一次磁盘读/写操作需要的时间=寻道时间+延迟时间+传输时间。</p><p>由于延迟时间和传输时间都是与磁盘转速有关的，且是线性相关。而转速又是磁盘的固有属性，因此无法通过操作系统优化延迟时间和传输时间。所以只能优化寻找时间。</p><p>寻找时间可以根据不同的调入算法而不同：</p><p>①先来先服务算法（FCFS）</p><p>算法思想：<strong>根据进程请求访问磁盘的先后顺序进行调度。</strong></p><p>优点：<strong>公平；如果请求访问的磁道比较集中的话，算法性能还算可以</strong>。</p><p>缺点：<strong>如果大量进程竞争使用磁盘，请求访问的磁道很分散，FCFS在性能上很差，寻道时间长</strong>。</p><figure><imgsrc="https://pic3.zhimg.com/80/v2-821e30790cba6f032094a84aebd11aba_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>例如，磁盘请求队列中的请求顺序分别为55,58,39,18,90,160,150,38,184，磁头的初始位置是磁道100，采用FCFS算法时磁头的运动过程如图5.16所示。磁头共移动了(45+3+19+21+72+70+10+112+146)=498个磁道，平均寻找长度=498/9=55.3。</p><p>②最短寻找时间优先（SSTF）</p><p>算法思想：<strong>优先处理的磁道是与当前磁头最近的磁道。可以保证每次寻道时间最短，但是不能保证总的寻道时间最短</strong>。（其实是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</p><p>优点：寻道时间很短。</p><p>缺点：<strong>可能产生饥饿现象。</strong></p><figure><imgsrc="https://pic2.zhimg.com/80/v2-d902b8a09b9282c2fe6b13d88908bb29_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>③扫描算法/电梯算法（SCAN）</p><p>算法思想：<strong>磁头扫描到最边上才能往回移动。</strong></p><p>优点：<strong>性能较好，平均寻道时间较短，不会产生饥饿现象。</strong></p><p>缺点：<strong>有时候请求到不了磁盘两边，但是磁头要扫描到两边。对各磁道的响应不平均。</strong></p><figure><imgsrc="https://pic4.zhimg.com/80/v2-2fb455d2590603cb712c8ad2dcc9240f_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>④LOOK调度算法（边移动边观察）</p><p>算法思想：<strong>如果移动方向上已经没有别的请求，就可以立即改变磁头的移动方向。</strong></p><p>优点：比起SCAN算法来说，不需要每次都移动到最外侧或最内侧才改变磁头方向，使得寻道时间进一步缩短。</p><figure><imgsrc="https://pic3.zhimg.com/80/v2-331f38b2e36d4d8a6b89bd0a40ee1c9a_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>⑤循环扫描算法（C-SCAN）</p><p>算法思想：<strong>返回时直接快速移动至起始端而不做任何请求。</strong></p><p>优点：<strong>比起SCAN来说，对于各个位置磁道的响应频率很平均。</strong></p><p>缺点：<strong>不需要每次都返回到磁道的起始端。</strong></p><figure><imgsrc="https://pic1.zhimg.com/80/v2-755d4bf36e2899bb2e92ac2ba45095a0_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>⑥C-LOOK调度算法</p><p>算法思想：<strong>解决C-SCAN问题，如果磁头移动方向上没有访问请求，则立即返回，并且磁头只需返回到有磁道访问请求的位置即可。</strong></p><p>优点：<strong>进一步改进C-SCAN算法，使得寻道时间进一步缩短。</strong></p><figure><imgsrc="https://pic1.zhimg.com/80/v2-3368158c8ace46378db54d691bfa5568_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="新增考点"><strong>新增考点：</strong></h3><p><strong>一、（固态硬盘）SSD</strong></p><p>原理：基于闪存技术（与U盘一样），属于电可擦除ROM。</p><p>组成：闪存翻译层和闪存芯片</p><p>SSD擦除太多可能会坏掉，但是机械硬盘则不会坏。所以就产生了磨损均衡技术，把擦除平均分布再各个块上，以提升使用寿命。分为动态磨损均衡和静态磨损均衡。动态磨损均衡是为了写入数据时，优先选择累计擦除次数少的新闪存块儿，静态磨损技术则是让老旧的闪存块更多承担读，而新的闪存块更多承担写。</p><p>静态磨损均衡算法比动态磨损均衡算法表现更加优秀。</p><p>二、硬链接和软链接</p><p>Ⅰ、硬链接</p><p>硬链接指文件名与索引节点号（即inode号）的链接（所以创建一个新的文件,该文件使用stat命令查看时，links显示的是1），索引节点号（inode号）可以对应一个或多个文件名，并且这些文件名可以在同一或不同目录。</p><p>由于硬链接是直接将文件名与索引节点号（即inode号）链接，因此硬链接存在以下几个特点：1、文件有相同的inode号及datablock，这使得修改其中一个硬链接文件属性或文件数据时，其他硬链接文件都会发生相应修改；（bad）2、只能对已存在的文件进行创建；3、不能跨文件系统（即分区）进行创建；4、不能对目录文件进行创建；5、删除其中一个硬链接文件时，不会对其他硬链接文件产生影响。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-156e17a94f524b36eb253ec77a069e40_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Ⅱ、软链接</p><p>软链接类似于Windows的快捷方式。它实际上是一个特殊的文件，有着自己的索引节点号（即inode号）以及用户数据块（datablock），但用户数据块（data block）中包含的是另一个文件的位置信息。</p><p>由于软链接有着自己的索引节点号（即inode号）以及用户数据块（datablock），因此没有硬链接的诸多限制，它的特性如下：1、软链接有自己独有的文件属性、inode号和datablock，但是编辑文件其实就是编辑源文件；2、可以对不存在的文件或目录进行创建；3、可以跨文件系统（即分区）进行创建，使用ln命令跨文件系统创建时，源文件必须是绝对路径，否则为死链接；4、可以对文件或目录文件进行创建；5、删除软链接并不影响源文件，但源文件被删除，则相关软链接文件变为死链接（danglinglink），若源文件（原地址原文件名）重新被创建，则死链接恢复为正常软链接。</p><p>Ⅲ、区别</p><p>第一个特性，硬链接与源文件具有相同inode号和datablock，修改文件属性或文件数据会应影响所有硬链接（包括源文件）；软链接虽然有自己的inode号和datablock，但修改的其实还是源文件</p><p>第二个特性，硬链接不能对不存在的文件进行创建，但软链接可以（包括目录文件）</p><p>第三个特性，硬链接不可以跨文件系统（即分区）创建，软链接可以</p><p>第四个特性，硬链接不能对目录创建链接，但软链接可以</p><p>第五个特性，删除源文件，硬链接没有影响；软链接变成死链接，但在相同位置重新创建同名文件，软链接变成指向新文件的链接</p><p>三、虚拟文件系统</p><p>虚拟文件系统（VFS）是物理文件系统与服务之间的一个接口层，它对Linux的每个文件系统的所有细节进行抽象，使得不同的文件系统在<ahref="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/Linux%3FfromModule%3Dlemma_inlink">Linux</a>核心以及系统中运行的其他进程看来，都是相同的。严格说来，VFS并不是一种实际的<ahref="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/4827215%3FfromModule%3Dlemma_inlink">文件系统</a>。它只存在于<ahref="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%86%85%E5%AD%98/103614%3FfromModule%3Dlemma_inlink">内存</a>中，不存在于任何外存空间。VFS在系统启动时建立，在系统关闭时消亡。</p><p>四、文件系统挂载</p><p>将额外的文件系统与根文件系统某个现存的目录建立关联关系，进而使得该目录作为其他文件访问入口的行为称之为挂载。</p><h2 id="第五章-输入输出管理">第五章 输入输出管理</h2><h3 id="第一节-io管理概述">第一节 I/O管理概述</h3><p>一、I/O控制器（I/O接口）</p><p>Ⅰ为什么要单独设置一个控制器，为什么不直接用CPU控制？</p><p>①最肤浅的，为了能够让CPU能够和I/O设备进行通信</p><p>②协调I/O设备与总线之间的速度！</p><p>Ⅱ、I/O控制器主要功能和组成？</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-95aec93badb81ecdc69f08bb6c64383c_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>二、I/O控制方式（重点）</strong></p><table><colgroup><col style="width: 13%" /><col style="width: 49%" /><col style="width: 9%" /><col style="width: 6%" /><col style="width: 22%" /></colgroup><thead><tr><th></th><th>过程</th><th>CPU干预频率</th><th>传输单位</th><th>数据流向</th></tr></thead><tbody><tr><td>程序直接控制方式</td><td>CPU不断轮询查看设备状态</td><td>极高</td><td>字</td><td>设备-CPU-内存 内存-CPU-设备</td></tr><tr><td>中断驱动方式</td><td>CPU指令执行完，查看有没有中断请求</td><td>高</td><td>字</td><td>设备-CPU-内存 内存-CPU-设备</td></tr><tr><td>DMA</td><td>CPU发出请求后就可以做其他事，剩下事由DMA控制器完成，完成后向CPU发送完成信号</td><td>中</td><td>块</td><td>设备-内存 内存-设备</td></tr><tr><td>通道控制方式</td><td>CPU发出请求后就可以做其他事，完成后向CPU发送完成信号</td><td>低</td><td>一组块</td><td>设备-内存 内存-设备</td></tr></tbody></table><figure><imgsrc="https://pic1.zhimg.com/80/v2-a558aa3a1fff26b33e321cb0587a2d10_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>通道控制方式</p><p>进化过程：每一个阶段的优点都是解决了上一阶段的最大缺点。总体来说，整个发展过程就是要尽量减少CPU对/O过程的千预，把CPU从繁杂的/O控制事务中解脱出来，以便更多地去完成数据处理任务。</p><h3 id="第二节-设备独立性软件">第二节 设备独立性软件</h3><p>一、高速缓存和缓冲区</p><p>Ⅰ、目的：缓解CPU与设备的速度矛盾、减少对CPU的中断频率、解决数据粒度不匹配的问题、提高CPU与/IO设备之间的并行性。</p><p>Ⅱ、实现方法</p><p>①单缓冲</p><p>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）</p><p>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p><p><strong>处理一块数据平均使用的时间（常考）</strong></p><p><strong>①T&gt;C（输入时间大于处理时间）</strong></p><figure><imgsrc="https://pic3.zhimg.com/80/v2-6ef51937576ddd8860421e96edb187ce_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>②T&lt;C（输入时间小于处理时间）</strong></p><figure><imgsrc="https://pic1.zhimg.com/80/v2-b6fed4d1ef056e443ab6859c665bd218_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>结论：采用单缓冲策略，处理一块数据平均耗时Max(C,T)+M</strong></p><p>②双缓冲</p><p>操作系统为其分配两个缓冲区</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-f21435b6e41f153afbd4c3d17fc88d50_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>处理一块数据平均使用时间</p><p>双缓冲题目巾，假设初始状态为：工作区空，其中·个缓冲区满，另·个缓冲区空。</p><p><strong>结论：采用双缓冲策略，处理一个数据块的平均耗时为Max(T,C+M)</strong></p><p>③循环缓冲</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-32c46470b0291a24fc27e1d6ebf57a18_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>④缓冲池</p><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状沉可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）</p><p>另外，根据一·个缓冲区在实际运算巾扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区(hin)、用于提取输入数据的工作缓冲区(si)、用于收容输出数据的工作缓冲区(hout)、用于提取输出数据的工作缓冲区(sout)</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-b143f9b953844d50c96d085c97cc763f_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://pic1.zhimg.com/80/v2-725a05d2335b6cc7312197c62a93dcfc_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>三、高速缓冲和缓冲区的对比</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-94c14a4105dc38fc14a95c146c0779eb_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>四、SPOOLing技术（假脱机技术）</p><p>磁盘是一种高速设备，在与内存交换数据的速度上优于打印机、键盘、鼠标等中低速设备。试想一下，若没有SPOOLing技术，CPU要向打印机输出要打印的数据，打印机的打印速度比较慢，CPU就必须迁就打印机，在打印机把数据打印完后才能继续做其他的工作，浪费了CPU的不少时间。在SPOOLing技术下，CPU要打印机打印的数据可以先输出到磁盘的输出井中（这个过程由假脱机进程控制)，然后做其他的事情。若打印机此时被占用，则SPOOLing系统就会把这个打印请求挂到等待队列上，待打印机有空时再把数据打印出来。向磁盘输出数据的速度比向打印机输出数据的速度快，因此就节省了时间。<strong>提高了独占设备的利用率。</strong></p><p>五、静态分配和动态分配</p><p>对独占型设备一般采用静态分配,即在作业级进行的分配,当一个作业运行之前由系统一次分配满足需要的全部设备,这些设备一直为该作业占用,直到作业撤消。这种分配不会出现死锁,但设备的利用效率较低。而共享设备一般采用的事动态分配。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】MySQL命令</title>
      <link href="/posts/48897.html"/>
      <url>/posts/48897.html</url>
      
        <content type="html"><![CDATA[<h3 id="连接到mysql服务的指令">连接到MySQL服务的指令</h3><ol type="1"><li><p>启动MySQL服务（使用管理员权限）</p><p><code>net start mysql服务名</code></p><p>扩展：</p><p>​ 关闭MySQL服务：<code>net stop mysql服务名</code></p></li><li><p>登录MySQL服务</p></li></ol><p><code>mysql -h 主机IP -P 端口 -u 用户名 -p密码</code></p><blockquote><p>注意： - <code>-p密码</code>之间没有空格 -<code>-p</code>后面没写密码，回车会要求输入密码 -如果没写<code>-h 主机</code>，默认是本机 -如果没写<code>-P 端口</code>，默认是3306</p></blockquote><h3 id="创建数据库">创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个名称为wql_db01的数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE wql_db01</span><br><span class="line"># 创建一个使用utf8字符集的wql_db02数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE wql_db02 <span class="keyword">CHARACTER SET</span> utf8</span><br><span class="line"># 创建一个使用utf8字符集且含校对规则utf8_bin的wql_db03数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE wql_db03 <span class="keyword">CHARACTER SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin</span><br></pre></td></tr></table></figure><p>在创建数据库、表的时候，为了规避关键字，可以使用反引号解决：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `<span class="keyword">CREATE</span>`</span><br></pre></td></tr></table></figure><blockquote><p>默认字符集：utf8 默认校对规则：utf8_general_ci</p></blockquote><h3 id="查看删除数据库">查看、删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 显示数据库语句</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line"># 显示数据库创建语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE db_name</span><br><span class="line"># 删除名为db_name的数据库</span><br><span class="line"><span class="keyword">DROP</span> DATABASE db_name</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>#从所有字段中查询</span><br><span class="line"><span class="keyword">FROM</span> users#从users表中</span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="operator">=</span> &quot;tom&quot;#从NAME字段为tom的</span><br></pre></td></tr></table></figure><h3 id="备份与恢复">备份与恢复</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 备份数据库(DOS命令行执行)</span><br><span class="line">mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n &gt; 文件名.sql</span><br><span class="line"># 恢复数据库(进入mysql执行)</span><br><span class="line">source 文件名.sql</span><br><span class="line"># 备份数据库的表(DOS命令行执行)</span><br><span class="line">mysqldump -u 用户名 -p 数据库 表1 表2 表n &gt; 文件名.sql</span><br></pre></td></tr></table></figure><h3 id="创建表">创建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table table_name(</span><br><span class="line">field1 datatype,</span><br><span class="line">    field2 datatype,</span><br><span class="line">    field3 datatype</span><br><span class="line">)character set 字符集 collate 校对规则 engine 引擎</span><br><span class="line">/*</span><br><span class="line">field:列名 datatype:列类型/字段类型</span><br><span class="line">character set:默认为所在数据库字符集</span><br><span class="line">collate:默认为所在数据库校对规则</span><br><span class="line">engine:引擎</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】数学建模（未更完）</title>
      <link href="/posts/59666.html"/>
      <url>/posts/59666.html</url>
      
        <content type="html"><![CDATA[<h2 id="数学建模的一般步骤">数学建模的一般步骤</h2><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202212042222750.png" /></p><h3 id="模型准备">模型准备</h3><p>了解问题的实际背景，明确其实际意义，掌握对象的各种信息。以数学思路来解释问题的精髓</p><h3 id="模型假设">模型假设</h3><p>针对问题特点和建模目的作出合理的、简化的假设（在合理与简化之间作出折中）</p><h3 id="建立模型">建立模型</h3><p>用数学的语言、符号描述问题，发挥想象力 （尽量采用简单的数学工具）</p><h3 id="模型求解">模型求解</h3><p>利用获取的数据资料，对模型的所有参数做出计算。推到模型的公式，将数学表达式变形为建模方法的标准形式，通过限制条件，对这个模型进行求解。</p><h3 id="模型分析">模型分析</h3><p>对所要建立模型的思路进行阐述，对所得的结果进行数学上的分析。包括误差分析、数据稳定性分析等。</p><h3 id="模型检验">模型检验</h3><p>用非技术性的语言回答实际问题。将模型分析结果与实际情形进行比较，以此来验证模型的准确性、合理性和适用性。</p><ul><li>如果模型与实际较吻合，则要对结果给出其实际含义，并进行解释。</li><li>如果模型与实际吻合较差，则应该修改假设，再次重复建模过程。</li></ul><h2 id="论文要素">论文要素</h2><ul><li>题目：</li><li>摘要、关键词：很重要</li><li>问题重述：用自己的语言对问题进行描述</li><li>问题假设：</li><li>问题分析</li><li>符号说明</li><li>模型建立</li><li>模型求解：使用编程语言求解（matlab、python、R等）</li><li>模型优缺点评价</li><li>参考文献</li></ul><h2 id="备战建模比赛">备战建模比赛</h2><h3 id="分工协作及对应要求">分工协作及对应要求</h3><h4 id="建模员">建模员</h4><p>需要系统掌握各类模型，做到</p><ul><li>模型功能</li><li>模型适用场景</li><li>实现该模型需要的条件</li><li>模型有哪些缺点或不足，可以做出哪些改进</li></ul><p>学习基础知识-&gt;学习算法知识-&gt;学习优秀论文</p><h4 id="程序员">程序员</h4><p>需要掌握Matlab/Python，做到</p><ul><li>熟练掌握编程基础</li><li>实现各类常见算法</li><li>对程序Bug做出改正</li><li>熟练利用编程或软件制作精美图片</li></ul><p>学习编程知识-&gt;调试常用模型-&gt;复现优秀论文</p><h4 id="写作员">写作员</h4><p>需要熟练撰写论文各模块内容</p><ul><li>掌握学术语言规范</li><li>明白论文各模块写作要求</li><li>能够对论文进行排版</li><li>若撰写英文论文，需要能翻译并检查论文错误</li></ul><p>掌握写作要求-&gt;掌握学术语言-&gt;掌握排版技巧</p><h2 id="赛题类型">赛题类型</h2><h3 id="一预测类">一、预测类</h3><h4 id="解题一般步骤">解题一般步骤：</h4><ol type="1"><li>确定预测目标</li><li>收集、分析资料</li><li>选择合适的预测方法预测</li><li>分析评价预测方法及其结果</li><li>修正预测结果</li><li>给出预测结果</li></ol><h4 id="方法选择">方法选择</h4><p>小样本内部预测：插值与拟合方法 中、大样本内部预测：回归分析法小样本的未来预测：灰色预测方法中、大样本的随机因素或周期特征的未来预测：时间序列方法大、特大样本未来预测：神经网络方法</p><h3 id="二评价类">二、评价类</h3><h4 id="解题一般步骤-1">解题一般步骤</h4><ol type="1"><li>明确评价目的</li><li>确定被评价对象</li><li>建立评价指标体系</li><li>确定各指标相对应的权重系数</li><li>选择或构造综合评价模型</li><li>计算各系统的综合评价值</li><li>给出综合评价结果</li></ol><h3 id="三机理分析类">三、机理分析类</h3><h3 id="四优化类">四、优化类</h3><h4 id="解题一般步骤-2">解题一般步骤</h4><ol type="1"><li>确定优化目标</li><li>确定决策变量</li><li>构建目标函数</li><li>根据已知条件构建约束条件</li><li>选择合适的方法求解目标函数</li><li>给出优化结果</li></ol><h2 id="模型">模型</h2><h3 id="线性规划模型">线性规划模型</h3><blockquote><p>有限的条件下，最大的收益</p></blockquote><p>例题：张麻子既要攻碉楼又要追替身，他们一伙6人，总共1200发子弹；每有一人攻碉楼会给百姓带来40点士气值，每有一人追替身会给百姓带来30点士气值；攻碉楼每人需240发子弹，追替身每人需120发。问攻碉楼和追替身各派几个人，能使百姓的士气值最大？</p><blockquote><p>解：设x<sub>1</sub>人攻碉楼，x<sub>2</sub>人追替身，百姓士气值为y；士气值最大：max y = 40x<sub>1</sub> + 30x<sub>2</sub>；总共6人：x<sub>1</sub> + x<sub>2</sub> = 6； 子弹有限：240x<sub>1</sub>+ 120x<sub>2</sub> ≤ 1200；<font color="red">既要攻碉楼又要追替身：x<sub>1</sub> ≥ 1 ，x<sub>2</sub> ≥ 1；</font></p></blockquote><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202302171606913.png" /></p><h4 id="适用经典赛题">适用经典赛题</h4><ul><li>题目中提到“怎样安排/分配”、“尽量多(少)”、“最多(少)“、”利润最大”、最合理等</li><li>生产安排：原材料、设备有限制，总利润最大</li><li>投资收益：资产配置、收益率、损失率、组合投资、总收益最大<font color=red>而不是总收益率</font></li><li>销售运输：产地、销地、产量、销量、运费，总运费最省</li><li>车辆安排：路线、起点终点、承载量、时间点、车次安排最合理</li><li>整数规划、0-1规划</li></ul><h4 id="代码实现">代码实现</h4><ul><li><p><strong>模型化matlab标准型</strong>：目标函数最小值、约束条件小于等于或等号</p></li><li><p>如果有最大值怎么办？约束条件有大于等于怎么办？</p><ul><li>式子两边加负号</li></ul></li><li><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>f</td><td>目标函数的系数列向量</td></tr><tr><td>A,b</td><td>不等式约束条件的变量系数矩阵和常数项矩阵</td></tr><tr><td>Aeq,beq</td><td>等式约束条件的系数矩阵和常数项矩阵</td></tr><tr><td>lb,ub</td><td>决策变量的最小取值和最大取值</td></tr></tbody></table></li><li><p><code>[x,fval] = linprog(f,A,b,Aeq,beq,lb,ub)</code></p></li><li><p>x返回最优解的变量取值，fval返回目标函数的最优值</p></li><li></li><li><p>若不存在不等式约束，用”[]“代替A和b</p></li><li><p>若不存在等式约束，用”[]“代替Aeq和beq</p></li><li><p>没有等式约束和最小、最大取值的约束时，可以不写Aeq,beq,lb,ub：<code>[x,fval] =linprog(f,A,b)</code></p></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f = [<span class="number">-40</span>;<span class="number">-30</span>]; <span class="comment">%目标函数中变量的系数矩阵</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">1</span>;<span class="number">-1</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">-1</span>;<span class="number">240</span>,<span class="number">120</span>]; <span class="comment">%小于等于的约束条件中系数矩阵</span></span><br><span class="line">b = [<span class="number">6</span>;<span class="number">-1</span>;<span class="number">-1</span>;<span class="number">1200</span>]; <span class="comment">%小于等于的约束条件中常数项矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[x,y] = linprog(f,a,b);</span><br><span class="line">y=-y;</span><br></pre></td></tr></table></figure><h3 id="非线性规划模型">非线性规划模型</h3><blockquote><p>有限的条件下，最大的收益</p></blockquote><ul><li><p>至少一个变量不是一次方</p></li><li><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202302211432133.png" /></p></li><li></li><li><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>fun</td><td>单独函数文件里定义的目标函数</td></tr><tr><td>x0</td><td>决策变量的初始值。不知道就随便写个数</td></tr><tr><td>A,b</td><td>不等式约束条件的变量系数矩阵和常数项矩阵（都是&lt;=）</td></tr><tr><td>Aeq,beq</td><td>等式约束条件的系数矩阵和常数项矩阵</td></tr><tr><td>lb,ub</td><td>决策变量的最小取值和最大取值</td></tr><tr><td>nonlcon</td><td>非线性约束，包括不等式和等式</td></tr></tbody></table></li><li><p><code>[x,fval] = fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon)</code></p></li><li><p>x得到决策变量取值，fval得到最优解取值</p></li><li><p>本题：<code>[x,y] = fmincon('fun1',[0;0;0],[],[],[],[],[0;0;0],[],'fun2')</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% fun1 目标函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun1</span><span class="params">(x)</span></span></span><br><span class="line">f = sum(x.^<span class="number">2</span>) + <span class="number">8</span>;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% fun2 非线性约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[g,h]</span> = <span class="title">fun2</span><span class="params">(x)</span></span></span><br><span class="line">g = [-x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)-x(<span class="number">3</span>)^<span class="number">2</span> </span><br><span class="line">x(<span class="number">1</span>)+x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>)^<span class="number">3</span><span class="number">-20</span>] <span class="comment">% g是非线性不等式</span></span><br><span class="line">h = [-x(<span class="number">1</span>)-x(<span class="number">2</span>)^<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)^<span class="number">2</span><span class="number">-3</span>]</span><br></pre></td></tr></table></figure></li><li><p>适用经典赛题</p><ul><li>题目中提到“怎样安排/分配” …</li><li>投资规划：资产配置、收益率、损失率、组合投资、总收益率最大</li><li>角度调整：飞行管理避免相撞；影院最佳视角</li></ul></li></ul><h3 id="多目标规划模型">多目标规划模型</h3><blockquote><p>既要XXX，又要XXX</p><p><font color=red>需要衡量每个目标的完成情况，并在主观上区分三个目标的重要性，使得整体完成情况尽量好</font></p></blockquote><ul><li><p>引入三个概念：正负偏差变量、绝对约束和目标约束、优先因子</p></li><li><p>衡量每个目标的完成情况：正负偏差变量</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202302251103373.png"alt="image-20230225110320655" /><figcaption aria-hidden="true">image-20230225110320655</figcaption></figure></li></ul><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202302251104313.png"alt="image-20230225110408823" /><figcaption aria-hidden="true">image-20230225110408823</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202302251104103.png"alt="image-20230225110425503" /><figcaption aria-hidden="true">image-20230225110425503</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202302251104012.png"alt="image-20230225110446909" /><figcaption aria-hidden="true">image-20230225110446909</figcaption></figure><h3 id="层次分析法基本模型ahp">层次分析法基本模型（AHP）</h3><h4 id="三大典型应用">三大典型应用</h4><ol type="1"><li>最佳方案的选取（选择运动员、选择地址）</li><li>评价类问题（评价水质状况、评价环境）</li><li>指标体系的优选（兼顾科学和效率）</li></ol><h4 id="步骤">步骤</h4><ol type="1"><li><p>建立层次结构模型</p><p>最高层：决策的目的、要解决的问题</p><p>最低层：决策时的备选方案</p><p>中间层：考虑的因素、决策的准则</p><p>对于相邻的两层，称高层为目标层、低层为因素层</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202301042000020.png" /></p></li><li><p>构造判断（成对比较）矩阵</p><ol type="1"><li><p>不把所有因素放在一起比较，而是两两相互比较</p></li><li><p>对此时采用相对尺度，以尽可能减少性质不同的的因素比较的困难，以提高准确度</p><p>设要比较各准则C<sub>1</sub>、C<sub>2</sub>、C<sub>3</sub>、C<sub>4</sub>、C<sub>5</sub>对目标O的重要性C<sub>i</sub> : C<sub>j</sub> = a<sub>ij</sub></p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202301042018819.png" /></p><ul><li>对角线元素一定为1</li><li>a<sub>ij</sub> = 1/a<sub>ji</sub></li></ul><p>上述矩阵存在不一致问题，允许不一致，但要确定不一致的范围</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202301042023991.png" /></p></li></ol></li><li><p>层次单排序及其一致性检验</p><ol type="1"><li>对应于判断矩阵的最大特征根λ<sub>max</sub>的特征向量，经归一化后记为W</li><li>W的元素为同一层次因素对于上一层次因素某因素相对重要性排序权值，这一过程称为层次单排序</li></ol><p>能否确认层次单排序，需要进行一致性检验，指对A确定不一致的允许范围</p><p>定理：n阶一致阵的唯一非零特征根为n</p><p>定理：n阶正互反阵A的最大特征根λ≥n，当且仅当λ=n时A为一致阵</p><p>定义一致性指标： <span class="math display">$$ {CI}CI=\frac{\lambda-n}{n-1}$$</span> {一致性指标} CI=0，有完全的一致性 CI接近于0，有满意的一致性CI越大，不一致越严重</p></li><li><p>层次总排序及其一致性检验</p></li></ol><h2 id="matlab">MATLAB</h2><h3 id="基操">基操</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clear <span class="comment">%清空工作区</span></span><br><span class="line">clc <span class="comment">%清空控制台</span></span><br><span class="line"><span class="built_in">disp</span>(str); <span class="comment">%输出str信息</span></span><br><span class="line">A = input(<span class="string">&#x27;请输入矩阵A&#x27;</span>);</span><br><span class="line"><span class="built_in">size</span>(A);</span><br></pre></td></tr></table></figure><h3 id="矩阵">矩阵</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B = A&#x27; <span class="comment">%求A的转置矩阵</span></span><br><span class="line">[D,V] = eig(A)； <span class="comment">%求特征值和特征向量</span></span><br><span class="line">E = inv(A); <span class="comment">%求逆矩阵</span></span><br><span class="line">C = A*B; <span class="comment">%矩阵乘法</span></span><br><span class="line">E = A.*B; <span class="comment">%矩阵点乘，对应元素相乘</span></span><br></pre></td></tr></table></figure><h3 id="作图">作图</h3><h4 id="二维图">二维图</h4><h5 id="线图">线图</h5><blockquote><p><code>plot</code>函数用来创建x和y的简单线图</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">0.05</span>:<span class="number">30</span> <span class="comment">%从0到30，每隔0.05取一次值</span></span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">plot</span>(x,y); <span class="comment">%若(x,y,&#x27;LineWidth&#x27;,2)可让函数曲线变粗</span></span><br><span class="line">xlabel(<span class="string">&#x27;横轴标题&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;纵轴标题&#x27;</span>);</span><br><span class="line">grid on <span class="comment">%显示网格</span></span><br><span class="line">axis([<span class="number">-5</span> <span class="number">35</span> <span class="number">-2</span> <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h5 id="条形图">条形图</h5><blockquote><p><code>bar</code>函数创建垂直条形图<code>barh</code>函数创建水平条形图</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">-3</span>:<span class="number">0.5</span>:<span class="number">3</span>;</span><br><span class="line">p = <span class="built_in">exp</span>(-t.*t);</span><br><span class="line">bar(t,p);</span><br><span class="line">barh(t,p);</span><br></pre></td></tr></table></figure><h5 id="极坐标图">极坐标图</h5><blockquote><p><code>polarplot</code>函数用来绘制极坐标图</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">theta = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="comment">% abs求绝对值或复数的模</span></span><br><span class="line">radi = <span class="built_in">abs</span>(<span class="built_in">sin</span>(<span class="number">2</span>*theta).*<span class="built_in">cos</span>(<span class="number">2</span>*theta));</span><br><span class="line">polarplot(theta,radi); <span class="comment">%括号内是弧度和半径</span></span><br></pre></td></tr></table></figure><h5 id="散点图">散点图</h5><blockquote><p><code>scatter</code>函数用来绘制x和y的散点图</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Height = <span class="built_in">randn</span>(<span class="number">1000</span>,<span class="number">1</span>);</span><br><span class="line">Weight = <span class="built_in">randn</span>(<span class="number">1000</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scatter</span>(Height,Weight);</span><br><span class="line">xlabel(<span class="string">&#x27;Height&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Weight&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="三维图和子图">三维图和子图</h4><h5 id="三位曲面图">三位曲面图</h5><blockquote><p><code>surf</code>函数可以用来做三维曲面图。一般是展示函数<code>z=z(x,y)</code>的图像。</p></blockquote><p>首先需要用<code>meshgrid</code>创建好空间上<code>(x,y)</code>点。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[X,Y] = <span class="built_in">meshgrid</span>(<span class="number">-2</span>:<span class="number">0.2</span>:<span class="number">2</span>);</span><br><span class="line"><span class="comment">%Z = X.^2 + Y.^2;</span></span><br><span class="line">Z = X.*<span class="built_in">exp</span>(-X.^<span class="number">2</span> - Y.^<span class="number">2</span>;);</span><br><span class="line">surf(X,Y,Z);</span><br><span class="line"></span><br><span class="line">colormap spring <span class="comment">% colormap设置颜色，可跟winter、summer、hsv</span></span><br><span class="line">colorbar</span><br></pre></td></tr></table></figure><h5 id="子图">子图</h5><blockquote><p>使用subplot函数可以在同一窗口的不同区域显示多个绘图</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">theta = 0:0.01:2*pi;</span><br><span class="line">radi = abs(sin(2*theta)*cos(2*theta));</span><br><span class="line">Height = randn(1000,1);</span><br><span class="line">Weight = randn(1000,1);</span><br><span class="line"></span><br><span class="line">subplot(2,1,1); surf(X.^2); title(&#x27;1st&#x27;);</span><br><span class="line">subplot(2,1,2); surf(Y.^2); title(&#x27;2nd&#x27;);</span><br></pre></td></tr></table></figure><h3 id="处理缺失异常值">处理缺失/异常值</h3><blockquote><p>使用实时脚本文件，任务——清理缺失数据/清理离群数据</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>:<span class="number">100</span>; <span class="comment">%构造一个数组，元素为1,2,3,...,100</span></span><br><span class="line"><span class="comment">% randn(1,100)意味着生成一个1行100列的矩阵</span></span><br><span class="line"><span class="comment">% 矩阵元素的均值为0，方差σ^2=1，且是正态分布的随机数</span></span><br><span class="line">data = <span class="built_in">randn</span>(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">data(<span class="number">20</span>:<span class="number">20</span>:<span class="number">80</span>) = NaN;</span><br><span class="line"></span><br><span class="line">data(<span class="number">10</span>) = <span class="number">-50</span>;</span><br><span class="line">data(<span class="number">40</span>) = <span class="number">45</span>;</span><br><span class="line">data(<span class="number">70</span>) = <span class="number">-20</span>;</span><br><span class="line">data(<span class="number">90</span>) = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">plot</span>(x,data);</span><br></pre></td></tr></table></figure><h2 id="搜索技巧">搜索技巧</h2><h3 id="完全匹配搜索">完全匹配搜索</h3><blockquote><p>查询词的外边加上双引号“”</p></blockquote><ul><li>引号中英文均可</li><li>例如搜索 “CT参数标定”，则搜索结果不是分别带有“CT”或“参数标定”的网页</li></ul><h3 id="标题关键词搜索">标题关键词搜索</h3><blockquote><p>查询词的前边加上intitle:</p></blockquote><ul><li>冒号为英文冒号</li><li>例如搜索 intitle:CT参数标定，则搜索结果每一个标题都带有“CT参数标定”</li></ul><h3 id="搜索文档">搜索文档</h3><blockquote><p>查询词后空格再输入filetype:文件格式(doc/pdf/xls/等)</p></blockquote><ul><li>例如搜索 线性规划 filetype:pdf ，则搜索结果都是pdf的资料</li></ul><h3 id="去掉不想要的">去掉不想要的</h3><blockquote><p>查询词后边加空格后加减号关键字</p></blockquote><ul><li>例如搜索 线性规划 filetype:pdf -百度文库</li></ul><h2 id="查文献">查文献</h2><h3 id="知网">知网</h3><blockquote><p>优先查看知网的硕博士论文</p></blockquote><h3 id="谷歌学术">谷歌学术</h3><blockquote><p>国内无法访问，可访问谷歌学术镜像</p></blockquote><h2 id="查数据">查数据</h2><h3 id="国家统计局">国家统计局</h3><h3 id="github项目">GitHub项目</h3><ul><li>GitHub上的一个项目，包含了经济、地理、能源、教育等所有你能想到的领域的数据</li><li>https://github.com/awesomedata/awesome-public-datasets</li></ul><h2 id="数据预处理">数据预处理</h2><h3 id="缺失值">缺失值</h3><ul><li>比赛提供的数据，发现有些单元格是null或空</li><li>缺失太多直接将该项删除</li><li>最简单的处理：均值、众数插补<ul><li>定量数据：例如身高年龄等，用整体的均值来补缺失</li><li>定性数据：例如性别文化程度等，用众数来补缺失</li><li>使用赛题：人口的数量年龄、经济产业情况等统计数据，对个体精度要求不大的数据</li></ul></li><li>Newton插值法<ul><li>根据固定公式，构造近似函数，补上缺失值，普遍适用性强</li><li>缺点：区间边缘处的不稳定震荡，即龙格现象。不适合对导数有要求的题目</li><li>使用赛题：热力学温度、地形测量、定位等只追求函数值而不关心变化的数据</li></ul></li><li>样条插值法<ul><li>用分段光滑的曲线去插值，光滑意味着曲线不仅连续，还要有连续的曲率</li><li>使用赛题：零件加工、水库水流量、图像“基线漂移”、机器人轨迹等精度要求高、没有突变的数据</li></ul></li></ul><h3 id="异常值">异常值</h3><ul><li><p>样本中明显和其他数值差异很大的数据</p></li><li><p>正态分布3σ原则</p><ul><li>数值分布在(μ-3σ,μ+3σ)中的概率为99.73%，其中μ为平均值，σ为标准差</li><li>求解步骤：<ol type="1"><li>计算均值μ和标准差σ</li><li>判断每个数据值是否存在(μ-3σ,μ+3σ)内，不在则为异常值</li></ol></li><li>适用题目：总体符合正态分布，例如人口数据、测量误差、生产加工质量、考试成绩等</li><li>不适用题目：总体符合其他分布，例如公交站人数排队论符合泊松分布</li></ul></li><li><p>画箱型图</p><ul><li>箱型图中，把数据从小到大排序。下四分位数Q1是排第25%的数值，上四分位数Q3是拍第75%的数值</li><li>四分位距IQR=Q3-Q1，也就是排名第75%的减去第25%的数值</li><li>与正态分布类似，设置个合理区间，在区间外的就是异常值</li><li>一般设[Q1-1.5×IQR，Q3+1.5×IQR]</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Java输入输出流</title>
      <link href="/posts/64267.html"/>
      <url>/posts/64267.html</url>
      
        <content type="html"><![CDATA[<h3 id="流的分类">流的分类：</h3><ul><li>按操作数据单位不同分为：字节流、字符流</li><li>按数据流的流向不同：输入流、输出流</li><li>按流的角色不同分为：节点流、处理流/包装流</li></ul><table><thead><tr><th style="text-align: center;">抽象基类</th><th style="text-align: center;">字节流</th><th style="text-align: center;">字符流</th></tr></thead><tbody><tr><td style="text-align: center;">输入流</td><td style="text-align: center;">InputStream</td><td style="text-align: center;">Reader</td></tr><tr><td style="text-align: center;">输出流</td><td style="text-align: center;">OutputStream</td><td style="text-align: center;">Writer</td></tr></tbody></table><p><imgsrc="https://picture-wq3stone.oss-cn-hangzhou.aliyuncs.com/picgo/202211231643136.png" /></p><h3 id="fileinputstream文件输入流">FileInputStream：文件输入流</h3><h4 id="构造方法">构造方法</h4><ul><li><code>FileInputStream(File file)</code>该文件通过文件系统中的<code>File</code> 对象 <code>file</code> 指定。</li><li><code>FileInputStream(String path)</code>该文件通过文件系统中的路径名<code>path</code> 指定。</li><li><code>FileInputStream(FileDescriptor fdObj)</code>通过使用文件描述符<code>fdObj</code> 创建一个<code>FileInputStream</code>，该文件描述符表示到文件系统中某个实际文件的现有连接。</li></ul><h4 id="方法摘要">方法摘要</h4><table><colgroup><col style="width: 9%" /><col style="width: 32%" /><col style="width: 57%" /></colgroup><thead><tr><th>返回值类型</th><th>方法名及形参列表</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭此文件输入流并释放与此流有关的所有系统资源。</td></tr><tr><td><code>int</code></td><td><code>read()</code></td><td>从此输入流中读取一个数据字节。</td></tr><tr><td><code>int</code></td><td><code>read(byte[] b)</code></td><td>从此输入流中将最多 <code>b.length</code>个字节的数据读入一个byte数组中。</td></tr><tr><td><code>int</code></td><td><code>read(byte[] b, int off, int len)</code></td><td>从此输入流中将最多 <code>len</code> 个字节的数据读入一个 byte数组中。</td></tr></tbody></table><p><code>public int read()</code></p><ul><li>返回：<ul><li>下一个数据字节，如果到达文件末尾则返回 -1</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStram01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((read = input.read()) != -<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="type">char</span>) read);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>public int read(byte[] b)</code></p><ul><li>参数：<ul><li>b：存储读取数据的缓冲区</li></ul></li><li>返回：<ul><li>读入缓冲区的字节总数，如果因为已经到达文件末尾则返回 -1</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStram02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>((readLen=input.read(buf)) != -<span class="number">1</span>)</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readLen));</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>public int read(byte[] b, int off, int len)</code></p><ul><li><p>参数：</p><ul><li><p>b：存储读取数据的缓冲区</p></li><li><p>off：目标数组 b 中的起始偏移量</p></li><li><p>len：读取的最大字节数</p></li></ul></li><li><p>返回：</p><ul><li>读入缓冲区的字节总数，如果因为已经到达文件末尾则返回 -1。</li></ul></li></ul><h3 id="fileoutputstream文件输出流">FileOutputStream：文件输出流</h3><h4 id="构造方法-1">构造方法</h4><ul><li><code>FileOutputStream(File file)</code>该文件通过文件系统中的<code>File</code> 对象 <code>file</code> 指定。</li><li><code>FileOutputStream(File file, boolean append)</code>该文件通过文件系统中的<code>File</code> 对象 <code>file</code> 指定。</li><li><code>FileOutputStream(String path)</code>该文件通过文件系统中的路径名<code>path</code> 指定。</li><li><code>FileOutputStream(String path, boolean append)</code>该文件通过文件系统中的路径名<code>path</code> 指定。</li><li><code>FileOutputStream(FileDescriptor fdObj)</code>通过使用文件描述符<code>fdObj</code> 创建一个<code>FileOutputStream</code>，该文件描述符表示到文件系统中某个实际文件的现有连接。</li></ul><h4 id="方法摘要-1">方法摘要</h4><table><colgroup><col style="width: 9%" /><col style="width: 33%" /><col style="width: 57%" /></colgroup><thead><tr><th>返回值类型</th><th>方法名及形参列表</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭此文件输出流并释放与此流有关的所有系统资源。</td></tr><tr><td><code>void</code></td><td><code>write(int b)</code></td><td>将指定字节写入此文件输出流。</td></tr><tr><td><code>void</code></td><td><code>write(byte[] b)</code></td><td>将 <code>b.length</code> 个字节从指定 byte数组写入此文件输出流中。</td></tr><tr><td><code>void</code></td><td><code>write(byte[] b, int off, int len)</code></td><td>将指定 byte 数组中从偏移量 <code>off</code> 开始的 <code>len</code>个字节写入此文件输出流。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;e:\\output.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//写入一个字节</span></span><br><span class="line">        out.write(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        <span class="comment">//写入多个字节</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World!王勤磊&quot;</span>);</span><br><span class="line">        out.write(str.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件拷贝">文件拷贝</h3><p>思路分析：</p><ol type="1"><li>创建文件的输入流，将文件读入到程序</li><li>创建文件输出流，将读取到的文件数据，写入到指定文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将C:\Users\wq3stone\Pictures\tx.jpg拷贝到e:\JavaFileBuf\copy.jpg</span></span><br><span class="line"><span class="comment">//        思路分析：</span></span><br><span class="line"><span class="comment">//        1. 创建文件的输入流，将文件读入到程序</span></span><br><span class="line"><span class="comment">//        2. 创建文件输出流，将读取到的文件数据，写入到指定文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\wq3stone\\Pictures\\tx.jpg&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;e:\\JavaFileBuf\\copy.jpg&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5096</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((readLen=in.read(buf)) != -<span class="number">1</span>)</span><br><span class="line">            out.write(buf,<span class="number">0</span>,readLen);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filereader字符输入流">FileReader：字符输入流</h3><h4 id="构造方法-2">构造方法</h4><ul><li><code>new FileReader(File file)</code>在给定从中读取数据的<code>File</code> 的情况下创建一个新 <code>FileReader</code>。</li><li><code>new FileReader(String fileName)</code>在给定从中读取数据的文件名的情况下创建一个新<code>FileReader</code>。</li></ul><h4 id="方法摘要-2">方法摘要</h4><table><colgroup><col style="width: 10%" /><col style="width: 45%" /><col style="width: 44%" /></colgroup><thead><tr><th>返回值类型</th><th>方法名及形参列表</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>read()</code></td><td>读取单个字符。</td></tr><tr><td><code>int</code></td><td><code>read(char[] cbuf)</code></td><td>批量读取多个字符到数组，返回读取到的字符数</td></tr><tr><td><code>int</code></td><td><code>read(char[] cbuf, int offset, int length)</code></td><td>将字符读入数组中的某一部分。</td></tr></tbody></table><p>相关API：</p><ul><li><code>new String(char[])</code>将<code>char[]</code>转换成<code>String</code></li><li><code>new String(char[],off,len)</code>将<code>char[]</code>指定部分转换成<code>String</code></li></ul><h5 id="错误的读取方式">错误的读取方式：</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world!wangqinlei王勤磊</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reader01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;e:\\JavaFileBuf\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">char</span> c[] = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">while</span>(file.read(c)!=-<span class="number">1</span>)</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出内容为：hello world!wangqinlei王勤磊inlei王勤</span></span><br></pre></td></tr></table></figure><p><font color="red">错误分析：每次均读取缓冲数组<code>char[]</code>中所有内容，存在上次读取后未清除的部分</font>第一次读取：</p><table><thead><tr><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th></tr></thead><tbody><tr><td style="text-align: center;">h</td><td style="text-align: center;">e</td><td style="text-align: center;">l</td><td style="text-align: center;">l</td><td style="text-align: center;">o</td><td style="text-align: center;"></td><td style="text-align: center;">w</td><td style="text-align: center;">o</td></tr></tbody></table><p>第二次读取：</p><table><thead><tr><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th></tr></thead><tbody><tr><td style="text-align: center;">r</td><td style="text-align: center;">l</td><td style="text-align: center;">d</td><td style="text-align: center;">!</td><td style="text-align: center;">w</td><td style="text-align: center;">a</td><td style="text-align: center;">n</td><td style="text-align: center;">g</td></tr></tbody></table><p>第三次读取：</p><table><thead><tr><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th></tr></thead><tbody><tr><td style="text-align: center;">q</td><td style="text-align: center;">i</td><td style="text-align: center;">n</td><td style="text-align: center;">l</td><td style="text-align: center;">e</td><td style="text-align: center;">i</td><td style="text-align: center;">王</td><td style="text-align: center;">勤</td></tr></tbody></table><p>第四次读取：</p><table><colgroup><col style="width: 2%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 14%" /><col style="width: 14%" /></colgroup><thead><tr><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th></tr></thead><tbody><tr><td style="text-align: center;">磊</td><td style="text-align: center;"><font color="red">i</font></td><td style="text-align: center;"><font color="red">n</font></td><td style="text-align: center;"><font color="red">l</font></td><td style="text-align: center;"><font color="red">e</font></td><td style="text-align: center;"><font color="red">i</font></td><td style="text-align: center;"><font color="red">王</font></td><td style="text-align: center;"><font color="red">勤</font></td></tr></tbody></table><p>因此输出结果为：<code>hello world!wangqinlei王勤磊inlei王勤</code></p><h5 id="正确的读取方式">正确的读取方式</h5><ol type="1"><li>使用<code>read()</code>逐个字符读取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reader02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;e:\\JavaFileBuf\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>((data=fileReader.read())!=-<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="type">char</span>)data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>使用<code>read(char[] buf)</code>批量读取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reader03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;e:\\JavaFileBuf\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="type">int</span> readLen;</span><br><span class="line">        <span class="keyword">while</span>((readLen=fileReader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readLen));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filewriter字符输出流">FileWriter：字符输出流</h3><h4 id="构造方法-3">构造方法</h4><ul><li><code>new FileWriter(File file/String fileName)</code>覆盖模式</li><li><code>new FileWriter(File file/String fileName , true)</code>追加模式</li></ul><h4 id="方法摘要-3">方法摘要</h4><table><colgroup><col style="width: 13%" /><col style="width: 50%" /><col style="width: 36%" /></colgroup><thead><tr><th>返回值类型</th><th>方法名及形参列表</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭此流，但要先刷新它</td></tr><tr><td><code>void</code></td><td><code>flush()</code></td><td>刷新该流的缓冲。</td></tr><tr><td><code>String</code></td><td><code>getEncoding()</code></td><td>返回此流使用的字符编码的名称</td></tr><tr><td><code>void</code></td><td><code>write(int c)</code></td><td>写入单个字符</td></tr><tr><td><code>void</code></td><td><code>write(char[] cbuf)</code></td><td>写入整个字符数组</td></tr><tr><td><code>void</code></td><td><code>write(char[] cbuf, int off, int len)</code></td><td>写入字符数组的某一部分</td></tr><tr><td><code>void</code></td><td><code>write(String str, int off, int len)</code></td><td>写入字符串的某一部分</td></tr><tr><td><code>void</code></td><td><code>write(String str)</code></td><td>写入整个字符串</td></tr></tbody></table><p>相关API：</p><ul><li><code>toCharArray</code>可将<code>String</code>转成<code>char[]</code></li></ul><p><strong><font color="red"><code>FileWriter</code>使用后，必须要关闭(close)或刷新(close)，否则写入不到指定文件</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Writer01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;e:\\JavaFileBuf\\writer.txt&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java你好123&quot;</span>);</span><br><span class="line">        fileWriter.write(<span class="number">97</span>);   <span class="comment">//a</span></span><br><span class="line">        fileWriter.write(<span class="string">&quot;你好&quot;</span>); <span class="comment">//你好</span></span><br><span class="line">        fileWriter.write(str,<span class="number">0</span>,<span class="number">4</span>);  <span class="comment">//Java</span></span><br><span class="line">        fileWriter.write(str.toCharArray());    <span class="comment">//Java你好123</span></span><br><span class="line">        fileWriter.write(str.toCharArray(),<span class="number">0</span>,<span class="number">5</span>);    <span class="comment">//Java你</span></span><br><span class="line">        fileWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Java日期类</title>
      <link href="/posts/17742.html"/>
      <url>/posts/17742.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一代日期类date">第一代日期类：Date</h2><h3 id="将日期转化成格式化的字符串">将日期转化成格式化的字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import java.util.Date;</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">// 创建一个日期Date对象</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(date);<span class="comment">// 将date对象格式化返回给format字符串</span></span><br><span class="line">System.out.println(format);<span class="comment">// 输出格式化的日期</span></span><br></pre></td></tr></table></figure><h3 id="将格式化的字符串转化成日期">将格式化的字符串转化成日期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">String s= <span class="string">&quot;2003年2月20日 10时20分30秒&quot;</span>;<span class="comment">// 格式化的字符串</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> sdf.parse(s);<span class="comment">// 将格式化的字符串转成日期对象返回给parse</span></span><br><span class="line">System.out.printLn(parse);<span class="comment">// 输出日期</span></span><br></pre></td></tr></table></figure><p><font color="red">String转Date时，使用的sdf格式需要和所给的String的格式一样，否则会抛出转换异常</font></p><blockquote><table><colgroup><col style="width: 3%" /><col style="width: 22%" /><col style="width: 33%" /><col style="width: 40%" /></colgroup><thead><tr><th style="text-align: center;">字母</th><th style="text-align: center;">日期或时间元素</th><th style="text-align: center;">表示</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr><td style="text-align: center;"><code>G</code></td><td style="text-align: center;">Era 标志符</td><td style="text-align: center;"><a href="#text">Text</a></td><td style="text-align: center;"><code>AD</code></td></tr><tr><td style="text-align: center;"><code>y</code></td><td style="text-align: center;">年</td><td style="text-align: center;"><a href="#year">Year</a></td><td style="text-align: center;"><code>1996</code>; <code>96</code></td></tr><tr><td style="text-align: center;"><code>M</code></td><td style="text-align: center;">年中的月份</td><td style="text-align: center;"><a href="#month">Month</a></td><td style="text-align: center;"><code>July</code>; <code>Jul</code>;<code>07</code></td></tr><tr><td style="text-align: center;"><code>w</code></td><td style="text-align: center;">年中的周数</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>27</code></td></tr><tr><td style="text-align: center;"><code>W</code></td><td style="text-align: center;">月份中的周数</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>2</code></td></tr><tr><td style="text-align: center;"><code>D</code></td><td style="text-align: center;">年中的天数</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>189</code></td></tr><tr><td style="text-align: center;"><code>d</code></td><td style="text-align: center;">月份中的天数</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>10</code></td></tr><tr><td style="text-align: center;"><code>F</code></td><td style="text-align: center;">月份中的星期</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>2</code></td></tr><tr><td style="text-align: center;"><code>E</code></td><td style="text-align: center;">星期中的天数</td><td style="text-align: center;"><a href="#text">Text</a></td><td style="text-align: center;"><code>Tuesday</code>;<code>Tue</code></td></tr><tr><td style="text-align: center;"><code>a</code></td><td style="text-align: center;">Am/pm 标记</td><td style="text-align: center;"><a href="#text">Text</a></td><td style="text-align: center;"><code>PM</code></td></tr><tr><td style="text-align: center;"><code>H</code></td><td style="text-align: center;">一天中的小时数（0-23）</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>0</code></td></tr><tr><td style="text-align: center;"><code>k</code></td><td style="text-align: center;">一天中的小时数（1-24）</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>24</code></td></tr><tr><td style="text-align: center;"><code>K</code></td><td style="text-align: center;">am/pm 中的小时数（0-11）</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>0</code></td></tr><tr><td style="text-align: center;"><code>h</code></td><td style="text-align: center;">am/pm 中的小时数（1-12）</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>12</code></td></tr><tr><td style="text-align: center;"><code>m</code></td><td style="text-align: center;">小时中的分钟数</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>30</code></td></tr><tr><td style="text-align: center;"><code>s</code></td><td style="text-align: center;">分钟中的秒数</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>55</code></td></tr><tr><td style="text-align: center;"><code>S</code></td><td style="text-align: center;">毫秒数</td><td style="text-align: center;"><a href="#number">Number</a></td><td style="text-align: center;"><code>978</code></td></tr><tr><td style="text-align: center;"><code>z</code></td><td style="text-align: center;">时区</td><td style="text-align: center;"><a href="#timezone">General timezone</a></td><td style="text-align: center;"><code>Pacific Standard Time</code>;<code>PST</code>; <code>GMT-08:00</code></td></tr><tr><td style="text-align: center;"><code>Z</code></td><td style="text-align: center;">时区</td><td style="text-align: center;"><a href="#rfc822timezone">RFC 822 timezone</a></td><td style="text-align: center;"><code>-0800</code></td></tr></tbody></table></blockquote><h2 id="第二代日期类calendar">第二代日期类：Calendar</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">// 创建日期对象，不可以使用new因为Calendar是抽象类</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;年:&quot;</span> +c.get(Calendar.YEAR));</span><br><span class="line">System.out.println(<span class="string">&quot;月:&quot;</span> +(c.get(Calendar.MONTH)+<span class="number">1</span>));<span class="comment">// 月是从0开始编号</span></span><br><span class="line">System.out.println(<span class="string">&quot;日:&quot;</span> +c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;小时:&quot;</span> +c.get(Calendar.HOUR));<span class="comment">// 输出12小时制的时</span></span><br><span class="line">System.out.println(<span class="string">&quot;小时:&quot;</span> +c.get(Calendar.HOUR_OF_DAY));<span class="comment">// 输出24小时制的时</span></span><br><span class="line">System.out.println(<span class="string">&quot;分钟:&quot;</span> +c.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒:&quot;</span> + c.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure><h2 id="第三代日期类">第三代日期类：</h2><h3 id="前两代日期类的不足">前两代日期类的不足</h3><p>JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calendar类之后被弃用了。而Calendar也存在问题是:1. 可变性：像日期和时间这样的类应该是不可变的 2.偏移性：Date中的年份是从1900开始的，而月份都从0开始 3.格式化：格式化只对Date有用，Calendar则不行 4.它们不是线程安全的，不能处理闰秒等（每隔2天，多出1秒）</p><h3 id="第三代日期类对象的创建">第三代日期类对象的创建</h3><ul><li>LocalDateTime包含日期+时间字段</li><li>LocalDate只包含日期字段</li><li>LocalTime只包含时间字段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();<span class="comment">// 返回当前时刻日期时间对象</span></span><br><span class="line">ldt.getYear();</span><br><span class="line">ldt.getMonthValue();</span><br><span class="line">ldt.getMonth();<span class="comment">// 返回纯大写英文月份</span></span><br><span class="line">ldt.getDayOfMonth();</span><br><span class="line">ldt.getHour();</span><br><span class="line">ldt.getMinute();</span><br><span class="line">ldt.getSecond();</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">lt</span> <span class="operator">=</span> LocalTime.now();</span><br></pre></td></tr></table></figure><h3 id="格式日期类">格式日期类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(format);</span><br></pre></td></tr></table></figure><h2 id="时间戳">时间戳</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();    <span class="comment">// 通过静态方法now()获取当前时间戳对象</span></span><br><span class="line">System.out.println(instant);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> Date.from(instant);    <span class="comment">// 通过from方法将Instant转成Date</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> date1.toInstant();   <span class="comment">// 通过toInstant方法将Date转成Instant</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Java常用的文件操作</title>
      <link href="/posts/39094.html"/>
      <url>/posts/39094.html</url>
      
        <content type="html"><![CDATA[<h3 id="创建文件对象">创建文件对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String pathname) <span class="comment">//根据路径创建一个File对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(File parent,String child) <span class="comment">//根据父目录文件+子路径创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String parent,String child) <span class="comment">//根据父目录+子路径创建</span></span><br><span class="line"></span><br><span class="line">f.createNewFile();<span class="comment">// 创建文件</span></span><br></pre></td></tr></table></figure><h3 id="获取文件的相关信息">获取文件的相关信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(...);</span><br><span class="line">System.out.println(<span class="string">&quot;文件名字：&quot;</span>+file.getName());</span><br><span class="line">System.out.println(<span class="string">&quot;文件的绝对路径：&quot;</span> + file.getAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;文件的父级目录：&quot;</span> + file.getParentFile());</span><br><span class="line">System.out.println(<span class="string">&quot;文件的大小：&quot;</span> + file.length());</span><br><span class="line">System.out.println(<span class="string">&quot;文件是否存在：&quot;</span> + file.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;是不是一个文件&quot;</span> + file.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;是不是一个目录&quot;</span> + file.isDirectory());</span><br></pre></td></tr></table></figure><h3 id="目录的操作和文件删除">目录的操作和文件删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">dirPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(...);</span><br><span class="line">dirPath.mkdir();<span class="comment">// 创建一级目录</span></span><br><span class="line">dirPath.mkdirs();<span class="comment">// 创建多级目录</span></span><br><span class="line">dirPath.delete();<span class="comment">// 删除目录</span></span><br><span class="line"><span class="comment">// 以上操作均有返回值 成功(true) 失败(false)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Java异常Throwable类</title>
      <link href="/posts/60327.html"/>
      <url>/posts/60327.html</url>
      
        <content type="html"><![CDATA[<p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202211021503341.jpg" /></p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202211021503343.jpeg" /></p><h2 id="异常介绍">异常介绍</h2><p>异常分为Error和Exception两种类型。</p><h3 id="error">Error</h3><p>Error是Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。</p><h3 id="exception">Exception</h3><p>Exception是因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。</p><p>Exception又可分为Check Exception和Uncheck Exception</p><h4 id="check-exception">Check Exception</h4><p>编译时出现的异常</p><ol type="1"><li><p>SQLException</p><p>操作数据库时，查询表可能发生的异常</p></li><li><p>IOException</p><p>操作文件时发生的异常</p></li><li><p>FileNotFoundException</p><p>当操作一个不存在的文件时发生的异常</p></li><li><p>ClassNotFoundException</p><p>加载一个不存在的类时发生的异常</p></li><li><p>EOFException</p><p>操作文件到文件末尾时发生的异常</p></li><li><p>IllegalArgumentException</p><p>参数异常</p></li></ol><h4 id="uncheck-exception">Uncheck Exception</h4><p>运行时出现的异常</p><ol type="1"><li><p>NullPointerException 空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;name.length&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>ArithmeticException 数学运算异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>ArrayIndexOutOfBoundsException 数组下标越界异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li><li><p>ClassCastException 类型转换异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//向上转型</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> (B)b1;<span class="comment">//向下转型</span></span><br><span class="line"><span class="type">C</span> <span class="variable">c1</span> <span class="operator">=</span> (C)b;<span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>NumberFormatException 数字格式异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> <span class="string">&quot;www&quot;</span>; System.out.println(Integer.parseInt(name2));</span><br></pre></td></tr></table></figure></li></ol><h3 id="基本语法">基本语法</h3><p>IDEA快捷键：<code>Ctrl + Alt + T</code></p><h4 id="try-catch-finally">try-catch-finally</h4><p>程序员在代码中捕获发生的异常，自行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能有异常的代码块</span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型 异常对象名) &#123;</span><br><span class="line">    捕获到异常后要执行的代码块</span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型 异常对象名) &#123;</span><br><span class="line">    捕获到异常后要执行的代码块</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    无论有无异常都要执行的代码块，可以关闭连接、释放资源等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理机制：</strong></p><ol type="1"><li>当异常发生时，异常代码后面的代码不再执行</li><li>系统将异常封装成Exception对象e，传递给catch</li><li>得到异常对象后，程序员自行处理</li><li>如果没有发生异常，catch代码块不执行</li></ol><p>注意：</p><ol type="1"><li>存在try-finally方式，不处理异常，程序会直接崩溃</li><li>存在多个catch用于处理不同的业务逻辑。但是子类异常要写在前面，父类异常写在后面。</li></ol><p>小练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    System.out.print(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num = Integer.parseInt(sc.next());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;你输入的不是整数，请重新输入：&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;你输入的整数是：&quot;</span>+num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="throws">throws</h4><ul><li><p>如果一个方法中的语句执行时可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理,而由该方法的调用者负责处理。</p></li><li><p>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p></li></ul><p><strong>处理机制：</strong></p><p>从最底层一层层往上throws</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">    f2(); <span class="comment">//不会报错，因为f2()抛出的运行异常，有默认处理机制</span></span><br><span class="line">    f3(); <span class="comment">//报错，因为f3()抛出的编译异常，f1()必须要处理这个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常">自定义异常</h3><p>应用实例</p><p>当我们接受Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常（要求继承RuntimeException）并给出提示信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">220</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(age &gt;= <span class="number">80</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的年龄在18-120之间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;你的年龄输入有误！&quot;</span>);</span><br><span class="line">        <span class="comment">//通过构造器，设置异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般情况下，自定义异常是继承RuntimeException即把自定义异常做成运行时异常，可以使用默认的处理机制，比较方便</p></blockquote><h3 id="throw和throws">throw和throws</h3><table><tr><td></td><td>意义</td><td>位置</td><td>后面跟</td></tr><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></table><h3 id="加深理解">加深理解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Important</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReturnExceptionDemo.methodA();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        ReturnExceptionDemo.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入方法A&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;制造异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用A方法的finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入方法B&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;调用B方法的finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入方法A</span><br><span class="line">用A方法的finally</span><br><span class="line">制造异常</span><br><span class="line">进入方法B</span><br><span class="line">调用B方法的finally</span><br></pre></td></tr></table></figure><p>IDEA格式化代码快捷键：<code>Ctrl + Alt + Shift + L</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】xml学习笔记</title>
      <link href="/posts/11539.html"/>
      <url>/posts/11539.html</url>
      
        <content type="html"><![CDATA[<h3 id="xml概念">XML概念</h3><p>XML：eXtensible Markup Language，可扩展标记语言 -可扩展：标签都是自定义的 - 功能 1.存储数据，可作为小型数据库，存储配置文件 2.数据传输，可在不兼容的系统之间轻松地交换数据</p><p>XML与HTML的区别：</p><ol type="1"><li>xml标签都是自定义的，html标签是预定义</li><li>xml语法严格，html语法松散</li><li>xml是存储数据的，html是展示数据</li></ol><h3 id="xml语法">XML语法</h3><h4 id="基本语法">基本语法</h4><ol type="1"><li>xml文档的后缀名是 <code>*.xml</code></li><li>若有文档声明，则必须放在第一行，不然报错</li><li>xml文档中有且仅有一个根标签</li><li>属性值必须使用单或双引号引起来</li><li>标签必须正确关闭</li><li>xml标签名称区分大小写</li><li>标签名属性名不能以数字或者标点符号开始，不能包含空格，不能以字符“xml”（含大小写）开头</li><li>元素需要正确嵌套不能交叉</li><li>特殊字符使用实体（只有以下五种）<ul><li><code>&amp;lt;</code> &lt;</li><li><code>&amp;gt;</code> &gt;</li><li><code>&amp;amp;</code> &amp;</li><li><code>&amp;quot;</code> ”</li><li><code>&amp;apos;</code> ’</li></ul></li></ol><p><strong>sample-xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】ArrayList学习</title>
      <link href="/posts/8928.html"/>
      <url>/posts/8928.html</url>
      
        <content type="html"><![CDATA[<p>ArrayList的底层操作机制</p><ul><li>ArrayList中维护了一个Object类型的数组elementData.<ul><li>transient Object[] elementData</li></ul></li><li>当创建ArrayList对象时，如果使用的无参构造器，则初始elementData容量为0，第一次添加，则扩容为10，如果需要再次扩容，则扩容为1.5倍</li><li>当创建ArrayList对象时，如果使用的有参构造器，则初始elementData容量为传入的参数大小，如果需要再次扩容，则扩容为1.5倍</li></ul><p>ArrayList注意事项：</p><ul><li>ArrayList可以加入null空元素，并且多个</li><li>ArrayList是由数组来实现数据存储的</li><li>ArrayList基本等同于Vector<ul><li>ArrayList是线程不安全，但执行效率高</li><li>多线程不建议使用ArrayList</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Collection方法</title>
      <link href="/posts/2488.html"/>
      <url>/posts/2488.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionMethod</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//        add:添加单个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;wq3stone&quot;</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);   <span class="comment">//自动装箱 list.add(new Integer(5))</span></span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);     <span class="comment">// list=[wq3stone, 5, true]</span></span><br><span class="line"><span class="comment">//        remove:删除指定元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);   <span class="comment">//删除第一个元素，返回第一个元素的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);     <span class="comment">// list=[5, true]</span></span><br><span class="line">        list.remove(<span class="literal">true</span>);  <span class="comment">//删除值为true的元素，返回一个布尔值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);     <span class="comment">// list=[5]</span></span><br><span class="line"><span class="comment">//        contains:查找元素是否存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//        size:获取元素个数</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"><span class="comment">//        isEmpty:判断是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());</span><br><span class="line"><span class="comment">//        clear:清空</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(list.isEmpty());</span><br><span class="line"><span class="comment">//        addAll:添加多个元素</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;new_element1&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;new_element2&quot;</span>);</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        containsAll:查找多个元素是否都存在</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list3.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(list.containsAll(list3));</span><br><span class="line"><span class="comment">//        removeAll:删除多个元素</span></span><br><span class="line">        list.removeAll(list2);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Iterator迭代器</title>
      <link href="/posts/50555.html"/>
      <url>/posts/50555.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        hasNext: 判断是否有下一个元素</span></span><br><span class="line"><span class="comment">//        next: 指针后移并返回当前元素</span></span><br><span class="line"><span class="comment">//        remove: 删除指针当前指向的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;西游记&quot;</span>,<span class="string">&quot;吴承恩&quot;</span>,<span class="number">44.6</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>,<span class="number">38.9</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;水浒传&quot;</span>,<span class="string">&quot;罗贯中&quot;</span>,<span class="number">66.6</span>));</span><br><span class="line">        System.out.println(col);</span><br><span class="line">        <span class="comment">/* 遍历这个列表 */</span></span><br><span class="line">        <span class="comment">// 1. 先得到col对应的迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> col.iterator();</span><br><span class="line">        <span class="comment">// 2. 使用while循环遍历即可，快捷键itit</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();    <span class="comment">// 返回的是Object对象</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 当退出while循环后，这时迭代器it指向最后的元素</span></span><br><span class="line"><span class="comment">//        it.next();  //报错 NoSuchElementException</span></span><br><span class="line">        <span class="comment">// 4. 想再次遍历，需要重置迭代器</span></span><br><span class="line">        it = col.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String author;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Java增强型for循环</title>
      <link href="/posts/11635.html"/>
      <url>/posts/11635.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhanceFor</span> &#123;</span><br><span class="line">    <span class="comment">// 增强for底层是简化版的迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;西游记&quot;</span>,<span class="string">&quot;吴承恩&quot;</span>,<span class="number">44.6</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>,<span class="number">38.9</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;水浒传&quot;</span>,<span class="string">&quot;罗贯中&quot;</span>,<span class="number">66.6</span>));</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> col.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用增强for迭代器 快捷键 I</span></span><br><span class="line">        <span class="keyword">for</span>(Object book : col)&#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增强for遍历数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】List接口方法</title>
      <link href="/posts/24668.html"/>
      <url>/posts/24668.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;贾宝玉&quot;</span>);</span><br><span class="line">        <span class="comment">// add(int index, Object element) 插入</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;亦晓白&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// get(int index) 获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">2</span>));</span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;亦晓白&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;marry&quot;</span>);</span><br><span class="line">        <span class="comment">// addAll(int index, Collection elements) 从index位置插入elements中的所有元素</span></span><br><span class="line">        list.addAll(<span class="number">1</span>,list2);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// indexOf(Object obj) 返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;亦晓白&quot;</span>));</span><br><span class="line">        <span class="comment">// lastIndexOf(Object obj) 返回obj在集合中末次出现的位置</span></span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;亦晓白&quot;</span>));</span><br><span class="line">        <span class="comment">// remove(int index) 移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        System.out.println(list.remove(<span class="number">1</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// remove(Object obj) 删除第一个obj元素</span></span><br><span class="line">        list.remove(<span class="string">&quot;亦晓白&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// set(int index,Object obj) 设置index位置元素为obj</span></span><br><span class="line">        list.set(<span class="number">1</span>,<span class="string">&quot;替换&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// subList(int fromIndex, int toIndex) 返回从fromIndex到toIndex-1的子集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">retList</span> <span class="operator">=</span> list.subList(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(retList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】三元运算符更深一步的理解</title>
      <link href="/posts/13345.html"/>
      <url>/posts/13345.html</url>
      
        <content type="html"><![CDATA[<p>在使用三元运算符的时候，要把三元运算符当做一个整体，返回值的时候，取精度高的那个返回。</p><p>例如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">true</span>?<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>):<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 输出结果为<code>1.0</code>而非<code>1</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】OJ术语</title>
      <link href="/posts/22232.html"/>
      <url>/posts/22232.html</url>
      
        <content type="html"><![CDATA[<p><strong>AC-Accepted 答案正确/通过</strong></p><p><strong>WA-Wrong Answer 答案错误</strong></p><p><strong>RE-Runtime Error 运行时错误</strong></p><p><strong>CE-Complie Error 编译错误</strong></p><p><strong>TLE-Time Limit Exceed 运行超时</strong></p><p><strong>MLE-Memory Limit Exceed 超出内存限制</strong></p><p><strong>PE-Presentation Error 格式错误</strong></p><p><strong>OLE-Output Limit Exceed 输出超出限制/输出超限</strong></p><p><strong>补充一个</strong></p><p><strong>UKE_Unknown Error未知错误</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OJ术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】JavaScript笔记</title>
      <link href="/posts/59091.html"/>
      <url>/posts/59091.html</url>
      
        <content type="html"><![CDATA[<h1 id="javascript的引入">JavaScript的引入</h1><h2 id="内部引入">内部引入</h2><p>将JS代码写在<code>&lt;script&gt;</code>与<code>&lt;/script&gt;</code>标签之间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>那些老旧的实例可能会在 <code>&lt;script&gt;</code>标签中使用type=“text/javascript”。现在已经不必这样做了。JavaScript是所有现代浏览器以及 HTML5 中的默认脚本语言。</p></blockquote><h2 id="外部引入">外部引入</h2><p>可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p><p>外部 JavaScript 文件的文件扩展名是 .js。</p><p>如需使用外部文件，请在 <code>&lt;script&gt;</code> 标签的 “src”属性中引入该 js 文件：</p><p>test.js <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>test.html <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="javascript的输出">JavaScript的输出</h1><p>JavaScript 可以通过不同的方式来输出数据：</p><ul><li>使用 <strong>window.alert()</strong> 弹出警告框。</li><li>使用 <strong>document.write()</strong> 方法将内容写到 HTML文档中。</li><li>使用 <strong>innerHTML</strong> 写入到 HTML 元素。</li><li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li></ul><h2 id="使用window.alert">使用window.alert()</h2><p>出现在浏览器上的弹窗，类似于警告框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;Hello World!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开网站，弹出对话框</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202211051710937.png"alt="Hello World" /><figcaption aria-hidden="true">Hello World</figcaption></figure><h2 id="操作html元素">操作HTML元素</h2><p>从 JavaScript 访问某个 HTML 元素，可以使用document.getElementById(<em>id</em>) 方法。</p><p>使用 “id” 属性来标识 HTML 元素，并使用 innerHTML来获取或插入元素内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个 Web 页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;段落已修改。&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202211051719101.png"alt="运行结果" /><figcaption aria-hidden="true">运行结果</figcaption></figure>以上 JavaScript 语句（在<script><p>标签中）可以在 web 浏览器中执行：</p><ul><li><p><strong>document.getElementById(“demo”)</strong> 是使用 id属性来查找 HTML 元素的 JavaScript 代码 。</p></li><li><p><strong>innerHTML = “段落已修改。”</strong> 是用于修改元素的 HTML内容(innerHTML)的 JavaScript 代码。</p></li></ul><blockquote><p>请使用 document.write() 仅仅向文档输出写内容。</p><p>如果在文档已完成加载后执行 document.write，整个 HTML页面将被覆盖。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个 Web 页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Date</span>());</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202211051727071.png"alt="image-20221105172739735" /><figcaption aria-hidden="true">image-20221105172739735</figcaption></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个 Web 页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Date</span>());</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202211051728398.png"alt="image-20221105172828870" /><figcaption aria-hidden="true">image-20221105172828870</figcaption></figure><p>单击“点我”按钮，会将原有的文字覆盖。</p><h2 id="写到控制台">写到控制台</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个 Web 页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">a = <span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript">b = <span class="number">6</span>;</span></span><br><span class="line"><span class="language-javascript">c = a + b;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202211051732355.png"alt="image-20221105173221210" /><figcaption aria-hidden="true">image-20221105173221210</figcaption></figure><h1 id="javascript语法">JavaScript语法</h1><ol type="1"><li><p>定义变量<code>var 变量名 = 变量值</code></p></li><li><p>条件控制：与Java语法一致</p></li><li><p>浏览器弹窗<code>alert()</code></p></li><li><p>控制台输出<code>console()</code></p></li></ol><h3 id="数据类型">数据类型</h3><h4 id="数值">数值</h4><p>JS不区分小数和整数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span><span class="comment">//整数123</span></span><br><span class="line"><span class="number">123.1</span><span class="comment">//浮点数123.1</span></span><br><span class="line"><span class="number">1.123e5</span><span class="comment">//科学计数法</span></span><br><span class="line">-<span class="number">123</span><span class="comment">//负数</span></span><br><span class="line"><span class="title class_">NaN</span><span class="comment">//Not a Number</span></span><br><span class="line"><span class="title class_">Infinity</span><span class="comment">//表示无限大</span></span><br></pre></td></tr></table></figure><p>尽量避免使用浮点数进行运算，会存在精度问题！</p><h4 id="字符串">字符串</h4><h5 id="基本字符">基本字符</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="转义字符">转义字符</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\&#x27;&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;\t&quot;</span></span><br><span class="line"><span class="string">&quot;\u4e2d&quot;</span><span class="comment">//Unicode字符</span></span><br><span class="line"><span class="string">&quot;\x41&quot;</span><span class="comment">//ASCII字符</span></span><br></pre></td></tr></table></figure><h5 id="多行字符串">多行字符串</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">`</span></span><br><span class="line"><span class="string">Hello,</span></span><br><span class="line"><span class="string">Nihao,</span></span><br><span class="line"><span class="string">亦晓白</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h5 id="模板字符串">模板字符串</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;亦晓白&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">`你好，<span class="subst">$&#123;name&#125;</span>`</span>;<span class="comment">// 你好，亦晓白</span></span><br></pre></td></tr></table></figure><h5 id="字符串的属性和方法">字符串的属性和方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;student&quot;</span>;</span><br><span class="line">str.<span class="property">length</span><span class="comment">//字符串长度</span></span><br><span class="line">str[i]<span class="comment">//作为数组使用获取第i+1个元素</span></span><br><span class="line">str.<span class="title function_">toUpperCase</span>()<span class="comment">//转成大写</span></span><br><span class="line">str.<span class="title function_">toLowerCase</span>()<span class="comment">//转成小写</span></span><br><span class="line">str.<span class="title function_">indexOf</span>(<span class="string">&quot;c&quot;</span>)<span class="comment">//获取首个字符c的索引</span></span><br><span class="line">str.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;c&quot;</span>)<span class="comment">//获取最后一个字符c的索引</span></span><br><span class="line">str.<span class="title function_">substring</span>(num)<span class="comment">//获取从num到最后一个位置的字符串</span></span><br><span class="line">str.<span class="title function_">substring</span>(start,end)<span class="comment">//获取从start到end位置的字符串</span></span><br></pre></td></tr></table></figure><h4 id="布尔值">布尔值</h4><p><code>true</code> <code>false</code></p><h4 id="数组">数组</h4><p>Array可以包含任意的数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数组使用中括号[]</span></span><br><span class="line"><span class="keyword">var</span> arr[<span class="number">1</span>,<span class="string">&quot;abc&quot;</span>,<span class="number">1.2</span>,<span class="literal">false</span>];</span><br></pre></td></tr></table></figure><h5 id="数组的属性和方法">数组的属性和方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="property">length</span><span class="comment">//获取数组的长度</span></span><br><span class="line"><span class="comment">// 假如给arr.length赋值，数组大小就会发生变化</span></span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="number">2</span>)<span class="comment">//获取数组索引为2的元素</span></span><br><span class="line">arr.<span class="title function_">slice</span>()<span class="comment">//截取arr的一部分，返回一个新数组，类似字符串的substring方法</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">push</span>()<span class="comment">//压入新元素到数组尾部</span></span><br><span class="line">arr.<span class="title function_">pop</span>()<span class="comment">//弹出数组尾部元素</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">unshift</span>()<span class="comment">//压入新元素到数组头部</span></span><br><span class="line">arr.<span class="title function_">shift</span>()<span class="comment">//弹出数组头部元素</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>()<span class="comment">//给数组排序并返回新数组</span></span><br><span class="line">arr.<span class="title function_">reverse</span>()<span class="comment">//数组反转并返回新数组</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">concat</span>(newarr)<span class="comment">//在数组尾部添加新数组元素并返回新数组</span></span><br><span class="line"><span class="comment">/* 注意：concat()并没有修改数组，只是会返回一个新数组 */</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">join</span>(str)<span class="comment">//使用str字符串拼接数组</span></span><br></pre></td></tr></table></figure><h4 id="对象">对象</h4><p>若干个键值对组成的变量。 所有的键都是字符串，值是任意对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">    属性名: 属性值,</span><br><span class="line">    属性名: 属性值,</span><br><span class="line">    属性名: 属性值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;wq3stone&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">19</span>,</span><br><span class="line"><span class="attr">tags</span>:[<span class="string">&quot;JS&quot;</span>,<span class="string">&quot;HTML&quot;</span>,<span class="string">&quot;Python&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象属性的动态增删">对象属性的动态增删</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.<span class="property">haha</span> = <span class="string">&quot;haha&quot;</span>;<span class="comment">//增加person的haha属性</span></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">tags</span><span class="comment">//删除person对象的tags属性</span></span><br></pre></td></tr></table></figure><h5 id="判断对象中是否存在某个属性">判断对象中是否存在某个属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;age&quot;</span> <span class="keyword">in</span> person;<span class="comment">//true</span></span><br><span class="line"><span class="string">&quot;toString&quot;</span> <span class="keyword">in</span> person;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5id="判断一个属性是否是这个对象自身拥有的">判断一个属性是否是这个对象自身拥有的</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;toString&quot;</span>);<span class="comment">//false</span></span><br><span class="line">person.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;age&quot;</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="map和set">Map和Set</h4><blockquote><p>ES6的新特性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;tom&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;jack&#x27;</span>,<span class="number">20</span>],[<span class="string">&#x27;jerry&#x27;</span>,<span class="number">30</span>]]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&#x27;tom&#x27;</span>));<span class="comment">// 10</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;admin&#x27;</span>,<span class="number">12345</span>);<span class="comment">//新增或修改元素</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;tom&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&#x27;tom&#x27;</span>));<span class="comment">// 20</span></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;jack&#x27;</span>);<span class="comment">// 删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);<span class="comment">// Set可以去重</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);<span class="comment">//添加元素</span></span><br><span class="line">set.<span class="title function_">delete</span>(<span class="number">1</span>);<span class="comment">//删除元素</span></span><br><span class="line">set.<span class="title function_">has</span>(e)<span class="comment">//判断有无e元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="iterator">iterator</h4><h5 id="遍历数组">遍历数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">// 4,5,6 打印的是元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">// 0,1,2 打印的是下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历map">遍历map</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;tom&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;jack&#x27;</span>,<span class="number">20</span>],[<span class="string">&#x27;jerry&#x27;</span>,<span class="number">30</span>]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">// [&#x27;tom&#x27;,10] [&#x27;jack&#x27;,20] [&#x27;jerry&#x27;,30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历set">遍历set</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> set)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">// 5 6 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符">运算符</h3><h4 id="逻辑运算符">逻辑运算符</h4><p><code>&amp;&amp;</code> ==&gt; 与运算 <code>||</code> ==&gt; 或运算<code>!</code> ==&gt; 取反运算</p><h4 id="比较运算符">比较运算符</h4><p><code>==</code> 等于（类型不一样，值一样，结果为true）<code>===</code> 绝对等于（类型一样，值一样，结果为true）</p><ul><li>NaN===NaN，这个与所有的数值都不相等，包括自己</li><li>只能通过<code>isNaN()</code>来判断这个数是否是NaN</li></ul><h3 id="流程控制">流程控制</h3><p>和Java一致，多了for…in循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3.2</span>,<span class="string">&quot;a&quot;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">in</span> nums)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(nums[num]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="严格检查模式">严格检查模式</h2><p><code>'use strict'</code>代表严格检查模式，预防JavaScript的随意性导致产生的一些问题，必须写在js的第一行</p><p>局部变量建议使用<code>let</code>去定义</p><h2 id="函数">函数</h2><h3 id="定义函数">定义函数</h3><blockquote><p>定义方式1</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params">X</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义方式2</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手动抛出异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x!= <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;Not a Number&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(X&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>arguments 是JS免费赠送的一个关键字它代表传递进来的所有的参数，是一个数组。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x=&gt;&quot;</span>+x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>rest用于获取除了已经定义的参数之外的参数</p></blockquote><p>以前：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>&gt;<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在：ES6新特性rest</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aaa</span>(<span class="params">x,y,...rest</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x=&gt;&quot;</span>+x);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;y=&gt;&quot;</span>+y);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量的作用域">变量的作用域</h3><p>在js中，var定义的变量是有作用域的。假设在函数体中声明，则在函数体外不可以使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = x + <span class="number">2</span>;<span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>全局对象 window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>(x);</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">window</span>.<span class="property">x</span>);</span><br></pre></td></tr></table></figure><p>alert()这个函数本身也是一个window全局函数</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Java动态绑定</title>
      <link href="/posts/9845.html"/>
      <url>/posts/9845.html</url>
      
        <content type="html"><![CDATA[<h4 id="程序绑定">程序绑定</h4><p>程序绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定</p><h4 id="静态绑定">静态绑定</h4><blockquote><p>静态绑定（前期绑定）：在程序执行前方法已经被绑定。</p></blockquote><p>在编译过程中就已经知道这个方法到底是哪个类中的方法，此时由编译器或其它连接程序实现。例如：C。针对java简单的可以理解为程序编译期的绑定；java当中的方法只有final，static，private和构造方法是前期绑定(如果一个方法不可被继承或者继承后不可被覆盖，那么这个方法就采用的静态绑定。)</p><h4 id="动态绑定">动态绑定</h4><blockquote><p>动态绑定（后期绑定）：在运行时根据具体对象的类型进行绑定。</p></blockquote><p>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。动态绑定的过程：</p><blockquote><ol type="1"><li>虚拟机提取对象的实际类型的方法表</li><li>虚拟机搜索方法签名；</li><li>调用方法。</li></ol></blockquote><p><b>属性是静态绑定的</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;父亲属性&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">　　</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;儿子属性&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Father</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;调用的属性：&quot;</span> + sample.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出的是父亲属性</p><p><b>方法是动态绑定的</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;FatherFatherFather&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;SonSonSon&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(sample.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码输出的是儿子属性</p><p>再来看一串代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">m(<span class="keyword">new</span> <span class="title class_">GraduateStudent</span>());</span><br><span class="line">m(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">m(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">m(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(Object o)</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(o.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraduateStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student</span><br><span class="line">Student</span><br><span class="line">Person</span><br><span class="line">java.lang.Object@7852e922</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>动态绑定体现了Java的继承与多态，在继承链中，JVM一直沿着继承链动态找到带有该方法的实现。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】HTML+CSS笔记</title>
      <link href="/posts/28197.html"/>
      <url>/posts/28197.html</url>
      
        <content type="html"><![CDATA[<h2 id="html">HTML</h2><h3 id="实体">实体</h3><blockquote><p>在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格。在有些时候，我们不能直接书写一些特殊符号，比如：多个连续的空格、大于号和小于号等</p></blockquote><p>如果我们需要在网页中书写这些特殊的符号，需要使用<code>html</code>中的实体：实体的语法为：<code>&amp;实体的名字</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&amp;nbsp;空格 </span></span><br><span class="line"><span class="comment">&amp;gt;大于号&gt;</span></span><br><span class="line"><span class="comment">&amp;lt;小于号&lt;</span></span><br><span class="line"><span class="comment">&amp;copy;版权符号©</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="meta标签">meta标签</h3><p>meta主要用于设置网页中的一些元数据（指定字符集、网页关键字、网页描述），元数据不是给用户看，而是给浏览器看的。基础用法：<code>&lt;meta name="名字" content="内容" /&gt;</code></p><h4 id="设置字符集">设置字符集</h4><p><code>&lt;meta charset="UTF-8" /&gt;</code></p><h4 id="设置关键字">设置关键字</h4><p><code>&lt;meta name="keywords" content="关键字,可用英文逗号分隔" /&gt;</code></p><h4 id="设置网页描述">设置网页描述</h4><p><code>&lt;meta name="description" content="网页描述" /&gt;</code></p><h4 id="网页重定向">网页重定向</h4><p><code>&lt;meta http-equiv="refresh" content="倒数秒数;url=网址" /&gt;</code></p><p>例如3秒后跳转到百度首页可以这样写：<code>&lt;meta http-equiv="refresh" content="3;url=https://www.baidu.com" /&gt;</code></p><h4 id="语义化标签">语义化标签</h4><p>在网页中HTML专门用来负责网页的结构，所以在使用html标签时，应该关注的是标签的语义，而不是它的样式</p><blockquote><p>在页面中独占一行的元素称为块元素（block element） -在网页中一般通过块元素来对页面进行布局</p></blockquote><blockquote><p>在页面中不会独占一行的元素称为行内元素（inline element） -行内元素主要用来包裹文字 -一般情况下会在块元素中放行内元素，而不会在行内元素中放块元素 -块元素中基本上什么都能放 - p元素中不能放任何的块元素</p></blockquote><blockquote><p>浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正。比如： -标签写在了根元素的外部 - p元素中嵌套了块元素 -根元素中出现了除head和body以外的子元素</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">h1~h6：标题标签</span></span><br><span class="line"><span class="comment">    &lt;h1&gt;一级标题&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">&lt;h2&gt;二级标题&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">    &lt;h3&gt;三级标题&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">    &lt;h4&gt;四级标题&lt;/h4&gt;</span></span><br><span class="line"><span class="comment">    &lt;h5&gt;五级标题&lt;/h5&gt;</span></span><br><span class="line"><span class="comment">    &lt;h6&gt;六级标题&lt;/h6&gt;</span></span><br><span class="line"><span class="comment">hgroup标签：标题分组标签，可以将一组相关的标题同时放入到hgroup</span></span><br><span class="line"><span class="comment">&lt;hgroup&gt;</span></span><br><span class="line"><span class="comment">    &lt;h1&gt;回乡偶书二首&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">    &lt;h2&gt;其一&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">    &lt;/hgroup&gt;</span></span><br><span class="line"><span class="comment">p标签：段落标记</span></span><br><span class="line"><span class="comment">&lt;p&gt;在p标签中的内容就表示一个段落&lt;/p&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;在p标签中的内容就表示一个段落&lt;/p&gt;</span></span><br><span class="line"><span class="comment">b标签：加粗标记</span></span><br><span class="line"><span class="comment">我这句话&lt;b&gt;很重要&lt;/b&gt;</span></span><br><span class="line"><span class="comment">q标签：引用标记</span></span><br><span class="line"><span class="comment">子曰&lt;q&gt;学而时习之，乐呵乐呵！&lt;/q&gt;</span></span><br><span class="line"><span class="comment">br标签：换行标记</span></span><br><span class="line"><span class="comment">这是第一行&lt;br&gt;这是第二行&lt;br&gt;这是第三行</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="布局标签">布局标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 布局标签（结构化语义标签）</span></span><br><span class="line"><span class="comment">    header 表示网页的头部</span></span><br><span class="line"><span class="comment">    main 表示网页的主体部分(一个页面中只会有一个main)</span></span><br><span class="line"><span class="comment">    footer 表示网页的底部</span></span><br><span class="line"><span class="comment">    nav 表示网页中的导航</span></span><br><span class="line"><span class="comment">    aside 和主体相关的其他内容（侧边栏）</span></span><br><span class="line"><span class="comment">    article 表示一个独立的文章</span></span><br><span class="line"><span class="comment">    section 表示一个独立的区块，上边的标签都不能表示时使用section</span></span><br><span class="line"><span class="comment">    div 没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素</span></span><br><span class="line"><span class="comment">    span 行内元素，没有任何的语义，一般用于在网页中选中文字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="列表">列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在html中也可以创建列表，html列表一共有三种：</span></span><br><span class="line"><span class="comment">    1、有序列表 ol li</span></span><br><span class="line"><span class="comment">    2、无序列表 ul li</span></span><br><span class="line"><span class="comment">    3、定义列表 dl dt dd</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    无序列表，使用ul标签来创建无序列表</span></span><br><span class="line"><span class="comment">    使用li表示列表项  </span></span><br><span class="line"><span class="comment">type属性可设置为：disc、square、circle</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    有序列表，使用ol标签来创建无序列表</span></span><br><span class="line"><span class="comment">    使用li表示列表项</span></span><br><span class="line"><span class="comment">type属性可设置为：A、a、i、I、1</span></span><br><span class="line"><span class="comment">start属性可设置一个数字n表示从序号n开始</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    定义列表，使用dl标签来创建一个定义列表</span></span><br><span class="line"><span class="comment">    使用dt来表示定义的内容</span></span><br><span class="line"><span class="comment">    使用dd来对内容进行解释说明</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    列表之间可以互相嵌套</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>火龙果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="超链接">超链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a标签 </span></span><br><span class="line"><span class="comment">超链接可以让我们从一个页面跳转到其他页面，或者是当前页面的其他的位置</span></span><br><span class="line"><span class="comment">&lt;a href=&quot;网址&quot;&gt;Obj&lt;/a&gt;</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">href 指定跳转的目标路径(相对路径或绝对路径)</span></span><br><span class="line"><span class="comment">target 指定超链接打开的位置</span></span><br><span class="line"><span class="comment">  _self  默认值 在当前页面中打开超链接</span></span><br><span class="line"><span class="comment">  _blank 在一个新的要么中打开超链接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">超链接是也是一个行内元素，在a标签中可以嵌套除它自身外的任何元素，文字图片等</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.wq3stone.cn&quot;</span>&gt;</span>亦晓白笔记<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.wq3stone.cn&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以使用 javascript:; 来作为href的属性，此时点击这个超链接什么也不会发生 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>这是一个新的超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">可以直接将超链接的href属性设置为#</span></span><br><span class="line"><span class="comment">这样点击超链接以后，页面不会发生跳转，而是转到当前页面的顶部的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以跳转到页面的指定位置，只需将href属性设置 #目标元素的id属性值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">id属性（唯一不重复的）</span></span><br><span class="line"><span class="comment">    - 每一个标签都可以添加一个id属性</span></span><br><span class="line"><span class="comment">    - id属性就是元素的唯一标识，同一个页面中不能出现重复的id属性    </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;top&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#bottom&quot;</span>&gt;</span>这是顶部，点击跳转到底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;bottom&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>这是底部，点击跳转到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;bottom&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这是底部，点击跳转到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片标签">图片标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">图片img标签用于向当前页面中引入一个图片</span></span><br><span class="line"><span class="comment">img这种元素属于替换元素（块和行内元素之间，具有两种元素的特点）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">  src 属性指定的是外部图片的路径（路径规则和超链接是一样的）</span></span><br><span class="line"><span class="comment">  alt 图片的描述，这个描述默认情况下不会显示，有些浏览器在图片无法加载时显示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  width 图片的宽度，单位为px</span></span><br><span class="line"><span class="comment">  height 图片的高度，单位为px</span></span><br><span class="line"><span class="comment">    宽度和高度中如果只修改了一个，则另一个会等比例缩放</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;提示文字&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内联框架">内联框架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">内联框架，用于向当前页面中引入一个其他页面</span></span><br><span class="line"><span class="comment">    src 指定要引入的网页的路径</span></span><br><span class="line"><span class="comment">    frameborder 指定内联框架的边框(inline)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.bilibili.com&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1920&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1080&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="音视频文件">音视频文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">audio 标签用来向页面中引入一个外部的音频文件的</span></span><br><span class="line"><span class="comment">音视频文件引入时，默认情况下不允许用户自己控制播放停止</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">  controls 是否允许用户控制播放</span></span><br><span class="line"><span class="comment">  autoplay 音频文件是否自动播放</span></span><br><span class="line"><span class="comment">    如果设置了autoplay 则音乐在打开页面时会自动播放，但是目前来讲大部分浏览器都不会自动对音乐进行播放</span></span><br><span class="line"><span class="comment">  loop 音乐是否循环播放  </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 除了通过src来指定外部文件的路径以外，还可以通过source来指定文件的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对不起，您的浏览器不支持播放音频！请升级浏览器！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.ogg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">使用video标签来向网页中引入一个视频，使用方式和audio基本上是一样的</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;视频地址&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 嵌入视频网站代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=516169242&amp;bvid=BV1Cg411a7JJ&amp;cid=850985179&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe src="//player.bilibili.com/player.html?aid=516169242&amp;bvid=BV1Cg411a7JJ&amp;cid=850985179&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="1080" height="720"></iframe><h2 id="css">CSS</h2><p>CSS有3种引用方式：</p><blockquote><p>内联样式（行内样式）：在标签内部通过style属 性来设置元素的样式</p></blockquote><p><code>&lt;p style="color:red;font-size:60px;"&gt;红色字体大小为30/p&gt;</code></p><p style="color:red;font-size:30px;">红色字体大小为30<p><blockquote><p>内部样式表：将样式编写到head种的style标签中，然后通过CSS的选择器来选中元素并为其设置各种样式。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">color</span>:green;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">font-size</span>: <span class="number">20</span>;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            绿色字体大小20px</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>外部样式表：可以将CSS样式编写到一个外部的CSS文件中，然后通过head中的link标签来引入外部的CSS文件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./style.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="css基本语法">CSS基本语法</h3><p><code>选择器 声明块</code></p><p>选择器，通过选择器可以选中页面中的指定元素，比如 p的作用就是选中页面中所有的p元素。</p><p>声明块：通过声明来指定要为元素设置的样式，声明块由一个一个的声明组成，声明是一个键值对结构，一个样式名对应一个样式值，键和值之间以英文冒号<font style="color:red;">:</font>连接</p><h3 id="常用选择器">常用选择器</h3><h4 id="元素选择器">元素选择器</h4><p>作用：根据标签名选中指定的元素 语法：标签名{}例子：<code>p&#123;&#125; h1&#123;&#125; div&#123;&#125;</code> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="id选择器">id选择器</h4><p>作用：根据元素的id属性值选中一个元素 语法：#id属性值{}例子：<code>#box&#123;&#125;  #red&#123;&#125;</code> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="类选择器">类选择器</h4><blockquote><p>class 是一个标签的属性，它和id类似，不同的是class可以重复使用可以通过class属性来为元素分组可以同时为一个元素指定多个class属性</p></blockquote><p>作用：根据元素的class属性值选中一组元素 语法：.class属性值{}例子：<code>.nav&#123;&#125;  .top&#123;&#125;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blue</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.abc</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通配选择器">通配选择器</h4><p>作用：选中页面中的所有元素 语法：<code>*&#123;&#125;</code></p><h3 id="复合选择器">复合选择器</h3><h4 id="交集选择器">交集选择器</h4><blockquote><p>交集选择器 作用：选中同时复合多个条件的元素语法：<code>选择器1选择器2选择器3选择器n&#123;&#125;</code>注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头示例：<code>div.red&#123;&#125;</code></p></blockquote><h4 id="并集选择器">并集选择器</h4><blockquote><p>并集选择器 作用：同时选择多个选择器对应的元素语法：<code>选择器1,选择器2,选择器3,选择器n&#123;&#125;</code>示例：<code>#b1,.p1,h1,span,div.red&#123;&#125;</code> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>复合选择器演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 将class为red的元素设置为红色（字体） */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.red</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 交集选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 将class为red的div字体大小设置为30px */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span><span class="selector-class">.red</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>:<span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"><span class="comment">/* 将class同时包含a和b和c的元素字体颜色设置为blue */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.a</span><span class="selector-class">.b</span><span class="selector-class">.c</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 并集选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 将h1元素和class属性为red的元素字体设置为绿色 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h1</span>,<span class="selector-class">.red</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>我是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>我是p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red2 a b c&quot;</span>&gt;</span>我是div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="关系选择器">关系选择器</h3><p>父元素：直接包含子元素的元素是父元素子元素：直接被父元素包含的元素是子元素祖先元素：直接或间接包含后代元素的元素是祖先元素后代元素：直接或间接被祖先元素包含的元素是后代元素兄弟元素：具有相同父元素的元素是兄弟元素</p><h4 id="子元素选择器">子元素选择器</h4><blockquote><p>作用：选中指定父元素指定子元素 语法：父元素&gt;子元素示例：<code>div.box&gt;span&#123;&#125;</code></p></blockquote><h4 id="后代元素选择器">后代元素选择器</h4><blockquote><p>作用：选中指定元素内的指定后代元素 语法：祖先 后代示例：<code>div span&#123;&#125;</code></p></blockquote><h4 id="兄弟元素选择器">兄弟元素选择器</h4><blockquote><p>选择下一个兄弟： 语法：<code>前一个 + 下一个</code>选择下边所有兄弟： 语法：<code>兄 ~ 弟</code></p></blockquote><h3 id="属性选择器">属性选择器</h3><blockquote><p>作用：选择含有特定属性的元素 语法：<code>[属性名] 选择含有指定属性的元素</code><code>[属性名=属性值] 选择含有指定属性和属性值的元素</code><code>[属性名^=属性值] 选择属性值以指定值开头的元素</code><code>[属性名$=属性值] 选择属性值以指定值结尾的元素</code><code>[属性名*=属性值] 选择属性值中含有某值的元素的元素</code>示例：<code>p[title="abc"]&#123;color=red&#125;</code></p></blockquote><h3 id="伪类选择器">伪类选择器</h3><h4 id="通用元素的伪类">通用元素的伪类</h4><blockquote><p>伪类，不存在的类，用于定义元素的特殊状态。 -设置鼠标悬停在元素上时的样式</p><ul><li><p>为已访问和未访问链接设置不同的样式</p></li><li><p>设置元素获得焦点时的样式</p></li></ul><p>比如：第一个子元素、被点击的元素、鼠标移入的元素等用法：伪类一般情况下都是使用英文冒号 : 开头 <code>:first-child</code>选择作为其父的首个子元素的每个元素 <code>:last-child</code>选择作为其父的最后一个子元素的每个元素 <code>:nth-child(i)</code>选择作为其父的第 i 个子元素的每个元素。 特殊值： n 全选 2n或eveb偶数位元素 2n+1或odd 奇数位元素 以上这些伪类都是根据所有的子元素进行排序<code>:only-child</code> 只有是子元素时才选中<code>:first-of-type</code> <code>:last-of-type</code><code>:nth-of-type()</code> <code>:only-of-type</code><code>:empty</code>这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序<code>:not()</code> 否定伪类，将符合条件的元素从选择器中去除</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>伪类选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">       <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n+<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(even)&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:first-of-type</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>))&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: yellowgreen;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第〇个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第四个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第五个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="a元素的伪类">a元素的伪类</h4><blockquote><p><code>:link</code> 选择所有未被访问的链接 <code>:visited</code>选择所有已访问的链接 <code>:hover</code> 选择鼠标悬停其上的链接<code>active</code> 选择活动（被点击）的链接</p></blockquote><h3 id="伪元素选择器">伪元素选择器</h3><blockquote><p>伪元素，不存在的元素，用于设置元素指定部分的样式。 例如，它可用于： -设置元素的首字母、首行的样式 - 在元素的内容之前或之后插入内容</p></blockquote><blockquote><p><code>::first-line</code> 伪元素用于向文本的首行添加特殊样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line"><span class="attribute">font-variant</span>: small-caps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>::first-letter</code> 伪元素用于向文本的首字母添加特殊样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line"><span class="attribute">font-size</span>: xx-large;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>::before</code> 伪元素可用于在元素内容之前插入一些内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">smiley.gif</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>::after</code> 伪元素可用于在元素内容之后插入一些内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">smiley.gif</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>::selection</code> 伪元素匹配用户选择的元素部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::selection</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red; </span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="样式的继承">样式的继承</h3><blockquote><p>CSS的某些样式是具有继承性的</p></blockquote><p><strong>继承</strong>是一种规则，样式不但可以应用于某个特定的html标签元素，还可以应用于其后代元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: brown;&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;</span><br><span class="line">    今天是</span><br><span class="line">    &lt;<span class="selector-tag">span</span>&gt;星期三&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure><p>如上代码所示的效果中，颜色不仅应用于p标签，还可以应用于span标签 <imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210121908328.png"alt="img" /> 注：有些css样式是不具有继承性的，如边框属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;</span><br><span class="line">    今天是</span><br><span class="line">    &lt;<span class="selector-tag">span</span>&gt;星期三&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure><p>如上代码所示的效果中，边框样式只应用在了p标签上，对span标签并没有起到作用<imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210121909355.png"alt="img" /></p><h3 id="长度单位">长度单位</h3><h4 id="像素">像素</h4><ul><li>屏幕（显示器）实际上是由一个一个的小点点构成的</li><li>不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰</li><li>所以同样的200px在不同的设备下显示效果不一样</li></ul><h4 id="百分比">百分比</h4><ul><li>也可以将属性值设置为相对于其父元素属性的百分比</li><li>设置百分比可以使子元素跟随父元素的改变而改变</li></ul><h4 id="em">em</h4><ul><li>em是相对于元素的字体大小来计算的</li><li>1em = 1font-size</li><li>em会根据字体大小的改变而改变</li></ul><h4 id="rem">rem</h4><ul><li>rem是相对于根元素html字体大小来计算</li></ul><h3 id="文档流">文档流</h3><p>网页时一个多层的结构，一层摞着一层。通过css样式可以为每一层来设置样式。</p><p>作为用户来讲只能看见最顶层。</p><p>这些层中，最底下的一层称为文档流，文档流是网页的基础，我们所创建的元素默认都是在文档流中排列。</p><p>元素主要有两个状态：</p><ul><li>在文档流中</li><li>不在文档流中（脱离文档流）</li></ul><p>元素在文档流中的特点：</p><ul><li><p>块元素</p><ul><li><p>块元素在页面中独占一行（自上向下垂直排列）</p></li><li><p>默认宽度是父元素的全部（会把父元素撑满）</p></li><li><p>默认高度是被内容撑开（子元素）</p></li></ul></li><li><p>行内元素</p><ul><li>行内元素不会独占页面的一行，只占自身的大小</li><li>行内元素在页面中自左向右水平排列，如果一行内中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列</li><li>行内元素的默认宽度和高度都是被内容撑开</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box2</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>我是div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>我是div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210171016073.png" /></p><h3 id="盒子模型">盒子模型</h3><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210171039176.png" /></p><blockquote><p>内容区（content）：元素中的所有的子元素和文本内容都在内容区中排列。内容区的大小由width和height两个属性来设置</p></blockquote><blockquote><p>边框（border）：边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部。要设置边框，至少需要设置三个样式： - 边框的宽度 border-width -边框的颜色 border-color - 边框的样式 border-style</p></blockquote><p>盒子模型：</p><p>又称盒模型、框模型（boxmodel），CSS中将页面中的所有元素都设置为了一个矩形的盒子。这样对页面的布局就变成将不同的盒子摆放到不同的位置。</p><p>每一个盒子都由以下几个部分组成： - 内容区（content） -内边距（padding） - 边框（border） - 外边距（margin）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>盒模型<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">             <span class="attribute">border-width</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">             <span class="comment">/*border-color: red;*/</span></span></span><br><span class="line"><span class="language-css">             <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210171031930.png" /></p><h4 id="边框border">边框（border）</h4><h5 id="边框的宽度">边框的宽度</h5><blockquote><p>border-width：默认值为3个像素，它可以同时指定四个方向的边框的宽度。值的情况： - 四个值：上 右 下 左 - 三个值：上 左右 下 - 两个值：上下左右 - 一个值：上下左右</p></blockquote><p>除了border-width还有一组border-xxx-width，其中xxx可以是 top rightbottom left，可以用来单独指定某一个边的宽度。</p><h5 id="边框的颜色">边框的颜色</h5><blockquote><p>border-color：用来指定边框的颜色，同样可以分别指定四个边的边框，规则和border-width一样。border-color也可以省略不写，如果省略了则自动使用color的颜色值。</p></blockquote><p>除了border-color还有一组border-xxx-color，其中xxx可以是 top rightbottom left，可以用来单独指定某一个边的颜色。</p><h5 id="边框的样式">边框的样式</h5><blockquote><p>border-style：用来指定边框的样式，同样可以分别指定四个边的样式，规则和border-widthborder-color 一样。 border-style的默认值是none 表示没有边框 border-style指定边框的样式</p><ul><li>solid 表示实线</li><li>dotted 点状虚线</li><li>dashed 虚线</li><li>double 双线</li></ul></blockquote><p>除了border-style还有一组border-xxx-style，其中xxx可以是 top rightbottom left，可以用来单独指定某一个边的样式。</p><h5 id="border简写属性">border简写属性</h5><p>border简写属性，通过该属性可以同时设置四条边框的相关样式，并且没有顺序要求。除了border以外还有四个 border-xxx，其中xxx为top、right、bottom、left</p><h4 id="内边距padding">内边距（padding）</h4><ul><li>内边距的设置会影响到盒子的大小。</li><li>背景颜色会延伸到内边距上</li></ul><p>一个盒子的可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算。</p><p>padding可以设置盒子内边距大小。同边框的属性一样，可以同时设置四个方向的内边距。还可以对某个方向的内边距单独设置，padding-xxx，其中xxx为top、right、bottom、left</p><h4 id="外边距margin">外边距（margin）</h4><ul><li>外边距不会影响盒子可见框的大小</li><li>但是外边距会影响盒子的位置</li><li>一共有四个方向的外边距： &gt;margin-top：上外边距，设置一个正值，元素会向下移动 &gt; margin-right：默认情况下设置margin-right不会产生任何效果 &gt;margin-bottom：下外边距，设置一个正值，其下边的元素会向下移动 &gt;margin-left：左外边距，设置一个正值，元素会向右移动 &gt; &gt; （margin也可以设置负值，如果是负值则元素会向相反的方向移动）</li></ul><p>margin 可以同时设置四个方向的外边距 ，用法和padding一样。</p><p>一个元素在其父元素中，水平布局必须要满足以下的等式<code>margin-left</code>+<code>border-left</code>+<code>padding-left</code>+<code>width</code>+<code>padding-right</code>+<code>border-right</code>+<code>margin-right</code>= 其父元素内容区的宽度</p><h4 id="圆角">圆角</h4><p>圆角设置是圆的半径大小，属性border-radius用来设置圆角</p><p>border-radius 可以分别指定四个角的圆角 四个值 左上 右上 右下 左下三个值 左上 右上/左下 右下 两个个值 左上/右下 右上/左下</p><blockquote><ul><li>左上角：border-top-left-radius</li><li>右上角：border-top-right-radius</li><li>左下角：border-bottom-left-radius</li><li>右下角：border-bottom-right-radius</li></ul></blockquote><h3 id="浮动">浮动</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】计算机组成原理知识点整理</title>
      <link href="/posts/55019.html"/>
      <url>/posts/55019.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-计算机系统概述">第一章 计算机系统概述</h2><p><em>较简单，不做过多赘述，后面会详细学到</em></p><h3 id="第一节-计算机系统层次结构">第一节 计算机系统层次结构</h3><p>1.计算机系统的基本组成：硬件+软件</p><p>2.计算机硬件的基本组成：运算器+存储器+控制器+输入设备+输出设备</p><p>3.系统软件和应用软件</p><table><colgroup><col style="width: 11%" /><col style="width: 88%" /></colgroup><thead><tr><th>系统软件</th><th>操作系统、数据库管理系统、语言处理程序、分布式软件系统、网络软件系统、标准库语言、服务性程序</th></tr></thead><tbody><tr><td>应用软件</td><td>科学计算类程序、工程设计类程序、数据统计与处理程序</td></tr></tbody></table><p>4.（易考）翻译程序：</p><table><thead><tr><th>汇编程序（汇编器）</th><th>将汇编语言程序翻译成机器语言程序</th></tr></thead><tbody><tr><td>解释程序（解释器）</td><td>将源程序翻译成机器指令并立即执行</td></tr><tr><td>编译程序（编译器）</td><td>将高级语言翻译城机器语言或汇编语言</td></tr></tbody></table><h3 id="第二节-计算机性能指标">第二节 计算机性能指标</h3><ul><li><strong>吞吐量</strong>：表征一台计算机在某一时间间隔内能够处理的信息量。</li><li><strong>响应时间</strong>：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量。</li><li><strong>利用率</strong>：在给定的时间间隔系统被实际使用的时间所占的比率，用百分比表示。</li><li><strong>处理机字长</strong>：指处理机运算器中一次能够完成二进制数运算的位数，如32 位、64 位。</li><li><strong>总线宽度</strong>：一般指 CPU中运算器与存储器之间进行互连的内部总线二进制位数。</li><li><strong>存储器容量</strong>：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB 来表示。公式一般是：位数×个数</li></ul><p>（MAR×MDR）</p><ul><li><strong>存储器带宽</strong>：单位时间内从存储器读出的二进制数信息量，一般用字节数/秒表示。</li><li><strong>主频/时钟周期</strong>：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟度量单位是MHz、GHz</li></ul><p>主频的倒数称为 CPU 时钟周期（T），T=1/f，度量单位是 μs、ns。</p><p>K= 103 ，M= 106 ，G= 109</p><p>易错：时钟频率的提高，不能保证CPU执行速度又同倍速的提高，有时候还会减慢。</p><ul><li><strong>CPU 执行时间</strong>：表示 CPU 执行一般程序所占用的 CPU时间，可用下式计算：</li></ul><p>CPU 执行时间 = CPU 时钟周期数 * CPU 时钟周期</p><ul><li><strong>CPI</strong>：执行一条指令所需的平均时钟周期数。用下式计算：</li></ul><p>CPI = 执行某段程序所需的 CPU 时钟周期数 / 程序包含的指令条数</p><ul><li><strong>MIPS</strong>：（Million Instructions PerSecond）的缩写，表示平均每秒执行多少百万条定点指令数，用下式计算：</li></ul><p>MIPS = 指令数 / （程序执行时间 * 10^6）</p><ul><li><strong>FLOPS</strong>：（Floating-point Operations PerSecond）的缩写，表示每秒执行浮点操作的次数，用来衡量机器浮点操作的性能。用下式计算：FLOPS= 程序中的浮点操作次数 / 程序执行时间（s）</li></ul><h3 id="题目总结">题目总结：</h3><p>①对于<strong>高级</strong>语言程序员来说，浮点数格式、乘法指令、数据如何在运算器中运算时透明的。对于<strong>汇编语言</strong>程序员，指令格式，机器构造，数据格式则不是透明的。</p><p>②在CPU中，IR、MAR、MDR对各类程序员都是透明的。</p><p>③机器字长，指令字长，存储字长</p><p>机器字长也称字长——是计算机直接处理二进制数据的位数，机器字长一半等于内部寄存器的大小，它决定了计算机的运算精度。</p><p>指令字长——一个指令中包含的二进制代码的位数。</p><p>存储字长——一个存储单元中二进制代码的长度。</p><p>指令字长一般是存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取值周期为机器周期的2倍；若指令字长等于存储字长，则取值周期等于机器周期。</p><h2 id="第二章-数据的表示和运算">第二章 数据的表示和运算</h2><p>一、无符号整数的表示和运算</p><p>Ⅰ、无符号整数的加法：从最低位开始，按位相加，并往更高位进位。</p><p>Ⅱ、”被减数“不变，”减数“<strong>全部按位取反</strong>，末位+1，<strong>减法变加法。</strong></p><p>二、带符号整数的表示和运算</p><p>带符号的整数表示：原码、补码、反码</p><p>※带符号的整数运算可以用原码吗？</p><p>用原码的话符号位不能参与运算，需要设计复杂的硬件电路才能处理，贵。</p><p>这时候就可以利用补码来进行带符号的整数运算。</p><p>①涉及原码和补码的转化。</p><p>正数：原码-&gt;补码，不变</p><p>负数：原码-&gt;补码，除符号位外，各位取反，末位+1</p><p>Ⅰ、补码的加法</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031505324.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从最低位开始，然后按位相加，并往高位进位。算出来的结果，转回原码，就可以得到正值。</p><p>补充：补码-&gt;原码：类似，除符号位外，各位取反，末位+1</p><p>Ⅱ、补码的减法</p><p>※加法电路造价便宜，减法电路造价昂贵，若将减法变为加法，更加economize。</p><ul><li>那我们知道了”减数“的补码，那如何求得”减数“负值的补码呢？</li></ul><p>补码<strong>全部位</strong>取反，末位+1（易错这里是全部位取反，而带符号位的负数，是除符号位外，各位取反）</p><p>其实啊，这里的运算的逻辑结构和无符号的减法运算是一样的，通用一套电路，省钱！</p><p>三、原码、反码和补码的特性对比</p><table><colgroup><col style="width: 15%" /><col style="width: 21%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 37%" /></colgroup><thead><tr><th>8bit</th><th>合法的表示范围</th><th>最大的数</th><th>最小的数</th><th>真值0的表示</th></tr></thead><tbody><tr><td>带符号原码</td><td>-127~127</td><td>127</td><td>-127</td><td>+0=00000000 -0=10000000</td></tr><tr><td>带符号反码</td><td>-127~127</td><td>127</td><td>-127</td><td>+0=00000000 -0=11111111</td></tr><tr><td>带符号补码</td><td>-128~127</td><td>127</td><td>-128</td><td>-/+0=00000000 只有这一种</td></tr><tr><td>无符号整数</td><td>0~255</td><td>255</td><td>0</td><td>00000000</td></tr><tr><td>带符号移码</td><td>-128~127</td><td>127</td><td>-128</td><td>0=10000000 只有这一种</td></tr></tbody></table><p>原码和反码的合法表示范围完全相同，而且都有两种表示真值0的方法。</p><p>补码的合法表示范围多一个负数，原因就是只有一种0的表示方法，因为-0的补码就是00000000</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031506023.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>四、移码，定点小数</p><p>移码：在补码的基础上符号位取反。且移码只能表示整数。表示范围和补码相同。</p><p>移码的作用：<em>移码的作用就是方便计算机比较两个数数值的大小。</em></p><p>定点小数的编码表示：原码、反码、补码。</p><p>运算规则和整数的运算规则一模一样。</p><p>五、电路的基本原理和加法器设计</p><p>Ⅰ、补码/无符号整数加减法运算器</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031506100.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>减法运算过程：</p><p>①首先Sub信号置为1；</p><p>②多路选择器的值为1，Y（减数）经过非门，都取反；</p><p>③cin来自低位加1；</p><p>Ⅱ、标志位生成</p><p>①进位标志CF (Carry Flag)只对无符号运算有意义当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，</p><p>即CF = 1；否则CF= 0。</p><p>49H + 6DH＝B6H，　没有进位：CF = 0</p><p>BBH + 6AH＝（1）25H，有进位：CF = 1</p><p>②零标志ZF (Zero Flag) 若运算结果为0，则ZF = 1；否则ZF = 0</p><p>49H + 6DH＝B6H，结果不是零：ZF = 0</p><p>75H + 8BH＝（1）00H，结果是零：ZF = 1</p><p>③符号标志SF (Sign Flag)只对有符号运算有意义 运算结果最高位为1，则SF =1；否则SF = 0</p><p>49H + 6DH＝B6H=10110110B，SF=1</p><p>④溢出标志OF (Overflow Flag)只对有符号运算有意义若算术运算的结果有溢出，则OF＝1；否则 OF＝0</p><p>49H + 6DH ＝B6H，产生溢出：OF = 1</p><p>75H + 8BH ＝（1）26H，没有溢出：OF = 0</p><p>进位CF和溢出OF位有什么区别呢？</p><p>进位标志表示无符号数运算结果是否超出范围，运算结果仍然正确，对有符号位加减法无意义。</p><p>溢出标志表示有符号数运算结果是否超出范围，运算结果已经不正确，对无符号加减无意义。</p><p>溢出的判断判断运算结果是否溢出有一个简单的规则：</p><p>只有当两个相同符号数相加（包括不同符号数相减），而运算结果的符号与原数据符号相反时，产生溢出；因为，此时的运算结果显然不正确其他情况下，则不会产生溢出</p><p>1.当两个符号相同的数相加，结果的符号与之相反，则OF=1,否则OF=0.</p><p>2.当两个符号不同的数相减，结果的符号与减数相同，则OF=1,否则OF=0.</p><p>六、定点数的移位运算</p><ul><li>左移1位相当于×2，右移1位相当于÷2</li><li>原码：符号位不参与移位。左移，右移都补0</li><li>反码：符号位不参与移位。<strong>若反码是负数补1；若反码是正数补0</strong></li><li>补码：符号位不参与移位。<strong>若补码是负数左移低位补0，右移高位补1；若补码是正数，左移右移都补0</strong></li></ul><p>七、原码补码的乘法除法运算</p><p>Ⅰ、原码的一位乘法</p><p>符号位通过异或确定；数值部分通过被乘数和乘数绝对值的n轮加法、移位完成，根据当前乘数中参与运算的位确定（ACC）加什么。若当运算位=1，则（ACC）+[|x|],若为0，则(ACC)+1。每轮加法完成后，ACC,MQ的内容统一逻辑右移。</p><p>![img](<imgsrc="https://pic1.zhimg.com/80/v2-391e106f8411d22834924628fce767cc_720w.webp"alt="img" /></p><p>先ACC初始化。x置于通用寄存器中，y置于MQ。</p><p>Ⅱ、补码的一位乘法</p><p>原码一位乘法和补码一位乘法的不同点</p><table><colgroup><col style="width: 42%" /><col style="width: 57%" /></colgroup><thead><tr><th>原码一位乘法</th><th>补码一位乘法</th></tr></thead><tbody><tr><td>进行n轮的加法、移位</td><td>进行n轮加法，移位，最后再多来一次加法</td></tr><tr><td>每次加法相加，只有两种情况+0或加x</td><td>每次加法加有三种情况，0或+x或+[-x]</td></tr><tr><td>每次移位都是逻辑右移，补1</td><td>每次都是补码的右移，正数右移补0，负数右移补1</td></tr><tr><td>符号位不参与运算</td><td>符号位参与运算</td></tr></tbody></table><ul><li>会添加一位辅助位</li><li>辅助位-MQ中“最低位”=1时，(ACC)+[X)]补</li><li>辅助位-MQ中“最低位”=0时，(ACC)+0</li><li>辅助位-MQ中“最低位”=-1时，(ACC)+[-X]补</li></ul><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031507791.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>八、C语言类型转换和数据存储排列</p><ul><li>C语言中定点整数是用”补码“存储的。</li><li>无符号数转为有符号数：不改变数据内容，改变解释方式。</li><li>长整数变为短整数：高位截断，保留低位。</li><li>短整数变长整数：若为有符号数，在符号位和数值位添1，若为无符号，直接在高位添0。</li><li>大小端模式：大端方式便于人类阅读；小段方式便于机器处理，因为机器最先读入的就是最应被处理的数据。</li><li>边界对齐：假设存储字长为32位，则1个字=32bit,半字=16bit。每次访存只能读/写1个字。若采用边界对齐的方式，则访问一个字/半字都需要一次访存，虽然会造成一点点的空间浪费。采用不对齐的方式，对空间利用率高，但是可能会涉及到两次访存时间大大增加。</li></ul><p>九、浮点数的表示和运算</p><p>Ⅰ、概念：之前我们学习了定点数，其中「定点」指的是约定小数点位置固定不变。那浮点数的「浮点」就是指，其小数点的位置是可以是<strong>漂浮不定</strong>的。</p><p>Ⅱ、表示：阶符表示的是阶码正负，尾数的数符表示的是尾数正负。</p><p>阶码：常用补码或移码表示的定点整数，反映表示范围。</p><p>尾数：常用原码或补码表示的定点小数，反映精度。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031508462.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Ⅲ、<strong>规格化：规定尾数的最高位必须是有效位</strong>。</p><p>①”有效位“又分两种情况。分为尾数是补码表示还是原码表示</p><p>原码表示的尾数视格化：<strong>尾数的最高数值位必须是1</strong></p><p>补码表示的尾数规格化：<strong>尾数最高数值位必须和尾数符号位相反</strong></p><p>②左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减1。</p><blockquote><p>b= 22×(+0.01001)=21×(+0.10010) #尾数最高位为0，左规</p></blockquote><p>右规：当<strong>浮点数运算的结果尾数出现溢出（双符号位为01或10）时</strong>，将尾数算数右移一位，阶码加1。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031509567.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>采用双符号位，当发生溢出时（双符号位为01或10），可以采用右规，更高位的符号位是正确的符号位。</p><p>③虽然浮点数的范围和精度也有限，但其范围和精度都已非常之大，所以在计算机中，对于小数的表示我们通常会使用浮点数来存储。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031509929.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>十、IEEE 754</p><p>背景：在浮点数提出的早期，各个计算机厂商各自制定自己的浮点数规则，导致不同厂商对于同一个数字的浮点数表示各不相同，在计算时还需要先进行转换才能进行计算。后来IEEE 组织提出了浮点数的标准，统一了浮点数的格式，并规定了单精度浮点数float 和双精度浮点数double，从此以后各个计算机厂商统一了浮点数的格式，一直延续至今。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031510372.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031510737.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031511298.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>十一、浮点数运算（重点）</p><p>现代计算机表示数的方法通常都是浮点数了，所以这节很重要。</p><p>①对阶：小阶向大阶靠齐，方便计算机对尾数进行处理。</p><p>②尾数加减：尾数常规加减。</p><p>③规格化：如果尾数加减出现类似0.0099517× 1012 时，需要“左规”；</p><p>如果尾数加减出现类似99.517107× 1012 时，需要“右规”。</p><p>④舍入：尾数位数有限，若规定只能保留6位有效尾数，则9.9517107× 1012→9.95171× 1012 (多余的直接砍掉)或者，9.9517107× 1012 →9.95172× 1012（若砍掉分非0，则入1)或者，也可以采用四舍五入的原则，当舍弃位≥5时，高位入1。</p><p>⑤判溢出：若规定阶码不能超过两位，则运算后阶码超出范围，则溢出。</p><p>如：9.85211× 1099 +9.96007× 1099 =19.81218× 1099规格化并用四舍五入的原则保留6位尾数，得1.98122× 10100,阶码超过两位，溢出。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031511692.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>强制类型转化：</p><p>无损：char-&gt;int-&gt;long-&gt;double</p><p>float-&gt;double</p><p>有损：int-&gt;float,可能会损失精度</p><p>float-&gt;int，可能会溢出，也可能会损失精度</p><h2 id="第三章-存储系统">第三章 存储系统</h2><h3 id="第一节-存储器概述">第一节 存储器概述</h3><p>一、存储器的层次结构</p><p>寄存器-&gt;Cache-&gt;主存-&gt;辅存-&gt;外存</p><p>Cache-主存：解决了主存与CPU速度不匹配的问题。</p><p>主存-辅存：实现虚拟存储系统，解决了主存容量不够的问题。</p><p>※辅存中的数据要调入到主存才能被CPU访问</p><p>二、存储器的分类</p><p>Ⅰ、按照存取方式：分为随机存取存储器（RAM），如内存；顺序存取存储器（SAM），如磁带；直接存取存储器（DAM），如磁盘；相联存储器（可按内容访问的存储器，CAM），如快表。</p><p>Ⅱ、按信息是否可改：分为读/写存储器和只读存储器（ROM）</p><p>Ⅲ、断电后是否消失：分为易失性存储器，如内存、Cache；非易失性存储器，如磁盘、光盘</p><p>三、存储器的性能指标</p><p>1.存储容量：存储字数×字长</p><p>2.单位成本：每位价格=总成本/总容量</p><p>3.存储速度：数据传输率=数据的宽带/存储周期</p><p>存储周期=存取时间+恢复时间</p><h3 id="第二节-主存储器">第二节 主存储器</h3><p>一、SRAM和DRAM</p><p>一个静态RAM，一个动态RAM。动态的用于主存，静态的用于Cache</p><p>SRAM和DRAM的差别</p><table><thead><tr><th>类型特点</th><th>SRAM</th><th>DRAM</th></tr></thead><tbody><tr><td>存储信息</td><td>触发器</td><td>电容</td></tr><tr><td>破坏性读出</td><td>非</td><td>是</td></tr><tr><td>读出后是否需要重写</td><td>不用</td><td>需要</td></tr><tr><td>运行速度</td><td>快</td><td>慢</td></tr><tr><td>集成度</td><td>低</td><td>高</td></tr><tr><td>发热量</td><td>大</td><td>小</td></tr><tr><td>存储成本</td><td>高</td><td>低</td></tr><tr><td>是否易失</td><td>易失</td><td>易失</td></tr><tr><td>是否需要刷新</td><td>不需要</td><td>需要</td></tr><tr><td>作用</td><td>常用作Cache</td><td>常用作主存</td></tr></tbody></table><p>二、ROM只读存储器</p><p>RAM芯片——易失性，断电后数据消失</p><p>ROM芯片——非易失性，断电后数据不会消失</p><p>①MROM——掩模式只读存储器：任何人都不可重写</p><p>②PROM——可编程只读存储器：写一次后就不可更改</p><p>③EPROM——可擦除可编程只读存储器：可进行多次重写，写入时间很长</p><p>④FlashMemory——闪速存储器：可进行多次快速擦除重写，但写的速度比读的速度慢</p><p>⑤SSD——固态硬盘：可进行多次快速擦除重写，目前个人电脑大都市这种。速度快，功耗低，价格高。</p><h3 id="第三节-主存储器与cpu的连接">第三节 主存储器与CPU的连接</h3><p>一、单块存储器与CPU连接</p><p>Ⅰ、连接原理：主存器通过数据总线，地址总线和控制总线与CPU连接。</p><p>地址总线的位数决定了可寻址的最大内存空间。</p><p>控制总线指出总线周期类型和本次输入输出操作完成的时刻。</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031511879.png"alt="img" />主存储器的线路</p><p>二、多块存储器与CPU连接</p><p>Ⅰ、位扩展法</p><p>原理：CPU的数据线与存储芯片的数据位数不相等，此时必须使用多个存储器件对字长进行扩位。每个存储器的数据线都并行连接在CPU的数据总线上，而地址位数是串行相连。那CPU传一个地址过来，怎么知道是使用哪个存储芯片呢，此时就要WE来控制使用哪个存储芯片。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031512108.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Ⅱ、字扩展法</p><p>原理：当主存储器位数不足，字数足够时，我们会通过位扩展的方法来扩展主存储器，将多个字数相同的存储芯片并联起来，增加位数，并且存储空间是连续的。里面还会涉及译码器，主要功能就是增加控制存储器的个数，如有两位地址线连接了译码器，那么译码器可以控制22 个存储器。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031512107.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><table><colgroup><col style="width: 55%" /><col style="width: 44%" /></colgroup><thead><tr><th>线选法</th><th>译码片选法</th></tr></thead><tbody><tr><td>n条线n个片选信号</td><td>n条线2的n次方个片选信号</td></tr><tr><td>电路简单</td><td>电路复杂</td></tr><tr><td>地址不连续（两位举例，00和11的地址用不到）</td><td>地址连续（00和11的地址也都用到了）</td></tr></tbody></table><p>Ⅲ、字位同时扩展</p><p>原理：而当字数和位数都不足时，我们会通过字位同时扩展的方法来扩展存储器，将多个字数和位数都相同的存储芯片连接起来，同时增加字数和位数。</p><p>Ⅳ、三者比较</p><p>字扩展方法只能增加主存储器的容量，存取速度没有提升。而位扩展方法不光可以增加主存储器的容量，同时还可以让多个存储芯片同时工作，同时做读写操作，增加了存取速度。字位同时扩展的方法又可以增加主存储器的容量，又可以让多个存储芯片同时工作，那么是不是只用字位同时扩展这一种方法就可以了呢？任何事情都是有利弊两面性的，在能力增强的同时，他的成本，功耗和体积都会增加，所以我们还是要根据实际的系统需求来判断具体使用的主存储器扩展方法。</p><p>Ⅴ、题目总结</p><p>【2018统考真题】假定DRAM芯片中存储阵列的行数为r、列数为c,对于一个2K×1位的DRAM芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则r、c的取值分别是()。</p><p>解：r是行，c是列，为了保证地址引脚数最少，就要求，行列相差小，并且减少刷新开销，则要求行数越小越好。故最终行数位32，列数位64。</p><p>三、多模块存储器</p><p>背景：随着CPU的功能不断增强，I/O设备数量不断增多，这也导致了主存的存取速度已成为计算机系统的发展瓶颈。为了解决此问题，除了寻找更高速的原件和采用存储器层次结构外，调整主存的结构也可以提高访存速度，这就涉及到了多模块存储器。</p><p>由于取值周期=存取时间+恢复时间。DRAM芯片恢复时间较短，有可能是存取时间的几倍。那怎么半，不能让设备停着吧。那太浪费资源了。</p><p>Ⅰ、双端口RAM</p><p>顾名思义，就是利用两个端口实现多核CPU存储，需要有两组完全独立的数据线，地址线，控制线。支持两个CPU同时访问。</p><p>两个端口可以同时对不同单元的地址中取数据，也可以对同一地址单元中读出数据，但是不行同时对同一单元中写入数据，也不能对同一单元一边读一边写入数据。</p><p>解决办法：发出”busy“信号，其中一个CPU的访问端口暂时关闭。</p><p>Ⅱ、单体多字存储器</p><p>原理：原来每行只存放一个存储字，变为每行存放多个存储字，这样原来一次只能读取一个存储字，变为一次能读取多个存储字，这需要数据总线根数变大。</p><p>限制：指令和数据在主存必须是连续存放的。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031512562.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Ⅲ、多体并行存储器（重点）</p><p>原理：每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路，地址<ahref="https://link.zhihu.com/?target=https%3A//so.csdn.net/so/search%3Fq%3D%E5%AF%84%E5%AD%98%E5%99%A8%26spm%3D1001.2101.3001.7020">寄存器</a>，和数据寄存器，既能并行工作，又能交叉工作（一个模块进入恢复时间，另一个模块进行存取）。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031512723.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>区别：在高位交叉中，由于下一个访问的地址还是在这个存储体上，所以必须等到恢复时间结束后才能继续访问，故不能并行访问。效果也仅仅是扩容。而在低位交叉编制中，下一个访问地址不在同一个存储体上，所以可以交叉访问，不仅扩容还加快了访问速度。当块数m≥ T/r时，能达到最佳存储效率。T为存取周期，r为存取时间。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031513740.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="第四节-外部存储器">第四节 外部存储器</h3><p>一、磁盘存储器</p><p>优点：存储容量大，价格低，长期保存而不丢失。</p><p>缺点：存取速度慢，机械结构复杂，对环境要求高。</p><p>磁盘最小的读写单位是一个扇区。</p><p>二、固态存储器SSD（新增考点）</p><p>优点：读写速度快。若要写的页有数据，则不能写入，需要将块内其他页全部复制到一个新的块中，再写入新的页。</p><p>缺点：价格高，一个块被写入多次可能会坏掉（采用平均磨损，对我们来说仍然很耐用）而磁盘不会。</p><h3 id="第五节-高速缓冲存储器重点">第五节 高速缓冲存储器（重点）</h3><p>一、什么是Cache，为什么要引入Cache？</p><p>Cache存储器也被称为高速缓冲存储器，位于CPU和主存储器之间。之所以在CPU和主存之间要加cache是因为现代的CPU频率大大提高，内存的发展已经跟不上CPU访存的速度。在2001–2005年间，处理器时钟频率以每年55%的速度增长，而主存的增长速度只是7%。<strong>在现在的系统中，处理器需要上百个时钟周期才能从主存中取到数据。如果没有cache，处理器在等待数据的大部分时间内将会停滞不动</strong>。</p><p>二、原理</p><p>采用了程序访问的时间局部性原理和空间局部性原理</p><p>时间局部性：<strong>如果一个数据现在被访问了，那么以后很有可能也会被访问</strong></p><p>空间局部性：<strong>如果一个数据现在被访问了，那么它周围的数据在以后可能也会被访问</strong></p><p>三、多级Cache的由来？</p><p>cache分为L1，L2，L3甚至L4等多级。为什么不能把L1的容量做大，不要其它的cache了？原因在于性能/功耗/面积（PPA）权衡考虑。L1cache一般工作在CPU的时钟频率，要求的就是够快，可以在2-4时钟周期内取到数据。L2cache相对来说是为提供更大的容量而优化的。虽然L1和L2往往都是SRAM，但构成存储单元的晶体管并不一样。L1是为了更快的速度访问而优化过的，它用了更多/更复杂/更大的晶体管，从而更加昂贵和更加耗电；L2相对来说是为提供更大的容量优化的，用了更少/更简单的晶体管，从而相对便宜和省电。在有一些CPU设计中，会用DRAM实现大容量的L3cache。</p><p>四、如何区分Cache和主存的数据块对应关系？</p><p>每次被访问的主存块，一定会被立即调入Cache，而且是以块为单位进行调入。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031514944.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>那是采用什么方式将主存块号调入到Cache呢？有三种方式</p><p>①全相联映射——主存块可以放在Cache的任意位置。</p><p><strong>那它是如何来访问主存的呢？</strong></p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031514675.png"alt="img" />)</p><p>对以上图只要能看懂，对于全相联映射就没什么问题了。做几点说明，CPU在访问主存时，会先对比Cache所有块中的标记Tag，Tag就是在主存中的主存块号，占22位。</p><p>②直接映射——每个主存块只能放在一个特定的位置。Cache块号=主存块号%Cache块总数</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031514818.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>做以下几点说明</p><ul><li>相对于全相联映射，直接映射对<strong>Tag进行了优化</strong>，因为主存块号最后三位地址就是Cache中的位置，所以将主存块号其余位作为标记即可。</li><li>若Cache总块数= 2n,则主存块号末尾n位直接反映它在Cache的位置，所以将主存块号其余位作为标志位即可。</li></ul><p>③组相联映射——Cache块分为若干组，每个主存块可以放到特定分组中的任意一个位置。组号=主存块号%分组数</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031515265.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>做以下几点说明</p><ul><li>相对于全相联映射，直接映射对<strong>Tag进行了优化</strong>，因为主存块号最后两位地址就是Cache中的位置，所以将主存块号其余位作为标记即可。</li><li>一个组内有几个Cache块就成为几路相联映射</li></ul><p>④三种映射方法对比总结</p><table><colgroup><col style="width: 12%" /><col style="width: 31%" /><col style="width: 36%" /><col style="width: 18%" /></colgroup><thead><tr><th></th><th>全相联</th><th>直接</th><th>组相联</th></tr></thead><tbody><tr><td>特点</td><td>任意位置</td><td>特定位置</td><td>分组中的任意位置</td></tr><tr><td>主存地址结构</td><td>标记+块内地址</td><td>标记+行号+块内地址</td><td>标记+组号+块内地址</td></tr><tr><td>优点</td><td>Cache存储空间利用充分</td><td>对任意地址，执行对比一个Tag，速度快</td><td>折中办法</td></tr><tr><td>缺点</td><td>可以会对比所有行的标记，速度慢</td><td>Cache空间利用不充分</td><td>/</td></tr></tbody></table><p>五、Cache很小，而主存很大，如果Cache满了，是利用了什么替换算法？</p><p>替换条件：对于全相联映射，需要在全局中选择替换哪一块，对于直接映射，若非空，则直接替换，对于组相联，组内满了，则在组内选择替换哪一块。</p><p>Ⅰ、随机算法(RAND)</p><p>随机，随便，随意，换哪一个都行。实现简单，但完全没有考虑局部性原理，命中率低，实际效果很不稳定。</p><p>可能会导致，换出的块，下一次又需要访问。就会多次访问内存块。导致抖动现象。</p><p>Ⅱ、先进先出算法(FIFO)</p><p>替换最先进入的块。同样实现简单，但仍然没有考虑到局部性原理，最先被调入Cache块可能是被访问最频繁的。</p><p>Ⅲ、近期最少使用(LRU)</p><p>为每个Cache块设置一个”计数器“，用于记录每个Cache块多久没有被访问了。然后替换”计数器“值最大的。</p><ul><li>计数器的位数=Cache块的总数= 2n，只需要n位，且Cache装满后所有计数器的值一定不重复。</li><li>基于局部性原理，近期被访问的主存块，未来可能仍会被使用，LRU算法实际运行效果优秀。</li><li>若频繁访问的主存块数量&gt;Cache行的数量，则有可能发生”抖动“</li></ul><p>Ⅳ、最近不经常使用(LFU)</p><p>为每个Cache设置一个”计数器“，用于记录Cache被访问过几次，然后替换”计数器“值最小的（访问次数最少的）</p><p>曾经被经常访问的主存块不一定在未来会被用到。并没有很好的遵循局部性原理，因此实际运行效果不如LRU。</p><p>六、Cache写策略——CPU修改了Cache中的数据副本，如何确保主存中数据母本一致性？</p><p>Ⅰ、写命中——写入的时候，在Cache中</p><p>①回写法：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当次块被换出时才写回主存。减少了访存次数，但存在数据不一致的隐患。</p><p>被换出时，看”脏位“是否知道是否被修改。</p><p>②全写法：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲。访存次数增加，速度变慢，但是能保证数据的一致性。无脏位。</p><p>Ⅱ、写不命中——写入的时候，不在Cache中</p><p>①写分配法——当CPU对Cache不命中时，把主存中的块调入Cache，在Cache中修改。通常搭配<strong>回写法</strong>使用，改完后要被换出，才在主存中修改。</p><p>②非写分配法——当CPU对Cache写不命中时，只写入主存，不调入Cache，搭配全写法使用。</p><h3 id="第六节-虚拟存储器">第六节 虚拟存储器</h3><p>虚拟存储器：在操作系统的管理下，只把当前需要的部分数据调入主存，暂不需要的部分留在辅存中。在用户看来，似乎获得了一个超大的主存。（虚拟性）</p><p>一、页式虚拟存储器</p><p>背景：CPU执行的机器指令中，使用的是”逻辑地址“，因此需要通过”页表“将逻辑地址转为物理地址。</p><p>一个程序在逻辑上被分为若干个大小相等的”页面“，”页面“大小与”块“的大小相同。每个页面可以离散的存放在不同主存块中。</p><p>页表的作用：记录了每个逻辑页面存放在哪个主存块中。</p><p>无快表：</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031515837.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>逻辑地址=逻辑页号+页内地址</li><li>物理地址=主存块号+页内地址</li></ul><p>增加快表（存放在Cache中，先访问快表，若未命中，则去访问主存中的慢表）</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031515658.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>快表查询速度很快，若快表中无，则会去慢表中查找，会把相应的内容存入快表中</li></ul><p><strong>清楚整个查找流程</strong></p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031515288.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>二、段式虚拟存储（按功能拆分成大小不同的模块）</p><p>按照功能模块拆分不同的模块大小。</p><p>虚拟地址：段号+段内地址</p><p>优点：段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护。</p><p>缺点：段的长度可变，分配空间不便，容易留下碎片，不好利用，造成浪费。</p><p>三、段页式虚拟存储</p><p>把程序按逻辑结构分段，每段在分固定大小的页，主存空间也划分为大小相等的页，每个程序对应一个段表，每段对应一个页表。</p><p>虚拟地址：段号+段内地址+页内地址</p><p>优点是兼具段式和页式的优点缺点是需要查两次表，系统开销较大。</p><p>四、虚拟存储器与Cache的比较</p><table><colgroup><col style="width: 39%" /><col style="width: 60%" /></colgroup><thead><tr><th>Cache</th><th>虚拟存储器</th></tr></thead><tbody><tr><td>解决CPU与主存速度不匹配的问题</td><td>解决主存容量的问题</td></tr><tr><td>全由硬件组成，对所有程序员透明</td><td>由OS和硬件组成，逻辑上存储器对系统程序员不透明</td></tr><tr><td>不命中影响小</td><td>不命中影响大</td></tr><tr><td>不命中时，主存直接与CPU通信</td><td>不命中时，不能直接和CPU通信，要先硬盘调入主存</td></tr></tbody></table><h3 id="题目总结-1">题目总结：</h3><p>【2015统考真题】假定主存地址为32位，按字节编址，主存和Cache之间采用直接映射方式，主存块大小为4个字，每字32位，采用回写方式，则能存放4K字数据的Cache的总容量的位数至少是()</p><ul><li>Cache的容量分为两个部分一个是数据存储容量+标记阵列容量</li><li>标记阵列中一定包含有效位和标记位，若为回写法，则还存在一位的”脏位“，若为LRU、LFU替换算法，则还存在替换算法位（计数器）位数为log2n ,n为Cache的个数。</li><li>本题按照字节编址，则块内地址占4位，采用直接映射方法中的标志位为32-4-10=18，Tag=18。</li><li>采用回写法，有一位脏位，故最终标记项有18+1+1=20</li><li>标记阵列容量为 210×20=20K，数据储存容量为4K×32=128K，故总的为148K。</li></ul><h2 id="第四章-指令系统">第四章 指令系统</h2><h3 id="第一节-指令格式">第一节 指令格式</h3><p>指令概念：又称机器指令，是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。</p><p>一条指令就是机器语言的一个语句，一条指令通常要包括操作码和地址码两部分：操作码主要指明用户干什么，地址码主要指明对谁操作。</p><p>一、指令分类</p><p>按操作数个数分：</p><p>Ⅰ、零地址指令：不需要操作数，如空操作、停机、关中断等指令</p><p>Ⅱ、一地址指令：只需要单个操作数，如自增，自减，取反，求补，需要两个操作数，但其中一个隐含在某个寄存器中</p><p>Ⅲ、二地址指令：常用于两个操作数的算术运算、逻辑运算相关指令。</p><p>完成一条指令需要访存四次，分别为取值，读第一个操作数，读第二个操作数，写回第一个操作数。</p><p>Ⅳ、三地址指令：常用于两个操作数的计算，结果放在第三个地址中。</p><p>完成一条指令需要访存四次，分别为取值，读读一个操作数，读第二个操作数，写到第三个操作数。</p><p>※若指令长度不变，地址码数量越多，寻址能力就越差</p><p>按指令长度是机器指令的多少倍分：</p><p>Ⅰ、半长指令：是机器指令长度一半</p><p>Ⅱ、单字长指令：与机器指令长度一样</p><p>Ⅲ、双字长指令：是机器指令长度两倍</p><p>二、扩展操作码指令格式（考点：会设计指令系统）</p><p>概念：指令是定长的，但是操作码的长度可变。</p><p>通常情况下，使用频率高的指令使用短的操作码，减少指令译码和分析的时间。而使用频率低的指令使用长的操作码</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031516505.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>定长指令和扩展操作码的比较</p><table><thead><tr><th></th><th>定长操作码</th><th>扩展操作码</th></tr></thead><tbody><tr><td>优点</td><td>硬件设计简单，识别速度快</td><td>在指令长度限制下仍有丰富指令</td></tr><tr><td>缺点</td><td>指令难以增加，不灵活</td><td>增加指令译码和分析难度，速度慢</td></tr></tbody></table><p>【2017统考真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令29条、二地址指令107条，每个地址字段为6位，则指令字长至少应该是()。</p><p>解答：三地址29条需要的位数是5位，多出3位，而107条需要6位。故总共5+6+12=23，因为按照字节编址，所以最少需要24位。</p><h3 id="第二节-寻址方式重点">第二节 寻址方式（重点）</h3><p>一、指令寻址（由PC指出）</p><p>Ⅰ、顺序寻址</p><p>PC+”1“，这里的1指指令字长，每次取值结束后PC会+1</p><p>Ⅱ、跳跃寻址</p><p>执行转移类指令导致的PC值改变</p><p>二、数据寻址（由本条指令的地址码指明真实地址）</p><p>非偏移指令</p><table><colgroup><col style="width: 12%" /><col style="width: 28%" /><col style="width: 16%" /><col style="width: 21%" /><col style="width: 21%" /></colgroup><thead><tr><th>寻址方式</th><th>有效地址</th><th>优点</th><th>缺点</th><th>访存次数（指令执行期间）</th></tr></thead><tbody><tr><td>直接寻址</td><td>操作数的真实地址</td><td>简单</td><td>限制寻址范围</td><td>1</td></tr><tr><td>间接寻址</td><td>操作数地址的地址</td><td>可扩大寻址范围</td><td>指令在执行阶段要多次访存</td><td>最少2次</td></tr><tr><td>寄存器寻址</td><td>寄存器的地址</td><td>不访问主存，速度快</td><td>寄存器昂贵</td><td>0</td></tr><tr><td>寄存器间接寻址</td><td>寄存器地址，内部是操作数主存地址</td><td>与一般的间址快</td><td>但执行仍然会访存</td><td>1</td></tr><tr><td>隐含寻址</td><td>指令中隐含操作数地址</td><td>有利于缩短指令字长</td><td>需要增加存储操作数的硬件</td><td>0</td></tr><tr><td>立即寻址</td><td>就是操作数本身</td><td>最快</td><td>限制操作数范围</td><td>0</td></tr></tbody></table><p>偏移寻址（重中之重）</p><p>指令执行过程中，都会在将运算结果放入主存中，涉及一次访存。</p><p>Ⅰ、基址寻址</p><p>将CPU中基址寄存器(BR)/通用寄存器的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031516686.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>※采用通用寄存器作为基址寄存器 R0的位数，根据通用寄存器的总数判断，程序运行前，CPU将BR的值修改为该程序的起始地址。</p><ul><li>基址寄存器是面向操作系统的，其内容由<strong>操作系统或管理程序</strong>确定。用户无法修改，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。</li><li>当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由<strong>操作系统</strong>确定。</li><li>优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）</li></ul><p>Ⅱ、变址寻址</p><p>有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA=(IX)+A，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031516473.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>变址寄存器是面向用户的，在执行过程中，变址寄存器的内容可由用户改变（IX作为偏移量），形式地址A不变（作为基地址）。刚好与基址寻址相反。</li><li>在针对<strong>数组处理</strong>过程中，不断改变IX的值，便很容易形成数组中任一数据的地址，特别适合<strong>编制循环程序</strong>。</li><li>基址变址复合执行。EA=(IX)+(BR)+A。</li></ul><p>Ⅲ、相对寻址</p><p>相对寻址：把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(PC)+A，其中A是相对于PC所指地址的位移量，可正可负，补码表示。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031516876.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>优点：这段代码在程序内浮动时不用更改跳转指令的地址码</li><li>相对寻址广泛应用于转移指令</li><li>注意：对于JMPA转移指令，当从CPU中取出一字节时，会自动执行PC+1。若指令的地址为X，且占2B，在取出该指令后，会自定跳转到X+2+A。</li></ul><p>堆栈寻址</p><p>操作数存放在堆栈中，隐含使用堆栈指针作为操作数地址。</p><ul><li>硬堆栈是将寄存器作为栈，成本很高；软堆栈是将主存作为栈，成本低。</li><li>硬堆栈不访存，软堆栈访存一次</li></ul><h3 id="第三节-高级语言程序与机器级代码之间的对应">第三节高级语言程序与机器级代码之间的对应</h3><p>一、基本概念</p><ul><li>对操作数的操作地址只涉及三种：寄存器到寄存器，主存到寄存器，立即数到寄存器。</li><li>dword 32bit ；word 16bit ；byte 8bit</li><li>通用寄存器 eax ebx ecx edx 变址寄存器 esi edi 堆栈寄存器 ebpesp。</li></ul><p>二、选择结构语句的机器级表示</p><table><thead><tr><th>je</th><th>jump when equal,</th></tr></thead><tbody><tr><td>jne</td><td>jump when not equal,</td></tr><tr><td>jg</td><td>jump when greater,</td></tr><tr><td>jge</td><td>jump when greater or equal</td></tr><tr><td>jl</td><td>jump when less</td></tr><tr><td>jle</td><td>jump when less or equal</td></tr></tbody></table><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031517444.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>例如</p><blockquote><p>cmp eax ,ebx #比较寄存器eax和ebx里的值 jg NEXT#若eax&gt;ebx，则跳转到NEXT</p></blockquote><p>三、循环结构语句的机器级表示</p><p>用条件指令实现循环</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031517116.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>用loop指令实现循环</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031517380.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>就是将”某些处理“封装到了Looptop内，使得代码更加简洁。</p><p>四、CISC和RISC</p><table><thead><tr><th>对比项目</th><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>指令系统</td><td>复杂，庞大</td><td>简单，精简</td></tr><tr><td>指令数目</td><td>一般大于200条</td><td>一般小于100条</td></tr><tr><td>指令字长</td><td>不固定</td><td>定长</td></tr><tr><td>可访存指令</td><td>没有限制</td><td>只有Load/Store指令</td></tr><tr><td>各种指令执行时间</td><td>相差较大</td><td>绝大多数在一个周期内完成</td></tr><tr><td>各指令使用频率</td><td>有的常用，有点不常用</td><td>一般都常用</td></tr><tr><td>通用寄存器的数量</td><td>较少</td><td>多</td></tr><tr><td>控制方式</td><td>绝大多数为微程序控制</td><td>绝大多数为组合逻辑控制</td></tr><tr><td>指令流水线</td><td>可以通过一定方式实现</td><td>必须实现</td></tr></tbody></table><h2 id="第五章-中央处理器">第五章 中央处理器</h2><h3 id="第一节-cpu">第一节 CPU</h3><p>一、CPU的结构</p><p>CPU由运算器和控制器组成。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031517284.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>二、CPU的功能</p><p>指令控制、操作控制、时间控制、数据加工、中断处理。</p><p>运算器的功能：对数据加工</p><p>控制器的功能：取指令、分析指令、执行指令</p><h3 id="第二节-指令执行过程">第二节 指令执行过程</h3><p>在指令周期中，包含了：取指周期，在取指周期后需要判断是否有间址周期，如果没有就进入到执行周期，在执行周期后又需要判断是否有中断程序，如果有就响应中断并保存断点生成中断服务程序入口；如果没有就进入下一个取指周期。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031517776.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>四个周期都有CPU访存操作，只是访存目的不同。取值周期是取指令；间址周期是取有效地址；执行周期是为了取操作数；中断周期是为了保存程序断点。</p></blockquote><p>指令周期常常有若干个机器周期，机器周期里面又包含若干个时钟周期。每个指令周期内的机器周期可以不同，机器周期内的时钟周期也可以不同。时钟周期是CPU操作的最基本单位。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031518441.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>一、取值周期</p><p>取指周期：取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中。而PC中存放的是指令的地址，根据这个地址从内存单元取出的是指令，并放在指令寄存器IR中，取指令的同时，PC加1。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031518073.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>二、间址周期</p><p>间址周期：间址周期的任务是取操作数有效地址，以一次间址为例，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031518137.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>三、执行周期</p><p>执行周期：执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。</p><p>指令执行方案：</p><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr><th>单指令周期</th><th>所有指令选用相同的执行时间（取决于最长指令执行时间），指令间串行，但原本只需要很短时间完成指令也分配了很长时间，降低整个系统运行速度</th></tr></thead><tbody><tr><td>多指令周期</td><td>对不同指令选用不同的执行时间，需要更复杂的硬件设计，指令间是串行</td></tr><tr><td>流水线</td><td>在每个时钟周期让多个指令同时运行，指令间是并行</td></tr></tbody></table><p>四、中断周期</p><p>中断周期：中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031518284.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="第三节-数据通路的功能和基本结构">第三节数据通路的功能和基本结构</h3><p>一、数据通路的基本结构</p><p>Ⅰ：CPU内部单总线方式。将所有寄存器的输入端和输出端都连接在一条公共通路上。易发生冲突。</p><p>Ⅱ：双总线/多总线方式。多个总线上传不同的数据，提高效率。</p><p>Ⅲ：专用数据通路方式。专门给某些部件设计通路。性能很高但是硬件量大。</p><p>说明：</p><p>①对于单总线的连接方式来说，ALU只能有一端与总线相连，因为两端相连就必会发生冲突。所以另一段要设计一个暂存器，先把数据放入暂存器，暂存器再与总线相连。</p><p>②单周期就是指令在一个周期内完成，这是需要与多总线结构配合。才能使各个部件的数据传递。因为单总线一个周期内只能传递一个数据，所以指令不可能在一个周期内完成。</p><table><thead><tr><th>内部总线</th><th>是指同一部件，如CPU内部连接各个寄存器及运算部件之间的总线</th></tr></thead><tbody><tr><td>系统总线</td><td>指同一台计算机的各部件，如CPU，主存，I/O之间连接的总线</td></tr></tbody></table><h3 id="第四节-控制器的功能和工作原理">第四节控制器的功能和工作原理</h3><p>一、硬布线控制器</p><p><em>多提一嘴，一定要看看王道视频是如何设计出组合逻辑图的，我保证看完一定会有颠覆性的收获。</em></p><p><strong>根据指令操作码、目前的机器周期、节拍信号、机器状态条件，即可确定现在这个节拍应该发出哪些”微命令“</strong></p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031518649.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>硬布线控制器的特点：</p><ul><li>指令越多，设计和实现就越复杂（逻辑图很复杂），因此一般使用RISC。</li><li>如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较为困难。</li><li>由于使用存纯硬件实现控制，因此执行速度很快。</li></ul><p>二、微程序控制器（重难点）</p><p>要求：会基本概念微命令与微操作，微指令与微周期，主存储器与控制存储器，程序与微程序，MAR与CMAR，IR与CMDR。还会一些基本结构，比如为地址形成部件，微地址寄存器CMAR，微指令寄存器CMDR,控制存储器CM。</p><ul><li><strong>微命令</strong>：控制器部件向执行部件发出的控制命令，是构成控制序列的最小单位，例如打开或者关闭控制门的电位信号。是各部件完成某个基本微操作的命令</li><li><strong>微操作</strong>：执行部件接受微命令后所进行的操作，和微操作是一一对应的。（实际上，微命令是微操作的控制信号，微操作是微命令的执行过程，微操作是执行部件中最基本的操作）</li><li><strong>微指令</strong>：若干微命令的集合，存放在一个控制存储器中，而<strong>存放微指令的控制存储器的单元成为微地址</strong>。在同一CPU周期内，<strong>并行执行的一组微命令，存储在控制存储器上面，称为一条微指令</strong>。</li><li><strong>微周期</strong>：从读取一条微指令，到执行执行完毕所需要的时间称为微周期。</li><li><strong>控制存储器</strong>：<strong>主存储器</strong>，主要用来存放程序和数据，位于CPU的外部，使用的是RAM。而<strong>控制存储器，则主要用于存储微程序，位于CPU内部，采用的是ROM</strong>。</li><li><strong>微程序</strong>：实现一条机器指令功能的微指令序列。</li><li><strong>程序与微程序</strong>：程序由机器指令构成，编写好以后放到主存中运行，可以改写。而微程序由微指令构成，事先编写好在CM（控制存储器）中，一般是不可改写的。微程序的作用就是实现一条对应的机器指令。</li><li>微程序&gt;微指令&gt;微命令=微操作是微命令的执行过程。</li></ul><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031519580.png"alt="img" />秒懂哦</p><ul><li>一台计算机可以分为控制部件和执行部件。其中控制部件有指令寄存器，程序计数器，操作控制器，执行部件有运算器，存储器，外围设备，状态条件寄存器。</li><li>汇编程序员可见的寄存器有基址寄存器和状态/标志寄存器，程序计数器PC及通用寄存器。而MAR,MDR,IR,是CPU内部寄存器，汇编程序员不可见，微指令相关的汇编程序员也不可见。</li></ul><p>水平型微指令的编码方式（重点会考）</p><p><strong>①字段直接编码</strong>对于直接编码的方式最大的好处就是能够并行微操作，缩短了微命令的字段长度。有个题能很好的解释这其中的原因。某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码方式，共有33歌微命令，构成5个互斥类，分别包含7，3，12，5和6个微命令，则操作控制字段至少有几位？</p><p><strong>每个互斥类要留1个状态位不操作</strong>，故为8，4，13，6，7个微命令。则需要3，2，4，3，3位共15位控制字段，而直接控制法要33位。很明显的缩减操作字段位数。</p><p>优点明显，缺点也明显啊。增加了译码，执行时间会增长，而却增大成本。</p><p>②<strong>直接编码</strong>就是每个控制字段位，就代表一个微命令，优点就是快，电力嘎嘎简单。但是若微命令要是多达几百条。那不是要几百位了。因此指令位数太长。</p><p>③某带有中断的指令系统有101中操作，采用微程序控制方式，存储器中相应最少有103个微程序。</p><p><strong>要加上取值操作和终端操作，</strong>若有n条操作，则有<strong>n+2个微程序</strong></p><p>④下一条微指令的形成方法常考的：<strong>断定法（根据当前执行的微指令寻找到下一条微指令）和计数器法（类似PC）</strong></p><h3 id="第五节-异常和中断机制">第五节 异常和中断机制</h3><p><em>这节会在后面第七章一起讲</em></p><h3 id="第六节-指令流水线">第六节 指令流水线</h3><p>讲在前面，为什么要引入指令流水线。相信都听说过华强北的流水线运作方式吧。最明显的优点就是相较于顺序执行的吞吐量更大（单位时间内）运行相同数量的指令也更快。效率也更高。</p><p>这里就可以知道指令流水线的概念：<strong>把指令执行过程划分为不同的阶段，占用不同的资源，就能使多条指令同时执行</strong>。</p><p>①在流水执行的过程中，会经常遇到冲突，包括结构冲突，<strong>数据冲突</strong>，控制冲突。</p><table><colgroup><col style="width: 4%" /><col style="width: 35%" /><col style="width: 23%" /><col style="width: 35%" /></colgroup><thead><tr><th></th><th>结构相关/冲突/冒险</th><th>数据相关/冲突/冒险</th><th>控制相关/冲突/冒险</th></tr></thead><tbody><tr><td>概念</td><td>多条指令在同一时刻争用同一资源</td><td>下一条指令会用到当前指令计算的结果</td><td>遇到执行转移、调用、返回导致PC中断</td></tr><tr><td>处理办法</td><td>1.单独设置数据存储器和指令存储器，使取数和取值操作在不同的存储器中进行2.暂停时钟周期</td><td>1.暂停时钟周期 2.数据旁路技术 3.编译优化</td><td>1.早判断，早生成 2.预取转移成功和不成功两个控制流方向的目标指令3.加快和提前形成条件码 4.提高转移方向的猜准率</td></tr></tbody></table><p>②<strong>五段式指令流水线（超重要）</strong></p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031519289.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>顾名思义，五段分为IF(取值),ID(译码&amp;取数),EX(执行),M(访存),WB(写回寄存器)</p><p>只有上一条指令进入ID段后，下一条指令才能开始IF段，否则会覆盖IF段锁存器的内容</p><p>考试中常见的五类指令：</p><p><strong>Ⅰ、运算类指令的执行过程</strong></p><p>IF：根据PC从指令Cache取指令至IF段的锁存器</p><p>ID：取出操作数至ID段的锁存器</p><p>EX：运算，将结果存入EX段锁存器</p><p>M：空段</p><p>WB：将运算结果写回指定的寄存器</p><p><strong>Ⅱ、LOAD指令执行过程</strong></p><p><strong>作用</strong>：load指令可以完成将数据从存储器中复制到目的寄存器中，会访存</p><p>IF：根据PC从指令Cache取指令至IF段的锁存器</p><p>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到lmm</p><p>EX：运算，得到有效地址</p><p>M：从数据Cache中取数并放入锁存器</p><p>WB：将运算结果写回指定的寄存器</p><p><strong>Ⅲ、STORE指令执行过程</strong></p><p><strong>作用：</strong>将数据从寄存器中，复制到存储器中，会访存</p><p>IF：根据PC从指令Cache取指令至IF段的锁存器</p><p>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到lmm。将要存的数放到B</p><p>EX：运算，得到有效地址。并将锁存器B的内容放到锁存器Store</p><p>M：写入数据Cache</p><p>WB：空段</p><p><strong>Ⅳ、条件转移指令执行过程</strong></p><p>IF：根据PC从指令Cache取指令至IF段的锁存器</p><p>ID：进行比较的两个数放入锁存器A，B；偏移量放入lmm</p><p>EX：运算，比较两个数</p><p>M：将目标PC值写回PC</p><p>WB：空段</p><p><strong>Ⅴ、无条件转移指令的执行过程</strong></p><p>IF：根据PC从指令Cache取指令至IF段的锁存器</p><p>ID：偏移量放入lmm</p><p>EX：将目标PC值写回PC</p><p>M：空段</p><p>WB：空段</p><p>针对条件转移指令和无条件转移指令做以下说明：写入PC的好事比EX更短，可以安排在EX段时间内完成。越<strong>早完成就越能避免控制冲突</strong>。当然也有在WB段修改PC值的</p><h3 id="题目总结-2">题目总结：</h3><p>①流水CPU是由一系列叫做“段”的处理线路组成的。一个m段流水线稳定时的CPU的吞吐能力，与m个并行部件的CPU的吞吐能力相比<strong>具有相同的吞吐能力</strong></p><p>原因是当流水线稳定后，说明已经进行了一条指令，往后每多一个时钟周期就多一条指令执行成功。</p><p>m个并行平均下来也是一个时针周期就多条指令</p><p>故具有相同的吞吐能力，但是流水线的方式，结构实现较为简单。</p><h3 id="第七节-多处理器的基本概念选择题">第七节多处理器的基本概念（选择题）</h3><p>这节的要求就是明白基本概念</p><p>①SISD（单指令流单数据流）</p><p>特点：只能并发，不能并行，每条指令处理一个指令</p><p>不是数据级并行技术</p><table><colgroup><col style="width: 2%" /><col style="width: 17%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 22%" /><col style="width: 25%" /></colgroup><thead><tr><th></th><th>SISD（单指令流单数据流）</th><th>SIMD（单指令多数据流）</th><th>MIMD（多指令多数据流）</th><th>多处理器系统</th><th>多计算机系统</th></tr></thead><tbody><tr><td>特点</td><td>不是数据级并行技术</td><td>是一种数据级并行技术</td><td>是一种线程级并行技术</td><td>多个处理器共享单一物理地址空间</td><td>每台计算机拥有私有存储器，相互独立</td></tr><tr><td>特征</td><td>一条指令处理一个数据</td><td>一条指令处理多个数据</td><td>多条指令处理多个数据</td><td>多个处理器+一个主存储器</td><td>多个处理器+多个主存储器</td></tr></tbody></table><ul><li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。</li><li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。</li></ul><p>并发不是并行。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。（你学废了吗？）</p><h2 id="第六章-总线">第六章 总线</h2><h3 id="第一节-总线的概述">第一节 总线的概述</h3><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031519278.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>片内总线：芯片内部的总线，是CPU芯片内部寄存器与寄存器之间，寄存器与ALU之间的公共连接线</li><li>系统总线：计算机系统内部功能部件（CPU、主存、I/O接口）之间相互连接的总线，可分为三类，数据总线，地址总线，控制总线</li><li>通信总线：计算机系统之间或计算机系统与其它系统之间的信息传送的总线</li></ul><table><colgroup><col style="width: 21%" /><col style="width: 28%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr><th></th><th>数据总线</th><th>地址总线</th><th>控制总线</th></tr></thead><tbody><tr><td>功能</td><td>传输数据信息</td><td>传输地址信息</td><td>传输控制信息</td></tr><tr><td>大小与什么有关</td><td>机器字长、存储字长</td><td>主存地址空间大小</td><td>传输一个信号</td></tr><tr><td>方向</td><td>双向</td><td>单向</td><td>既有双向也有单向</td></tr></tbody></table><table><colgroup><col style="width: 5%" /><col style="width: 22%" /><col style="width: 38%" /><col style="width: 33%" /></colgroup><thead><tr><th>总线结构</th><th>单总线（常用）</th><th>双总线</th><th>三总线</th></tr></thead><tbody><tr><td>内容</td><td>系统总线</td><td>主存总线、I/O总线</td><td>主存总线、I/O总线、DMA总线</td></tr><tr><td>结构</td><td>CPU、主存、I/O设备都连接在一组总线上</td><td>主存总线用于CPU，主存之间的传送；I/O总线用于多个外部设备与通道之间进行传送</td><td>多加的一条DMA总线是用于主存访问高速外设</td></tr><tr><td>优点</td><td>结构简单，成本低，易于接入新的设备</td><td>将较低速的I/O设备从单总线分离出来，实现存储器总线和I/O总线分离</td><td>更加提高了I/O设备的性能，更快响应命令，提高系统吞吐量</td></tr><tr><td>缺点</td><td>带宽低，负载重，不支持并发传送操作</td><td>需要增加硬件设备</td><td>系统工作效率低，同一时刻只能一个总线工作</td></tr></tbody></table><h3 id="第二节-性能指标">第二节 性能指标</h3><p>写一些会考的性能指标，配合相应的题</p><h3 id="第三节-总线定时方式">第三节 总线定时方式</h3><table style="width:100%;"><colgroup><col style="width: 3%" /><col style="width: 20%" /><col style="width: 38%" /><col style="width: 12%" /><col style="width: 25%" /></colgroup><thead><tr><th></th><th>同步通信</th><th>异步通信</th><th>半同步通信</th><th>分离式通信</th></tr></thead><tbody><tr><td>特点</td><td>由统一时钟控制数据传送</td><td>采用应答方式，没有公共时钟的标准</td><td>同步、异步结合</td><td>充分挖掘系统总线每瞬间的潜力</td></tr><tr><td>优点</td><td>传送速度快</td><td>保证两个工作速度相差很大的部件之间进行传输</td><td></td><td></td></tr><tr><td>缺点</td><td>强制性同步</td><td>复杂，慢</td><td></td><td></td></tr></tbody></table><p>补充：关于异步通信还分为三类：不互锁，速度最快，可靠性最差；半互锁；全互锁。速度最慢，可靠性最好。</p><h2 id="第七章-io系统">第七章 I/O系统</h2><h3 id="第一节-io接口">第一节 I/O接口</h3><p>简单来说，<strong>I/O接口就是负责协调主机与外部设备之间的数据传输</strong>。</p><p>可以这样理解就是你的电脑，怎么控制你的U盘上，做一些读写操作。U盘不是“亲儿子”啊，所以要单独给它设置接口来控制它。</p><p>CPU那如何确定要操作的是主存还是外部设备呢。这就引出了编制方式——统一编制和独立编址</p><table><colgroup><col style="width: 3%" /><col style="width: 48%" /><col style="width: 48%" /></colgroup><thead><tr><th></th><th>统一编制</th><th>独立编制</th></tr></thead><tbody><tr><td>内容</td><td>把外部设备的存储当成内存进行分配，有统一的地区分配，靠不同的地址区别内存和外部设备</td><td>独立编制，专门为输入/输出指令设置访问端口，靠不同指令区别内存和外部设备</td></tr><tr><td>优点</td><td>1.不需要专门的指令表示访问外存 2.读写控制电路简单3，程序设计灵活性高</td><td>1.地址译码快 2.不占用主存地址空间</td></tr><tr><td>缺点</td><td>1.端口占用了主存地址空间，使主存地址空间变小2.寻址时间长（外部设备）</td><td>1.程序设计灵活差 2.指令增加，控制电路复杂</td></tr></tbody></table><p>补充个会考的内容，关于显存VRAM（就是显示存储器）</p><p>显存是为了提高刷新图像的信号，会提前把需要显示的数据放入显存中。如今的计算机很多都有独立显存，就这可以避免，显存占用主存的空间。</p><p>显存会考的计算：</p><p>容量=分辨率×灰度级位数</p><p>带宽=分辨率×灰度级位数×帧数</p><h3 id="第二节-主机访问io设备的控制方式">第二节主机访问I/O设备的控制方式</h3><p><strong>一、程序查询方式</strong></p><p>特点：CPU与I/O串行工作，CPU不断查询I/O设备状态，直到外设准备就绪。</p><p>优点：接口设计简单，设备量少。</p><p>缺点：CPU信息传送过程中要花费很多时间用于查询和等待，而且在一段时间内只能和一台外设交换信息，效率低。</p><p>独占查询：CPU100%的时间都在查询I/O状态，完全串行。</p><p>定时查询：每隔一段时间CPU就查询I/O状态，查询的间隔内CPU可以执行其他程序。</p><p><strong>二、中断方式</strong></p><p>Ⅰ、程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中断现行程序，而转去执行这些异常情况或特殊请求进行处理。处理完毕后又自动返回到现行程序的断点处，继续执行原程序。</p><p>引出几个问题：</p><p>问题一：接收到中断信号后是怎么转到执行中断程序的？</p><p>问题二：中断程序执行完后是怎么回来执行原先程序的？</p><p>问题三：假如有多个程序断源同时申请，怎么专门安排优先顺序？</p><p>问题四、如何判断是哪个设备发来的中断信号？</p><p>Ⅱ、*<strong>整个中断方式的流程（重点）*</strong></p><p>1.中断请求</p><p><em>“先说明开中断和关中断的作用，关中断保证原子操作，不会被打断，标志位IF=1为开中断（允许中断）”</em></p><p>CPU在统一时刻每条指令执行阶段结束前向接口发出中断查询信号，获取I/O的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。</p><p>如何判断是哪个设备发来的中断信号？</p><p>会存在一个中断请求标记寄存器，里面不同位代表不同的设备中断。状态位为1的话，代表处理中断申请。</p><p>CPU响应中断必须满足以下3个条件：</p><p>①中断源有中断请求。</p><p>②CPU允许中断即断开中断。</p><p>③一条指令执行完毕，且没有更紧迫的任务。</p><p>2.中断响应</p><p>假如有多个程序断源同时申请，怎么专门安排优先顺序？</p><p>有两种处理办法：</p><p>①硬件实现硬件排队器</p><p>②软件实现查询程序</p><p>中断的优先级：</p><p>硬件故障中断&gt;软件中断</p><p>非屏蔽中断&gt;可屏蔽中断</p><p>DMA请求&gt;I/O设备传送的中断请求</p><p>有再补充</p><p>3.中断处理</p><p>接收到中断信号后是怎么转到执行中断程序的？</p><p>这时候就需要中断隐指令：保存原程序的PC值，并让PC指向中断程序的第一条。</p><p><strong>中断隐指令的任务：</strong></p><p><strong>①关中断。在中断服务程序中，为保护中断现场不会再被新的中断打断，就必须关中断</strong></p><p><strong>②保存断点。保证“回得来”</strong></p><p><strong>③引出中断服务。将中断服务程序入口地址传送给程序计数器</strong></p><p>引出中断服务，如何将中断传给PC？</p><p>通过硬件向量法，将硬件（中断向量地址形成部件）产生向量地址，再由向量地址找到入口地址。</p><p>中断处理过程—硬件向量法。为什么要用向量地址去寻找中断的入口，而不是直接去寻找中断入口？</p><p>1.若是通过中断向量地址形成部件直接去入口地址的话，会造成中断程序有时候长短不一，就要频繁修改中断向量地址形成部件。</p><p>2.若是先通过向量地址，在内存中找到中断地址的话，只需修改内存的地址就可以。</p><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031519609.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>中断服务程序的任务</strong></p><p><strong>①保护现场。保存通用寄存器和状态寄存器的内容。</strong></p><p><strong>②中断服务。主体部分。例如将需要打印的字符传送到打印机的缓冲存储器中。</strong></p><p><strong>③恢复现场。通过出栈或取值把之前保存的信息传送回寄存器中。</strong></p><p><strong>④中断返回。通过中断返回指令回到原程序断点处。</strong></p><p>总结：中断处理过程=中断隐指令+中断服务程序</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031519437.png"alt="img" />中断流程</p><p>Ⅲ、单重中断和多重中断</p><p>单重中断：执行中断服务程序时不响应新的中断请求。</p><p>多重中断：又称中断嵌套，执行中断服务程序时可响应新的中断请求。</p><p>对于多重中断有中断屏蔽技术，在中断服务开启前打开中断指令。优先级别高的中断源有权中断优先级别低的中断源。</p><p>这时候就要设置一个屏蔽触发器，1表示屏蔽该中断请求，0表示正常申请，所有屏蔽触发器构成一个屏蔽寄存器，屏蔽寄存器里面内容就是屏蔽字。</p><p>有以下几个说明</p><p>①每个中断源至少有一个1（对自身中断源）</p><p>②1越多，优先级越高</p><p><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031519316.png"alt="img" />看懂这个例题就够了</p><p><strong>三、DMA方式</strong></p><p>DMA的特点：</p><p>1、内存既可以被CPU访问也可以被DMA控制器访问，CPU和DMA控制器会竞争总线的使用权，因而需要仲裁机制。</p><p>2、外部设备与内存之间的整个数据交换过程全部在DMA控制器的控制下完成，CPU能够与外部设备并行工作，大大提高了效率。</p><p>3、在DMA方式开始之前CPU要对DMA控制器进行初始化，在DMA方式结束之后，CPU要申请中断，对内存缓冲区进行后处理。</p><p>DMA的处理方式：</p><p>1.预处理：CPU完成寄存器初值设置等准备工作。</p><p>2.数据传输：CPU继续执行主程序，DMA控制器完成数据传送</p><p>3.后处理：CPU执行中断服务程序做DMA结束处理</p><p>DMA的传送方式：</p><p>1.停止CPU访存：需要传送数据时，停止CPU访存，总线控制器交给DMA控制器。</p><p>2.周期挪用方式：当I/O接口没有DMA请求时，CPU按程序要求访问内存；一旦I/P接口有DMA请求，则I/O接口挪用一个或几个周期。缺点是：数据输入或输出过程中实际占用了CPU时间。</p><p>3.交替访存方式：CPU与DMA控制器交替访问内存。不需要总线使用权的申请、建立和归还过程。</p><p>效率高，但实现起来有困难，基本上不被使用。</p><ul><li>DMA与中断方式的差别</li></ul><table><colgroup><col style="width: 9%" /><col style="width: 36%" /><col style="width: 53%" /></colgroup><thead><tr><th></th><th>中断</th><th>DMA</th></tr></thead><tbody><tr><td>数据传送</td><td>程序控制</td><td>硬件控制—DMA控制器。CPU只需进行预处理和后处理</td></tr><tr><td>中断请求</td><td>传送数据</td><td>向CPU报告传输结束</td></tr><tr><td>响应</td><td>指令执行周期结束后响应中断</td><td>每个机器周期结束都可，即总线空闲即可</td></tr><tr><td></td><td></td><td></td></tr><tr><td>适用场景</td><td>CPU控制，低速设备</td><td>DMA控制器控制，高速设备</td></tr><tr><td>优先级</td><td>低于DMA</td><td>高于中断</td></tr><tr><td>工作方式</td><td>CPU与外设并行，传送与主程序串行</td><td>CPU与外设并行，传送与主程序并行</td></tr><tr><td>请求内容</td><td>请求的是CPU处理时间</td><td>请求的是总线使用权</td></tr></tbody></table><ul><li>中断的分类：</li></ul><figure><imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202210031520925.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】使用阿里云OSS+CDN搭建图床（未写）</title>
      <link href="/posts/43138.html"/>
      <url>/posts/43138.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】高等数学同济版重点题目</title>
      <link href="/posts/28079.html"/>
      <url>/posts/28079.html</url>
      
        <content type="html"><![CDATA[<p>Hello，大家好，我们年后又回来啦~~<sub>不负之前所承诺，我把同济高等数学（第七版）的重点习题已经全部整理完毕，大家可以放心食用啦</sub></p><p>新的一年，新的开始，冲鸭~~~</p><p>第一章 函数与极限</p><p>第一节 函数与映射</p><p>重点题：5,6,7,8 理解单调性、奇偶性、周期性 13 复合函数</p><p>第二节 数列的极限</p><p>重点题：2,3 理解极限的概念 6,7,8 难 不会做可以背结论</p><p>第三节 函数的极限</p><p>大多数题与考研要求不相符，可以背10，11的结论。</p><p>第四节 无穷小与无穷大</p><p>重点题：4 简单计算 5 熟悉函数极限6,7 分辨有界、无界与无穷大8铅直渐近线</p><p>第五节 极限运算法则</p><p>重点题：1,2,3 练习计算 4,5 理解极限运算法则</p><p>第六节 极限存在准则 两个重要极限</p><p>重点题：1,2 练习计算 4 极限存在准则的应用（重点）</p><p>第七节 无穷小的比较</p><p>简单且基础，可以全做</p><p>第八节 函数的连续性与间断点</p><p>重点题：1-5 熟悉概念 6-8 较难，可以把例子记下来。</p><p>第九节 连续函数的运算与初等函数的连续性</p><p>重点题：1-4 训练计算 5 熟悉概念，记反例 6 计算</p><p>第十节 闭区间上连续函数的性质</p><p>重点题：1-5 零点定理与介值定理的使用</p><p>总习题一</p><p>除了第8题不属于考研类型，其余题都可以做。</p><p>第二章 导数与微分 第一节 导数概念</p><p>全做，都是考研会涉及的内容。</p><p>第二节 函数的求导法则</p><p>除了第12题，全做。</p><p>第三节 高阶导数</p><p>全做，练计算。</p><p>第四节 隐函数及由参数方程所确定的函数的导数 相关变化率</p><p>除了第3题和第4题可以只做一部分，第9题可以不做以外，其余可以全做，包括相关变化率的应用题。</p><p>第五节 函数的微分</p><p>重点题：2,3,4,5,6</p><p>总习题二</p><p>除了第15，17,18题外，全做。</p><p>第三章 微分中值定理与导数的应用 第一节 微分中值定理</p><p>除了第1-4,13题外，全做。</p><p>第二节 洛必达法则</p><p>全做，第2题和第3题可以积累例子。</p><p>第三节 泰勒公式</p><p>重点题：6,10.第6题可以记一下结论。</p><p>第四节 函数的单调性与曲线的凹凸性</p><p>重点题：1-4 判定单调性 5 利用单调性证明不等式6利用单调性分析方程的根7 记结论 积累例子8 证明9-10 凹凸性的判定13-15拐点16 记结论</p><p>第五节 函数的极值与最大值最小值</p><p>重点题： 1 计算 3 极值 4 记结论 6-9 最值 11-12 应用题</p><p>第六节 函数图形的描绘</p><p>除了第5题外，全做。</p><p>第七节 曲率</p><p>数一数二同学可以做1-4题。数三同学不用做。</p><p>第八节 方程的近似解</p><p>不在考研范围，不用做。</p><p>总习题三</p><p>除了第11,16,17题外，都可以做。</p><p>第四章 不定积分 除了第五节积分表的使用不需要做外，其余习题都可以做。</p><p>第五章 定积分 第一节 定积分的概念与性质 重点题：3 定积分的几何意义 8水压力 11-12 定积分不等式证明 13 定积分比较大小</p><p>第二节 微积分基本公式 全做</p><p>第三节 定积分的换元法和分部积分法 全做</p><p>第四节 反常积分 全做，练习反常积分的计算。</p><p>第五节 反常积分的审敛法 伽马函数 重点题: 1 判断反常积分的敛散性</p><p>总习题五 重点题：1-15题</p><p>第六章 定积分的应用 第二节 定积分在几何学上的应用 全做–求曲线弧长，求平面图形的面积，旋转体的体积</p><p>第三节 定积分在物理学上的应用 全做</p><p>总习题六 全做</p><p>第七章 微分方程 第一节 微分方程的基本概念 重点题：7 微分方程应用</p><p>第二节 可分离变量的微分方程 重点题：1-2 解微分方程</p><p>第三节 齐次方程 重点题：1-2 解齐次方程</p><p>第四节 一阶线性微分方程 重点题： 1-7 解微分方程 8伯努利方程（仅数一要求掌握）</p><p>第五节 可降阶的高阶微分方程 重点题：1-3 解微分方程</p><p>第六节 高阶线性微分方程 无</p><p>第七节 常系数齐次线性微分方程 重点题：1-2 解微分方程</p><p>第八节 常系数非齐次线性微分方程 重点题：1-2 解微分方程</p><p>第九节 欧拉方程 全做 （仅数一要求掌握）</p><p>总习题七 重点题：1（4）2 微分方程解的结构4（1）（2）（3）（5）（6）（7）（8）数一数二数三都做4（4）（9）仅数一要求做 解微分方程 5（2）（3）（4） 解微分方程 6微分方程的应用 8 导数与微分方程综合题 11 欧拉方程（仅数一要求）</p><p>第八章 向量代数与空间解析几何 第五节 曲面及其方程 重点题： 5-7求旋转曲面的方程</p><p>第六节 空间曲线及其方程 重点题：3-5、7</p><p>总习题八 无</p><p>第九章 多元函数微分法及其应用 第一节 多元函数的基本概念 重点题：6求二元函数的极限 9 二元函数的极限</p><p>第二节 偏导数 除第9题，其余都做。</p><p>第三节 全微分 重点题：1-2 求全微分 5 记结论</p><p>第四节 多元复合函数的求导法则 全做</p><p>第五节 隐函数的求导公式 全做</p><p>第六节 多元函数微分学的几何应用(仅数一要求) 重点题：2-12求曲线的切线以及法平面，曲面的切平面以及法线</p><p>第七节 方向导数与梯度(仅数一要求) 除第9题外，其余都做。</p><p>第八节 多元函数的极值及其求法 重点题：1-11 多元函数的极值</p><p>总习题九 除第7，20题外其余都做，其中19题仅数三要求掌握</p><p>第十章 重积分 第一节 二重积分的概念与性质<br />重点题：2定积分之间的关系、4（2021数一真题同类题型）、5 定积分比大小</p><p>第二节 二重积分的计算方法 重点题：1-2 计算二重积分、5-6二次积分换序、7-10&amp;16-18 重积分的应用（求质量，体积） 12-14极坐标系下计算二重积分、15 计算二重积分</p><p>第三节 三重积分（仅数一要求） 重点题：1 三重积分化累次积分、2求质量、 5-8 求三重积分、9-11 利用球坐标 柱坐标计算三重积分、</p><p>第四节 重积分的应用(涉及到三重积分的仅数一要求)全做。题型：求质心、曲面面积、转动惯量、体积、引力。</p><p>总习题十 重点题：1-4 、7 、9（仅数一要求）、11、12-13 二重积分的应用、14-15三重积分的应用</p><p>注：涉及到三重积分计算的仅数一要求。</p><p>第十一章 曲线积分与曲面积分（仅数一要求） 第一节 对弧长的曲线积分全做 练习计算</p><p>第二节 对坐标的曲线积分 重点题：3-4、7-8 练习计算</p><p>第三节 格林公式及其应用 重点题：2 曲线所围图形的面积、3、 4、 6积分与路径无关 7 利用格林公式计算曲线积分</p><p>第四节 对面积的曲面积分 重点题：4-8</p><p>第五节 对坐标的曲面积分 重点题：3、4</p><p>第六节 高斯公式 *通量与散度 重点题：1、3</p><p>第七节 斯托克斯公式 *环流量与旋度 重点题：2、3、4</p><p>总习题十一 重点题：1-4 7 8</p><p>第十二章 无穷级数（数一数三） 第一节 常数项级数的概念和性质重点题：2</p><p>第二节 常数项级数的审敛法 全做。</p><p>第三节 幂级数 全做。</p><p>第四节 函数展开成幂级数 重点题：5 6</p><p>第七节 傅里叶级数（仅数一要求） 重点题：2、4-6</p><p>总习题十二 重点题：1、2、3、6、8、9、10</p><p>作者：考研数学李艳芳https://www.bilibili.com/read/cv9965206?spm_id_from=333.999.0.0</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】C语言中结构体的比较</title>
      <link href="/posts/60086.html"/>
      <url>/posts/60086.html</url>
      
        <content type="html"><![CDATA[<p>由于C语言里没有运算符重载，只能对结构体的每个成员逐个进行比较，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">LocateElem</span><span class="params">(SqList L,Book e)</span><span class="comment">//查找到和元素e值相同元素并返回其位置序号 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line"><span class="keyword">if</span>(L.elem[i].no[<span class="number">20</span>]==e.no[<span class="number">20</span>]&amp;&amp;</span><br><span class="line">           L.elem[i].name[<span class="number">10</span>]==e.name[<span class="number">10</span>]&amp;&amp;</span><br><span class="line">           L.elem[i].price==e.price)</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是C++的话，就可以对==进行重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LocateElem</span><span class="params">(SqList L,Book e)</span><span class="comment">//查找到和元素e值相同元素并返回其位置序号 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line"><span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">        <span class="keyword">return</span> i<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件分享】最好用的压缩软件Bandizip</title>
      <link href="/posts/18228.html"/>
      <url>/posts/18228.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Bandizip在v7.0加入了广告盈利模式，习惯了无广告的我无奈只好用最后一个无广告的旧版本了</p></blockquote><h3 id="官网介绍">官网介绍</h3><h4 id="主要功能">主要功能</h4><ul><li><p>支持的操作系统: Windows 7/8/8.1/10/11(32bit/64bit/ARM64)</p></li><li><p>集压缩/解压/浏览/编辑为一体的压缩包管理器</p></li><li><p>可以提取包括 RAR/ISO/7Z/ZIP 在内的 30 多种格式</p></li><li><p>可以创建拥有密码和压缩分卷的压缩包</p></li><li><p>支持多个的处理器核心进行高速的解压缩操作</p></li><li><p>对 Windows 11 上下文菜单的支持</p></li></ul><p><imgsrc="https://picture-wq3stone.oss-cn-hangzhou.aliyuncs.com/picgo/202209272152408.png"alt="win11-menu" />]</p><p>（尽管如此我还是喜欢win10的右键菜单样式，可戳此查看<ahref="https://www.wq3stone.cn/posts/1526.html">《win11右键菜单返回win10样式》</a>）</p><h4 id="压缩">压缩</h4><ul><li>支持的格式: ZIP, 7Z(lzma2), ZIPX(xz), EXE(sfx), TAR, TGZ, LZH(lh7),ISO(joliet), GZ, XZ</li><li>修改 ZIP 文件 (添加/删除/重命名)</li><li>支持最高提升 6 倍速的多核解压缩技术</li><li>支持创建加密的压缩包</li><li>支持 AES256 文件加密算法</li><li>支持对 4 GB 以上大小的文件进行压缩</li><li>ZIP 格式的文件名支持 Unicode 以及 MBCS 编码</li><li>支持创建 ZIP/7Z 格式的多卷压缩包</li></ul><h4 id="解压缩">解压缩</h4><ul><li>支持的格式: 7Z, ACE, AES, ALZ, ARJ, BH, BIN, BR, BZ, BZ2, CAB,Compound(MSI), DAA(1.0), DEB, EGG, GZ, IMG, ISO, ISZ, LHA, LZ, LZH,LZMA, PMA, RAR, RAR5, SFX(EXE), TAR, TBZ/TBZ2, TGZ, TLZ, TXZ, UDF, WIM,XPI, XZ, Z, ZIP, ZIPX, ZPAQ, ZSTD, NSIS</li><li>可以轻松地查看压缩包的文件列表</li><li>可以只提取选定的文件，同时还支持拖放解压</li><li>支持 ZIP 和 RAR 格式压缩包的注释</li><li>支持对 TGZ/TBZ 格式进行快速提取</li></ul><h4 id="多样化的功能">多样化的功能</h4><ul><li>支持通过对文件完整性的检查来判断压缩包是否损坏</li><li>支持对代码页进行更改的功能</li><li>可以集成到资源管理器的右键菜单</li></ul><h3 id="下载地址">下载地址</h3><p><a class="wp-block-button__link has-text-color has-background" href="https://www.aliyundrive.com/s/skywQTuhdxE" style="border-radius:2px;background-color:#ba0c49;color:#fffffa" target="_blank" rel="noreferrer noopener">阿里云盘下载【提取码uu58】</a></p><p><a class="wp-block-button__link has-text-color has-background" href="https://pan.baidu.com/s/1bwEBQV4xs1_ZB6nyEg4i5g?pwd=f523" style="border-radius:2px;background-color:#ba0c49;color:#fffffa" target="_blank" rel="noreferrer noopener">百度网盘下载【提取码f523】</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 压缩软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】hexo+github建站</title>
      <link href="/posts/27971.html"/>
      <url>/posts/27971.html</url>
      
        <content type="html"><![CDATA[<h3 id="准备工作">0、准备工作</h3><ul><li>下载安装好node.js和git</li><li>注册登录github</li></ul><h4 id="git绑定用户名和邮箱">git绑定用户名和邮箱</h4><p>在任意文件夹下右键点击Git Bash Here</p><p>执行<code>git config --global user.email "&lt;youremail&gt;"</code>和<code>git config --global user.name "&lt;username&gt;"</code></p><h3 id="搭建仓库">1、搭建仓库</h3><h4 id="填写仓库信息">填写仓库信息</h4><p>★ Repositoryname为<code>&lt;username&gt;.github.io</code>，例如我的用户名为wq3stone我便填写<code>wq3stone.github.io</code>，我已经搭建过了因此会报错</p><p>★一定要选择Public，因为你的网站是对外公开的，选择Private别人就看不见了哦</p><h4 id="最后点击create-repository仓库就搭建好了">最后点击Createrepository仓库就搭建好了</h4><p>现在可以去<code>&lt;username&gt;.github.io</code>参观一下，展现的是<code>README.md</code>文件中的内容</p><h3 id="配置sshkeys">2、配置sshkeys</h3><h4 id="生成sshkeys">生成sshkeys</h4><p>在任意文件夹下右键点击Git BashHere，输入<code>ssh-keygen -t rsa -C &lt;youremail&gt;</code></p><p>这里如果没生成过的话会没有Overwrite那一行</p><h4 id="绑定sshkeys">绑定sshkeys</h4><p>据图中所示目录找到<code>id_rsa.pub</code>文件，用记事本打开全选复制</p><p>然后打开github</p><h4 id="测试是否绑定">测试是否绑定</h4><p>打开Git Bash，输入<code>ssh -T git@github.com</code>（…）</p><hr /><p>以下内容简要概括</p><hr /><h3 id="三本地生成">三、本地生成</h3><h4 id="安装hexo">安装hexo</h4><p><code>npm install -g hexo</code></p><h4 id="初始化hexo">初始化hexo</h4><p><code>hexo init</code></p><h4 id="静态生成本地服务器">静态生成本地服务器</h4><p><code>hexo serve</code>（<code>hexo s</code>）</p><h3id="四_config.yml中的deploy">四、<code>_config.yml</code>中的deploy</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">仓库http地址</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h3id="五装插件npm-install-xxx---save">五、装插件(<code>npm install xxx --save</code>)</h3><p>hexo-deployer-git（必需） hexo-blog-encrypt（文章加密）hexo-generator-baidu-sitemap（生成百度站点地图）hexo-generator-sitemap（生成站点地图） hexo-abbrlink（生成永久链接）</p><h3 id="六生成页面">六、生成页面</h3><p><code>hexo generate</code>（<code>hexo g</code>）</p><h3 id="七上传到github">七、上传到github</h3><p><code>hexo deploy</code>（<code>hexo d</code>）</p><p>该过程需要密码去github的开发者设置中设置token</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【玩转电脑】win11右键菜单返回win10样式</title>
      <link href="/posts/1526.html"/>
      <url>/posts/1526.html</url>
      
        <content type="html"><![CDATA[<p><font color=red>注：2023年8月-此方法疑似失效</font></p><h3 id="通过注册表修改">通过注册表修改</h3><ol type="1"><li>运行（win+R）输入<code>regedit</code>打开注册表编辑器定位到<code>HKEY_CURRENT_USER\SOFTWARE\CLASSES\CLSID</code></li><li>右键点击<code>CLSID</code>键值，新建一个名为<code>&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;</code>的项</li><li>右键点击新创建的项，新建一个名为<code>InprocServer32</code>的项，按下回车键保存</li><li>选择新创建的项，然后双击右侧窗格中的默认条目，什么内容都不需要输入，按下回车键</li><li>保存注册表后，重启<code>explorer.exe</code>即可看到右键菜单恢复成旧样式了</li></ol><p>如果想要恢复成为Win11的设计，那么删掉<code>InprocServer32的</code>项就可以了。</p><h3 id="通过脚本修改">通过脚本修改</h3><p>如果你觉得修改注册表比较麻烦，可以看下这个方法，它的本质也是修改注册表，不过不用你去操作了，脚本自动给你增减表项1.首先建立一个<code>.txt</code>文件，将下面代码拷贝到<code>.txt</code>文件中<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:start</span><br><span class="line">cls</span><br><span class="line">echo,</span><br><span class="line">echo 修改右键菜单模式 www.wq3stone.cn</span><br><span class="line">echo,</span><br><span class="line">echo 1 穿越到Windows 10默认模式</span><br><span class="line">echo,</span><br><span class="line">echo 2 恢复为Windows 11默认模式</span><br><span class="line">echo,</span><br><span class="line">echo 0 什么也不做，退出</span><br><span class="line">echo,</span><br><span class="line">echo,</span><br><span class="line">choice /c:120 /n /m:&quot;请选择要进行的操作（1/2/0）：&quot;</span><br><span class="line">if %errorlevel%==0 exit</span><br><span class="line">if %errorlevel%==2 goto cmd2</span><br><span class="line">if %errorlevel%==1 goto cmd1</span><br><span class="line">exit</span><br><span class="line">:cmd1</span><br><span class="line">reg.exe add &quot;HKCU\Software\Classes\CLSID\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\InprocServer32&quot; /f /ve</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">start explorer.exe</span><br><span class="line">exit</span><br><span class="line">:cmd2</span><br><span class="line">reg.exe delete &quot;HKCU\Software\Classes\CLSID\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;&quot; /f</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">start explorer.exe</span><br><span class="line">exit</span><br></pre></td></tr></table></figure> 2. 将文件的后缀名改成<code>.bat</code>格式如果你的电脑后缀名没有打开的话，可以去<ahref="https://cn.bing.com/search?q=如何显示文件后缀名">这里</a>查看 3.打开你的<code>.bat</code>文件，输入1返回win10样式，输入2返回win11样式，输入0退出<imgsrc="https://picture-wq3stone.oss-accelerate.aliyuncs.com/picgo/202308101634122.png"alt="uTools_1691656451704" /></p>]]></content>
      
      
      <categories>
          
          <category> 玩转电脑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
